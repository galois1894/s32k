   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"tasks.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.global	pxCurrentTCB
  21              		.section	.bss.pxCurrentTCB,"aw",%nobits
  22              		.align	2
  25              	pxCurrentTCB:
  26 0000 00000000 		.space	4
  27              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  28              		.align	2
  31              	pxReadyTasksLists:
  32 0000 00000000 		.space	160
  32      00000000 
  32      00000000 
  32      00000000 
  32      00000000 
  33              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  34              		.align	2
  37              	xDelayedTaskList1:
  38 0000 00000000 		.space	20
  38      00000000 
  38      00000000 
  38      00000000 
  38      00000000 
  39              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  40              		.align	2
  43              	xDelayedTaskList2:
  44 0000 00000000 		.space	20
  44      00000000 
  44      00000000 
  44      00000000 
  44      00000000 
  45              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  46              		.align	2
  49              	pxDelayedTaskList:
  50 0000 00000000 		.space	4
  51              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  52              		.align	2
  55              	pxOverflowDelayedTaskList:
  56 0000 00000000 		.space	4
  57              		.section	.bss.xPendingReadyList,"aw",%nobits
  58              		.align	2
  61              	xPendingReadyList:
  62 0000 00000000 		.space	20
  62      00000000 
  62      00000000 
  62      00000000 
  62      00000000 
  63              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  64              		.align	2
  67              	xTasksWaitingTermination:
  68 0000 00000000 		.space	20
  68      00000000 
  68      00000000 
  68      00000000 
  68      00000000 
  69              		.section	.bss.uxTasksDeleted,"aw",%nobits
  70              		.align	2
  73              	uxTasksDeleted:
  74 0000 00000000 		.space	4
  75              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  76              		.align	2
  79              	xSuspendedTaskList:
  80 0000 00000000 		.space	20
  80      00000000 
  80      00000000 
  80      00000000 
  80      00000000 
  81              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  82              		.align	2
  85              	uxCurrentNumberOfTasks:
  86 0000 00000000 		.space	4
  87              		.section	.bss.xTickCount,"aw",%nobits
  88              		.align	2
  91              	xTickCount:
  92 0000 00000000 		.space	4
  93              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  94              		.align	2
  97              	uxTopReadyPriority:
  98 0000 00000000 		.space	4
  99              		.section	.bss.xSchedulerRunning,"aw",%nobits
 100              		.align	2
 103              	xSchedulerRunning:
 104 0000 00000000 		.space	4
 105              		.section	.bss.uxPendedTicks,"aw",%nobits
 106              		.align	2
 109              	uxPendedTicks:
 110 0000 00000000 		.space	4
 111              		.section	.bss.xYieldPending,"aw",%nobits
 112              		.align	2
 115              	xYieldPending:
 116 0000 00000000 		.space	4
 117              		.section	.bss.xNumOfOverflows,"aw",%nobits
 118              		.align	2
 121              	xNumOfOverflows:
 122 0000 00000000 		.space	4
 123              		.section	.bss.uxTaskNumber,"aw",%nobits
 124              		.align	2
 127              	uxTaskNumber:
 128 0000 00000000 		.space	4
 129              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 130              		.align	2
 133              	xNextTaskUnblockTime:
 134 0000 00000000 		.space	4
 135              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 136              		.align	2
 139              	uxSchedulerSuspended:
 140 0000 00000000 		.space	4
 141              		.section	.text.xTaskGenericCreate,"ax",%progbits
 142              		.align	2
 143              		.global	xTaskGenericCreate
 144              		.thumb
 145              		.thumb_func
 147              	xTaskGenericCreate:
 148              	.LFB4:
 149              		.file 1 "../FreeRTOS/tasks.c"
   1:../FreeRTOS/tasks.c **** /*
   2:../FreeRTOS/tasks.c ****     FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:../FreeRTOS/tasks.c ****     All rights reserved
   4:../FreeRTOS/tasks.c **** 
   5:../FreeRTOS/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:../FreeRTOS/tasks.c **** 
   7:../FreeRTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:../FreeRTOS/tasks.c **** 
   9:../FreeRTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:../FreeRTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:../FreeRTOS/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  12:../FreeRTOS/tasks.c **** 
  13:../FreeRTOS/tasks.c ****     ***************************************************************************
  14:../FreeRTOS/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:../FreeRTOS/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:../FreeRTOS/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:../FreeRTOS/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:../FreeRTOS/tasks.c ****     ***************************************************************************
  19:../FreeRTOS/tasks.c **** 
  20:../FreeRTOS/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:../FreeRTOS/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:../FreeRTOS/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:../FreeRTOS/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:../FreeRTOS/tasks.c **** 
  25:../FreeRTOS/tasks.c ****     ***************************************************************************
  26:../FreeRTOS/tasks.c ****      *                                                                       *
  27:../FreeRTOS/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:../FreeRTOS/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:../FreeRTOS/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:../FreeRTOS/tasks.c ****      *    is the industry's de facto standard.                               *
  31:../FreeRTOS/tasks.c ****      *                                                                       *
  32:../FreeRTOS/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:../FreeRTOS/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:../FreeRTOS/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:../FreeRTOS/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:../FreeRTOS/tasks.c ****      *                                                                       *
  37:../FreeRTOS/tasks.c ****     ***************************************************************************
  38:../FreeRTOS/tasks.c **** 
  39:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:../FreeRTOS/tasks.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:../FreeRTOS/tasks.c ****     defined configASSERT()?
  42:../FreeRTOS/tasks.c **** 
  43:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:../FreeRTOS/tasks.c ****     embedded software for free we request you assist our global community by
  45:../FreeRTOS/tasks.c ****     participating in the support forum.
  46:../FreeRTOS/tasks.c **** 
  47:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:../FreeRTOS/tasks.c ****     be as productive as possible as early as possible.  Now you can receive
  49:../FreeRTOS/tasks.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:../FreeRTOS/tasks.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:../FreeRTOS/tasks.c **** 
  52:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:../FreeRTOS/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:../FreeRTOS/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:../FreeRTOS/tasks.c **** 
  56:../FreeRTOS/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:../FreeRTOS/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:../FreeRTOS/tasks.c **** 
  59:../FreeRTOS/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:../FreeRTOS/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:../FreeRTOS/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:../FreeRTOS/tasks.c **** 
  63:../FreeRTOS/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:../FreeRTOS/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:../FreeRTOS/tasks.c ****     mission critical applications that require provable dependability.
  66:../FreeRTOS/tasks.c **** 
  67:../FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  68:../FreeRTOS/tasks.c **** */
  69:../FreeRTOS/tasks.c **** 
  70:../FreeRTOS/tasks.c **** /* Standard includes. */
  71:../FreeRTOS/tasks.c **** #include <stdlib.h>
  72:../FreeRTOS/tasks.c **** #include <string.h>
  73:../FreeRTOS/tasks.c **** 
  74:../FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:../FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:../FreeRTOS/tasks.c **** task.h is included from an application file. */
  77:../FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:../FreeRTOS/tasks.c **** 
  79:../FreeRTOS/tasks.c **** /* FreeRTOS includes. */
  80:../FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  81:../FreeRTOS/tasks.c **** #include "task.h"
  82:../FreeRTOS/tasks.c **** #include "timers.h"
  83:../FreeRTOS/tasks.c **** #include "StackMacros.h"
  84:../FreeRTOS/tasks.c **** 
  85:../FreeRTOS/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:../FreeRTOS/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:../FreeRTOS/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:../FreeRTOS/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:../FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:../FreeRTOS/tasks.c **** 
  91:../FreeRTOS/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:../FreeRTOS/tasks.c **** functions but without including stdio.h here. */
  93:../FreeRTOS/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:../FreeRTOS/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:../FreeRTOS/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:../FreeRTOS/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:../FreeRTOS/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:../FreeRTOS/tasks.c **** 	#include <stdio.h>
  99:../FreeRTOS/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:../FreeRTOS/tasks.c **** 
 101:../FreeRTOS/tasks.c **** /* Sanity check the configuration. */
 102:../FreeRTOS/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
 103:../FreeRTOS/tasks.c **** 	#if( INCLUDE_vTaskSuspend != 1 )
 104:../FreeRTOS/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
 105:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 106:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 107:../FreeRTOS/tasks.c **** 
 108:../FreeRTOS/tasks.c **** /*
 109:../FreeRTOS/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 110:../FreeRTOS/tasks.c ****  */
 111:../FreeRTOS/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 112:../FreeRTOS/tasks.c **** 
 113:../FreeRTOS/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 114:../FreeRTOS/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 115:../FreeRTOS/tasks.c **** 	performed just because a higher priority task has been woken. */
 116:../FreeRTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 117:../FreeRTOS/tasks.c **** #else
 118:../FreeRTOS/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:../FreeRTOS/tasks.c **** #endif
 120:../FreeRTOS/tasks.c **** 
 121:../FreeRTOS/tasks.c **** /* Value that can be assigned to the eNotifyState member of the TCB. */
 122:../FreeRTOS/tasks.c **** typedef enum
 123:../FreeRTOS/tasks.c **** {
 124:../FreeRTOS/tasks.c **** 	eNotWaitingNotification = 0,
 125:../FreeRTOS/tasks.c **** 	eWaitingNotification,
 126:../FreeRTOS/tasks.c **** 	eNotified
 127:../FreeRTOS/tasks.c **** } eNotifyValue;
 128:../FreeRTOS/tasks.c **** 
 129:../FreeRTOS/tasks.c **** /*
 130:../FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 131:../FreeRTOS/tasks.c ****  * and stores task state information, including a pointer to the task's context
 132:../FreeRTOS/tasks.c ****  * (the task's run time environment, including register values)
 133:../FreeRTOS/tasks.c ****  */
 134:../FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
 135:../FreeRTOS/tasks.c **** {
 136:../FreeRTOS/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 137:../FreeRTOS/tasks.c **** 
 138:../FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 139:../FreeRTOS/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 140:../FreeRTOS/tasks.c **** 		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocat
 141:../FreeRTOS/tasks.c **** 	#endif
 142:../FreeRTOS/tasks.c **** 
 143:../FreeRTOS/tasks.c **** 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from d
 144:../FreeRTOS/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 145:../FreeRTOS/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 146:../FreeRTOS/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 147:../FreeRTOS/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 148:../FreeRTOS/tasks.c **** 
 149:../FreeRTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 150:../FreeRTOS/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 151:../FreeRTOS/tasks.c **** 	#endif
 152:../FreeRTOS/tasks.c **** 
 153:../FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 154:../FreeRTOS/tasks.c **** 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do n
 155:../FreeRTOS/tasks.c **** 	#endif
 156:../FreeRTOS/tasks.c **** 
 157:../FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 158:../FreeRTOS/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 159:../FreeRTOS/tasks.c **** 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. 
 160:../FreeRTOS/tasks.c **** 	#endif
 161:../FreeRTOS/tasks.c **** 
 162:../FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 163:../FreeRTOS/tasks.c **** 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 164:../FreeRTOS/tasks.c **** 		UBaseType_t 	uxMutexesHeld;
 165:../FreeRTOS/tasks.c **** 	#endif
 166:../FreeRTOS/tasks.c **** 
 167:../FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 168:../FreeRTOS/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 169:../FreeRTOS/tasks.c **** 	#endif
 170:../FreeRTOS/tasks.c **** 
 171:../FreeRTOS/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 172:../FreeRTOS/tasks.c **** 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 173:../FreeRTOS/tasks.c **** 	#endif
 174:../FreeRTOS/tasks.c **** 
 175:../FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 176:../FreeRTOS/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 177:../FreeRTOS/tasks.c **** 	#endif
 178:../FreeRTOS/tasks.c **** 
 179:../FreeRTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 180:../FreeRTOS/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 181:../FreeRTOS/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 182:../FreeRTOS/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 183:../FreeRTOS/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 184:../FreeRTOS/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 185:../FreeRTOS/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 186:../FreeRTOS/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 187:../FreeRTOS/tasks.c **** 		struct 	_reent xNewLib_reent;
 188:../FreeRTOS/tasks.c **** 	#endif
 189:../FreeRTOS/tasks.c **** 
 190:../FreeRTOS/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 191:../FreeRTOS/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 192:../FreeRTOS/tasks.c **** 		volatile eNotifyValue eNotifyState;
 193:../FreeRTOS/tasks.c **** 	#endif
 194:../FreeRTOS/tasks.c **** 
 195:../FreeRTOS/tasks.c **** } tskTCB;
 196:../FreeRTOS/tasks.c **** 
 197:../FreeRTOS/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 198:../FreeRTOS/tasks.c **** below to enable the use of older kernel aware debuggers. */
 199:../FreeRTOS/tasks.c **** typedef tskTCB TCB_t;
 200:../FreeRTOS/tasks.c **** 
 201:../FreeRTOS/tasks.c **** /*
 202:../FreeRTOS/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 203:../FreeRTOS/tasks.c ****  * be global, rather than file scope.
 204:../FreeRTOS/tasks.c ****  */
 205:../FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 206:../FreeRTOS/tasks.c **** 	#define static
 207:../FreeRTOS/tasks.c **** #endif
 208:../FreeRTOS/tasks.c **** 
 209:../FreeRTOS/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 210:../FreeRTOS/tasks.c **** static variables must be declared volatile. */
 211:../FreeRTOS/tasks.c **** 
 212:../FreeRTOS/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 213:../FreeRTOS/tasks.c **** 
 214:../FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 215:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 216:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 217:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 218:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 219:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 220:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 221:../FreeRTOS/tasks.c **** 
 222:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 223:../FreeRTOS/tasks.c **** 
 224:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 225:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 226:../FreeRTOS/tasks.c **** 
 227:../FreeRTOS/tasks.c **** #endif
 228:../FreeRTOS/tasks.c **** 
 229:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 230:../FreeRTOS/tasks.c **** 
 231:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 232:../FreeRTOS/tasks.c **** 
 233:../FreeRTOS/tasks.c **** #endif
 234:../FreeRTOS/tasks.c **** 
 235:../FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 236:../FreeRTOS/tasks.c **** 
 237:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle tas
 238:../FreeRTOS/tasks.c **** 
 239:../FreeRTOS/tasks.c **** #endif
 240:../FreeRTOS/tasks.c **** 
 241:../FreeRTOS/tasks.c **** /* Other file private variables. --------------------------------*/
 242:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 243:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 244:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 245:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 246:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 247:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 248:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 249:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 250:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 251:../FreeRTOS/tasks.c **** 
 252:../FreeRTOS/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 253:../FreeRTOS/tasks.c **** interrupts must not manipulate the xGenericListItem of a TCB, or any of the
 254:../FreeRTOS/tasks.c **** lists the xGenericListItem can be referenced from, if the scheduler is suspended.
 255:../FreeRTOS/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 256:../FreeRTOS/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 257:../FreeRTOS/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 258:../FreeRTOS/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 259:../FreeRTOS/tasks.c **** accessed from a critical section. */
 260:../FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 261:../FreeRTOS/tasks.c **** 
 262:../FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 263:../FreeRTOS/tasks.c **** 
 264:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 265:../FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 266:../FreeRTOS/tasks.c **** 
 267:../FreeRTOS/tasks.c **** #endif
 268:../FreeRTOS/tasks.c **** 
 269:../FreeRTOS/tasks.c **** /*lint +e956 */
 270:../FreeRTOS/tasks.c **** 
 271:../FreeRTOS/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 272:../FreeRTOS/tasks.c **** 
 273:../FreeRTOS/tasks.c **** /*
 274:../FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 275:../FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 276:../FreeRTOS/tasks.c ****  */
 277:../FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 278:../FreeRTOS/tasks.c **** 
 279:../FreeRTOS/tasks.c **** /*
 280:../FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 281:../FreeRTOS/tasks.c ****  */
 282:../FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 283:../FreeRTOS/tasks.c **** #define tskREADY_CHAR		( 'R' )
 284:../FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 285:../FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 286:../FreeRTOS/tasks.c **** 
 287:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 288:../FreeRTOS/tasks.c **** 
 289:../FreeRTOS/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 290:../FreeRTOS/tasks.c **** 
 291:../FreeRTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 292:../FreeRTOS/tasks.c **** 	performed in a generic way that is not optimised to any particular
 293:../FreeRTOS/tasks.c **** 	microcontroller architecture. */
 294:../FreeRTOS/tasks.c **** 
 295:../FreeRTOS/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 296:../FreeRTOS/tasks.c **** 	state task. */
 297:../FreeRTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 298:../FreeRTOS/tasks.c **** 	{																									\
 299:../FreeRTOS/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 300:../FreeRTOS/tasks.c **** 		{																								\
 301:../FreeRTOS/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 302:../FreeRTOS/tasks.c **** 		}																								\
 303:../FreeRTOS/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 304:../FreeRTOS/tasks.c **** 
 305:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 306:../FreeRTOS/tasks.c **** 
 307:../FreeRTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 308:../FreeRTOS/tasks.c **** 	{																									\
 309:../FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 310:../FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
 311:../FreeRTOS/tasks.c **** 		{																								\
 312:../FreeRTOS/tasks.c **** 			configASSERT( uxTopReadyPriority );															\
 313:../FreeRTOS/tasks.c **** 			--uxTopReadyPriority;																		\
 314:../FreeRTOS/tasks.c **** 		}																								\
 315:../FreeRTOS/tasks.c **** 																										\
 316:../FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 317:../FreeRTOS/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 318:../FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
 319:../FreeRTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 320:../FreeRTOS/tasks.c **** 
 321:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 322:../FreeRTOS/tasks.c **** 
 323:../FreeRTOS/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 324:../FreeRTOS/tasks.c **** 	they are only required when a port optimised method of task selection is
 325:../FreeRTOS/tasks.c **** 	being used. */
 326:../FreeRTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 327:../FreeRTOS/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 328:../FreeRTOS/tasks.c **** 
 329:../FreeRTOS/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 330:../FreeRTOS/tasks.c **** 
 331:../FreeRTOS/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 332:../FreeRTOS/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 333:../FreeRTOS/tasks.c **** 	architecture being used. */
 334:../FreeRTOS/tasks.c **** 
 335:../FreeRTOS/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 336:../FreeRTOS/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 337:../FreeRTOS/tasks.c **** 
 338:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 339:../FreeRTOS/tasks.c **** 
 340:../FreeRTOS/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 341:../FreeRTOS/tasks.c **** 	{																								\
 342:../FreeRTOS/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 343:../FreeRTOS/tasks.c **** 																									\
 344:../FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 345:../FreeRTOS/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 346:../FreeRTOS/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 347:../FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 348:../FreeRTOS/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 349:../FreeRTOS/tasks.c **** 
 350:../FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
 351:../FreeRTOS/tasks.c **** 
 352:../FreeRTOS/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 353:../FreeRTOS/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 354:../FreeRTOS/tasks.c **** 	or suspended list then it won't be in a ready list. */
 355:../FreeRTOS/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 356:../FreeRTOS/tasks.c **** 	{																									\
 357:../FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 358:../FreeRTOS/tasks.c **** 		{																								\
 359:../FreeRTOS/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 360:../FreeRTOS/tasks.c **** 		}																								\
 361:../FreeRTOS/tasks.c **** 	}
 362:../FreeRTOS/tasks.c **** 
 363:../FreeRTOS/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 364:../FreeRTOS/tasks.c **** 
 365:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 366:../FreeRTOS/tasks.c **** 
 367:../FreeRTOS/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 368:../FreeRTOS/tasks.c **** count overflows. */
 369:../FreeRTOS/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 370:../FreeRTOS/tasks.c **** {																									\
 371:../FreeRTOS/tasks.c **** 	List_t *pxTemp;																					\
 372:../FreeRTOS/tasks.c **** 																									\
 373:../FreeRTOS/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 374:../FreeRTOS/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 375:../FreeRTOS/tasks.c **** 																									\
 376:../FreeRTOS/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 377:../FreeRTOS/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 378:../FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 379:../FreeRTOS/tasks.c **** 	xNumOfOverflows++;																				\
 380:../FreeRTOS/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 381:../FreeRTOS/tasks.c **** }
 382:../FreeRTOS/tasks.c **** 
 383:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 384:../FreeRTOS/tasks.c **** 
 385:../FreeRTOS/tasks.c **** /*
 386:../FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 387:../FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.
 388:../FreeRTOS/tasks.c ****  */
 389:../FreeRTOS/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 390:../FreeRTOS/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 391:../FreeRTOS/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 392:../FreeRTOS/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 393:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 394:../FreeRTOS/tasks.c **** 
 395:../FreeRTOS/tasks.c **** /*
 396:../FreeRTOS/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 397:../FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 398:../FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 399:../FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 400:../FreeRTOS/tasks.c ****  */
 401:../FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 402:../FreeRTOS/tasks.c **** 
 403:../FreeRTOS/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 404:../FreeRTOS/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 405:../FreeRTOS/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 406:../FreeRTOS/tasks.c **** is important its value is not updated due to a task priority change while it is
 407:../FreeRTOS/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 408:../FreeRTOS/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 409:../FreeRTOS/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 410:../FreeRTOS/tasks.c **** to its original value when it is released. */
 411:../FreeRTOS/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 412:../FreeRTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 413:../FreeRTOS/tasks.c **** #else
 414:../FreeRTOS/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 415:../FreeRTOS/tasks.c **** #endif
 416:../FreeRTOS/tasks.c **** 
 417:../FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 418:../FreeRTOS/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 419:../FreeRTOS/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 420:../FreeRTOS/tasks.c **** #endif
 421:../FreeRTOS/tasks.c **** 
 422:../FreeRTOS/tasks.c **** #if configUSE_TICK_HOOK > 0
 423:../FreeRTOS/tasks.c **** 	extern void vApplicationTickHook( void );
 424:../FreeRTOS/tasks.c **** #endif
 425:../FreeRTOS/tasks.c **** 
 426:../FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 427:../FreeRTOS/tasks.c **** 
 428:../FreeRTOS/tasks.c **** /*
 429:../FreeRTOS/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 430:../FreeRTOS/tasks.c ****  * into the TCB structure.
 431:../FreeRTOS/tasks.c ****  */
 432:../FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 433:../FreeRTOS/tasks.c **** 
 434:../FreeRTOS/tasks.c **** /**
 435:../FreeRTOS/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 436:../FreeRTOS/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 437:../FreeRTOS/tasks.c ****  * is in any other state.
 438:../FreeRTOS/tasks.c ****  */
 439:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 440:../FreeRTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 441:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 442:../FreeRTOS/tasks.c **** 
 443:../FreeRTOS/tasks.c **** /*
 444:../FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 445:../FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 446:../FreeRTOS/tasks.c ****  */
 447:../FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 448:../FreeRTOS/tasks.c **** 
 449:../FreeRTOS/tasks.c **** /*
 450:../FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 451:../FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 452:../FreeRTOS/tasks.c ****  * creation of the first user task.
 453:../FreeRTOS/tasks.c ****  *
 454:../FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 455:../FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 456:../FreeRTOS/tasks.c ****  *
 457:../FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 458:../FreeRTOS/tasks.c ****  *
 459:../FreeRTOS/tasks.c ****  */
 460:../FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 461:../FreeRTOS/tasks.c **** 
 462:../FreeRTOS/tasks.c **** /*
 463:../FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 464:../FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 465:../FreeRTOS/tasks.c ****  *
 466:../FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 467:../FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 468:../FreeRTOS/tasks.c ****  */
 469:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 470:../FreeRTOS/tasks.c **** 
 471:../FreeRTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 472:../FreeRTOS/tasks.c **** 
 473:../FreeRTOS/tasks.c **** #endif
 474:../FreeRTOS/tasks.c **** 
 475:../FreeRTOS/tasks.c **** /*
 476:../FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 477:../FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 478:../FreeRTOS/tasks.c ****  * and its TCB deleted.
 479:../FreeRTOS/tasks.c ****  */
 480:../FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 481:../FreeRTOS/tasks.c **** 
 482:../FreeRTOS/tasks.c **** /*
 483:../FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 484:../FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 485:../FreeRTOS/tasks.c ****  */
 486:../FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 487:../FreeRTOS/tasks.c **** 
 488:../FreeRTOS/tasks.c **** /*
 489:../FreeRTOS/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 490:../FreeRTOS/tasks.c ****  * allocation was successful.
 491:../FreeRTOS/tasks.c ****  */
 492:../FreeRTOS/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 493:../FreeRTOS/tasks.c **** 
 494:../FreeRTOS/tasks.c **** /*
 495:../FreeRTOS/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 496:../FreeRTOS/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 497:../FreeRTOS/tasks.c ****  * a suspended list, etc.).
 498:../FreeRTOS/tasks.c ****  *
 499:../FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 500:../FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 501:../FreeRTOS/tasks.c ****  */
 502:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 503:../FreeRTOS/tasks.c **** 
 504:../FreeRTOS/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
 505:../FreeRTOS/tasks.c **** 
 506:../FreeRTOS/tasks.c **** #endif
 507:../FreeRTOS/tasks.c **** 
 508:../FreeRTOS/tasks.c **** /*
 509:../FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 510:../FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 511:../FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 512:../FreeRTOS/tasks.c ****  */
 513:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 514:../FreeRTOS/tasks.c **** 
 515:../FreeRTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 516:../FreeRTOS/tasks.c **** 
 517:../FreeRTOS/tasks.c **** #endif
 518:../FreeRTOS/tasks.c **** 
 519:../FreeRTOS/tasks.c **** /*
 520:../FreeRTOS/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 521:../FreeRTOS/tasks.c ****  * next move a task from the Blocked state to the Running state.
 522:../FreeRTOS/tasks.c ****  *
 523:../FreeRTOS/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 524:../FreeRTOS/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 525:../FreeRTOS/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 526:../FreeRTOS/tasks.c ****  * set to a value other than 1.
 527:../FreeRTOS/tasks.c ****  */
 528:../FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 529:../FreeRTOS/tasks.c **** 
 530:../FreeRTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 531:../FreeRTOS/tasks.c **** 
 532:../FreeRTOS/tasks.c **** #endif
 533:../FreeRTOS/tasks.c **** 
 534:../FreeRTOS/tasks.c **** /*
 535:../FreeRTOS/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 536:../FreeRTOS/tasks.c ****  * will exit the Blocked state.
 537:../FreeRTOS/tasks.c ****  */
 538:../FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 539:../FreeRTOS/tasks.c **** 
 540:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 541:../FreeRTOS/tasks.c **** 
 542:../FreeRTOS/tasks.c **** 	/*
 543:../FreeRTOS/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 544:../FreeRTOS/tasks.c **** 	 * human readable tables of task information.
 545:../FreeRTOS/tasks.c **** 	 */
 546:../FreeRTOS/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
 547:../FreeRTOS/tasks.c **** 
 548:../FreeRTOS/tasks.c **** #endif
 549:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 550:../FreeRTOS/tasks.c **** 
 551:../FreeRTOS/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 552:../FreeRTOS/tasks.c **** {
 150              		.loc 1 552 0
 151              		.cfi_startproc
 152              		@ args = 16, pretend = 0, frame = 40
 153              		@ frame_needed = 1, uses_anonymous_args = 0
 154 0000 80B5     		push	{r7, lr}
 155              		.cfi_def_cfa_offset 8
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 8CB0     		sub	sp, sp, #48
 159              		.cfi_def_cfa_offset 56
 160 0004 02AF     		add	r7, sp, #8
 161              		.cfi_def_cfa 7, 48
 162 0006 F860     		str	r0, [r7, #12]
 163 0008 B960     		str	r1, [r7, #8]
 164 000a 3B60     		str	r3, [r7]
 165 000c 1346     		mov	r3, r2	@ movhi
 166 000e FB80     		strh	r3, [r7, #6]	@ movhi
 553:../FreeRTOS/tasks.c **** BaseType_t xReturn;
 554:../FreeRTOS/tasks.c **** TCB_t * pxNewTCB;
 555:../FreeRTOS/tasks.c **** StackType_t *pxTopOfStack;
 556:../FreeRTOS/tasks.c **** 
 557:../FreeRTOS/tasks.c **** 	configASSERT( pxTaskCode );
 167              		.loc 1 557 0
 168 0010 FB68     		ldr	r3, [r7, #12]
 169 0012 002B     		cmp	r3, #0
 170 0014 09D1     		bne	.L2
 171              	.LBB102:
 172              	.LBB103:
 173              		.file 2 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../F
   1:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*
   2:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     All rights reserved
   4:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
   5:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
   7:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
   9:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  12:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  13:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  14:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  19:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  20:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  25:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  26:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  27:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    is the industry's de facto standard.                               *
  31:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  32:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****      *                                                                       *
  37:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     ***************************************************************************
  38:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  39:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     defined configASSERT()?
  42:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  43:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     embedded software for free we request you assist our global community by
  45:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     participating in the support forum.
  46:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  47:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  52:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  56:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  59:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  63:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     mission critical applications that require provable dependability.
  66:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  67:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****     1 tab == 4 spaces!
  68:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** */
  69:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  70:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  71:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef PORTMACRO_H
  72:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define PORTMACRO_H
  73:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  74:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #ifdef __cplusplus
  75:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** extern "C" {
  76:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif
  77:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  78:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------
  79:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  * Port specific definitions.
  80:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  *
  81:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  * given hardware and compiler.
  83:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  *
  84:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  * These settings should not be altered.
  85:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  *-----------------------------------------------------------
  86:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h ****  */
  87:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  88:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Type definitions. */
  89:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portCHAR		char
  90:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portFLOAT		float
  91:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portDOUBLE		double
  92:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portLONG		long
  93:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portSHORT		short
  94:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portBASE_TYPE	long
  96:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
  97:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  98:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** typedef long BaseType_t;
  99:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** typedef unsigned long UBaseType_t;
 100:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 101:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	typedef uint16_t TickType_t;
 103:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 104:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #else
 105:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	typedef uint32_t TickType_t;
 106:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 108:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	not need to be guarded with a critical section. */
 110:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 112:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 113:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 114:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Architecture specifics. */
 115:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 119:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 120:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Scheduler utilities. */
 121:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portYIELD() 															\
 122:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** {																				\
 123:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 																				\
 126:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	__asm volatile( "dsb" );													\
 129:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	__asm volatile( "isb" );													\
 130:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** }
 131:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 132:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 137:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 138:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Critical section management. */
 139:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** extern void vPortEnterCritical( void );
 140:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** extern void vPortExitCritical( void );
 141:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 148:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 149:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 150:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** (which build with all the ports) will build. */
 153:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 155:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 156:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 157:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Tickless idle/low power functionality. */
 158:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 161:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 162:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 163:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 164:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* Architecture specific optimisations. */
 165:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 168:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 169:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 171:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* Generic helper function. */
 172:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	{
 174:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	uint8_t ucReturn;
 175:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 176:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		return ucReturn;
 178:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	}
 179:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 180:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* Check the configuration. */
 181:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#endif
 184:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 185:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 189:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/*-----------------------------------------------------------*/
 190:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 191:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - ucPort
 192:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 193:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 195:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 196:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 197:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #ifdef configASSERT
 198:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 201:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 202:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /* portNOP() is not required by this port. */
 203:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #define portNOP()
 204:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 205:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #ifndef portFORCE_INLINE
 206:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 207:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** #endif
 208:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 209:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 210:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 211:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 212:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** {
 213:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** uint32_t ulNewBASEPRI;
 214:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	__asm volatile
 174              		.loc 2 215 0 discriminator 1
 175              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 176 0016 4FF00703 			mov r3, #7												
 177 001a 83F31188 		msr basepri, r3											
 178 001e BFF36F8F 		isb														
 179 0022 BFF34F8F 		dsb														
 180              	
 181              	@ 0 "" 2
 182              		.thumb
 183 0026 BB61     		str	r3, [r7, #24]
 184              	.L3:
 185              	.LBE103:
 186              	.LBE102:
 187              		.loc 1 557 0 discriminator 1
 188 0028 FEE7     		b	.L3
 189              	.L2:
 558:../FreeRTOS/tasks.c **** 	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMA
 190              		.loc 1 558 0
 191 002a 3B6B     		ldr	r3, [r7, #48]
 192 002c 072B     		cmp	r3, #7
 193 002e 09D9     		bls	.L4
 194              	.LBB104:
 195              	.LBB105:
 196              		.loc 2 215 0 discriminator 1
 197              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 198 0030 4FF00703 			mov r3, #7												
 199 0034 83F31188 		msr basepri, r3											
 200 0038 BFF36F8F 		isb														
 201 003c BFF34F8F 		dsb														
 202              	
 203              	@ 0 "" 2
 204              		.thumb
 205 0040 7B61     		str	r3, [r7, #20]
 206              	.L5:
 207              	.LBE105:
 208              	.LBE104:
 209              		.loc 1 558 0 discriminator 2
 210 0042 FEE7     		b	.L5
 211              	.L4:
 559:../FreeRTOS/tasks.c **** 
 560:../FreeRTOS/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 561:../FreeRTOS/tasks.c **** 	checking that the allocation was successful. */
 562:../FreeRTOS/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 212              		.loc 1 562 0
 213 0044 FB88     		ldrh	r3, [r7, #6]
 214 0046 1846     		mov	r0, r3
 215 0048 B96B     		ldr	r1, [r7, #56]
 216 004a FFF7FEFF 		bl	prvAllocateTCBAndStack
 217 004e 3862     		str	r0, [r7, #32]
 563:../FreeRTOS/tasks.c **** 
 564:../FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 218              		.loc 1 564 0
 219 0050 3B6A     		ldr	r3, [r7, #32]
 220 0052 002B     		cmp	r3, #0
 221 0054 76D0     		beq	.L6
 565:../FreeRTOS/tasks.c **** 	{
 566:../FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 567:../FreeRTOS/tasks.c **** 			/* Should the task be created in privileged mode? */
 568:../FreeRTOS/tasks.c **** 			BaseType_t xRunPrivileged;
 569:../FreeRTOS/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 570:../FreeRTOS/tasks.c **** 			{
 571:../FreeRTOS/tasks.c **** 				xRunPrivileged = pdTRUE;
 572:../FreeRTOS/tasks.c **** 			}
 573:../FreeRTOS/tasks.c **** 			else
 574:../FreeRTOS/tasks.c **** 			{
 575:../FreeRTOS/tasks.c **** 				xRunPrivileged = pdFALSE;
 576:../FreeRTOS/tasks.c **** 			}
 577:../FreeRTOS/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 578:../FreeRTOS/tasks.c **** 
 579:../FreeRTOS/tasks.c **** 			if( puxStackBuffer != NULL )
 580:../FreeRTOS/tasks.c **** 			{
 581:../FreeRTOS/tasks.c **** 				/* The application provided its own stack.  Note this so no
 582:../FreeRTOS/tasks.c **** 				attempt is made to delete the stack should that task be
 583:../FreeRTOS/tasks.c **** 				deleted. */
 584:../FreeRTOS/tasks.c **** 				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
 585:../FreeRTOS/tasks.c **** 			}
 586:../FreeRTOS/tasks.c **** 			else
 587:../FreeRTOS/tasks.c **** 			{
 588:../FreeRTOS/tasks.c **** 				/* The stack was allocated dynamically.  Note this so it can be
 589:../FreeRTOS/tasks.c **** 				deleted again if the task is deleted. */
 590:../FreeRTOS/tasks.c **** 				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
 591:../FreeRTOS/tasks.c **** 			}
 592:../FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 593:../FreeRTOS/tasks.c **** 
 594:../FreeRTOS/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 595:../FreeRTOS/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or vice versa.
 596:../FreeRTOS/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 597:../FreeRTOS/tasks.c **** 		required by the port. */
 598:../FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 599:../FreeRTOS/tasks.c **** 		{
 600:../FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 222              		.loc 1 600 0
 223 0056 3B6A     		ldr	r3, [r7, #32]
 224 0058 1A6B     		ldr	r2, [r3, #48]
 225 005a FB88     		ldrh	r3, [r7, #6]
 226 005c 03F18043 		add	r3, r3, #1073741824
 227 0060 013B     		subs	r3, r3, #1
 228 0062 9B00     		lsls	r3, r3, #2
 229 0064 1344     		add	r3, r3, r2
 230 0066 FB61     		str	r3, [r7, #28]
 601:../FreeRTOS/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINT
 231              		.loc 1 601 0
 232 0068 FB69     		ldr	r3, [r7, #28]
 233 006a 23F00703 		bic	r3, r3, #7
 234 006e FB61     		str	r3, [r7, #28]
 602:../FreeRTOS/tasks.c **** 
 603:../FreeRTOS/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 604:../FreeRTOS/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_AL
 235              		.loc 1 604 0
 236 0070 FB69     		ldr	r3, [r7, #28]
 237 0072 03F00703 		and	r3, r3, #7
 238 0076 002B     		cmp	r3, #0
 239 0078 09D0     		beq	.L7
 240              	.LBB106:
 241              	.LBB107:
 242              		.loc 2 215 0 discriminator 1
 243              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 244 007a 4FF00703 			mov r3, #7												
 245 007e 83F31188 		msr basepri, r3											
 246 0082 BFF36F8F 		isb														
 247 0086 BFF34F8F 		dsb														
 248              	
 249              	@ 0 "" 2
 250              		.thumb
 251 008a 3B61     		str	r3, [r7, #16]
 252              	.L8:
 253              	.LBE107:
 254              	.LBE106:
 255              		.loc 1 604 0 discriminator 3
 256 008c FEE7     		b	.L8
 257              	.L7:
 605:../FreeRTOS/tasks.c **** 		}
 606:../FreeRTOS/tasks.c **** 		#else /* portSTACK_GROWTH */
 607:../FreeRTOS/tasks.c **** 		{
 608:../FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 609:../FreeRTOS/tasks.c **** 
 610:../FreeRTOS/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 611:../FreeRTOS/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBY
 612:../FreeRTOS/tasks.c **** 
 613:../FreeRTOS/tasks.c **** 			/* If we want to use stack checking on architectures that use
 614:../FreeRTOS/tasks.c **** 			a positive stack growth direction then we also need to store the
 615:../FreeRTOS/tasks.c **** 			other extreme of the stack space. */
 616:../FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 617:../FreeRTOS/tasks.c **** 		}
 618:../FreeRTOS/tasks.c **** 		#endif /* portSTACK_GROWTH */
 619:../FreeRTOS/tasks.c **** 
 620:../FreeRTOS/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 621:../FreeRTOS/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 258              		.loc 1 621 0
 259 008e FB88     		ldrh	r3, [r7, #6]
 260 0090 0093     		str	r3, [sp]
 261 0092 386A     		ldr	r0, [r7, #32]
 262 0094 B968     		ldr	r1, [r7, #8]
 263 0096 3A6B     		ldr	r2, [r7, #48]
 264 0098 FB6B     		ldr	r3, [r7, #60]
 265 009a FFF7FEFF 		bl	prvInitialiseTCBVariables
 622:../FreeRTOS/tasks.c **** 
 623:../FreeRTOS/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 624:../FreeRTOS/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 625:../FreeRTOS/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 626:../FreeRTOS/tasks.c **** 		the	top of stack variable is updated. */
 627:../FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 628:../FreeRTOS/tasks.c **** 		{
 629:../FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 630:../FreeRTOS/tasks.c **** 		}
 631:../FreeRTOS/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 632:../FreeRTOS/tasks.c **** 		{
 633:../FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 266              		.loc 1 633 0
 267 009e F869     		ldr	r0, [r7, #28]
 268 00a0 F968     		ldr	r1, [r7, #12]
 269 00a2 3A68     		ldr	r2, [r7]
 270 00a4 FFF7FEFF 		bl	pxPortInitialiseStack
 271 00a8 0246     		mov	r2, r0
 272 00aa 3B6A     		ldr	r3, [r7, #32]
 273 00ac 1A60     		str	r2, [r3]
 634:../FreeRTOS/tasks.c **** 		}
 635:../FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 636:../FreeRTOS/tasks.c **** 
 637:../FreeRTOS/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 274              		.loc 1 637 0
 275 00ae 7B6B     		ldr	r3, [r7, #52]
 276 00b0 002B     		cmp	r3, #0
 277 00b2 02D0     		beq	.L9
 638:../FreeRTOS/tasks.c **** 		{
 639:../FreeRTOS/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 640:../FreeRTOS/tasks.c **** 			task can use this as a handle to delete the task later if
 641:../FreeRTOS/tasks.c **** 			required.*/
 642:../FreeRTOS/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 278              		.loc 1 642 0
 279 00b4 7B6B     		ldr	r3, [r7, #52]
 280 00b6 3A6A     		ldr	r2, [r7, #32]
 281 00b8 1A60     		str	r2, [r3]
 282              	.L9:
 643:../FreeRTOS/tasks.c **** 		}
 644:../FreeRTOS/tasks.c **** 		else
 645:../FreeRTOS/tasks.c **** 		{
 646:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 647:../FreeRTOS/tasks.c **** 		}
 648:../FreeRTOS/tasks.c **** 
 649:../FreeRTOS/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 650:../FreeRTOS/tasks.c **** 		updated. */
 651:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 283              		.loc 1 651 0
 284 00ba FFF7FEFF 		bl	vPortEnterCritical
 652:../FreeRTOS/tasks.c **** 		{
 653:../FreeRTOS/tasks.c **** 			uxCurrentNumberOfTasks++;
 285              		.loc 1 653 0
 286 00be 2A4B     		ldr	r3, .L15
 287 00c0 1B68     		ldr	r3, [r3]
 288 00c2 0133     		adds	r3, r3, #1
 289 00c4 284A     		ldr	r2, .L15
 290 00c6 1360     		str	r3, [r2]
 654:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB == NULL )
 291              		.loc 1 654 0
 292 00c8 284B     		ldr	r3, .L15+4
 293 00ca 1B68     		ldr	r3, [r3]
 294 00cc 002B     		cmp	r3, #0
 295 00ce 09D1     		bne	.L10
 655:../FreeRTOS/tasks.c **** 			{
 656:../FreeRTOS/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 657:../FreeRTOS/tasks.c **** 				the suspended state - make this the current task. */
 658:../FreeRTOS/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 296              		.loc 1 658 0
 297 00d0 264A     		ldr	r2, .L15+4
 298 00d2 3B6A     		ldr	r3, [r7, #32]
 299 00d4 1360     		str	r3, [r2]
 659:../FreeRTOS/tasks.c **** 
 660:../FreeRTOS/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 300              		.loc 1 660 0
 301 00d6 244B     		ldr	r3, .L15
 302 00d8 1B68     		ldr	r3, [r3]
 303 00da 012B     		cmp	r3, #1
 304 00dc 0FD1     		bne	.L11
 661:../FreeRTOS/tasks.c **** 				{
 662:../FreeRTOS/tasks.c **** 					/* This is the first task to be created so do the preliminary
 663:../FreeRTOS/tasks.c **** 					initialisation required.  We will not recover if this call
 664:../FreeRTOS/tasks.c **** 					fails, but we will report the failure. */
 665:../FreeRTOS/tasks.c **** 					prvInitialiseTaskLists();
 305              		.loc 1 665 0
 306 00de FFF7FEFF 		bl	prvInitialiseTaskLists
 307 00e2 0CE0     		b	.L11
 308              	.L10:
 666:../FreeRTOS/tasks.c **** 				}
 667:../FreeRTOS/tasks.c **** 				else
 668:../FreeRTOS/tasks.c **** 				{
 669:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 670:../FreeRTOS/tasks.c **** 				}
 671:../FreeRTOS/tasks.c **** 			}
 672:../FreeRTOS/tasks.c **** 			else
 673:../FreeRTOS/tasks.c **** 			{
 674:../FreeRTOS/tasks.c **** 				/* If the scheduler is not already running, make this task the
 675:../FreeRTOS/tasks.c **** 				current task if it is the highest priority task to be created
 676:../FreeRTOS/tasks.c **** 				so far. */
 677:../FreeRTOS/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 309              		.loc 1 677 0
 310 00e4 224B     		ldr	r3, .L15+8
 311 00e6 1B68     		ldr	r3, [r3]
 312 00e8 002B     		cmp	r3, #0
 313 00ea 08D1     		bne	.L11
 678:../FreeRTOS/tasks.c **** 				{
 679:../FreeRTOS/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 314              		.loc 1 679 0
 315 00ec 1F4B     		ldr	r3, .L15+4
 316 00ee 1B68     		ldr	r3, [r3]
 317 00f0 DA6A     		ldr	r2, [r3, #44]
 318 00f2 3B6B     		ldr	r3, [r7, #48]
 319 00f4 9A42     		cmp	r2, r3
 320 00f6 02D8     		bhi	.L11
 680:../FreeRTOS/tasks.c **** 					{
 681:../FreeRTOS/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 321              		.loc 1 681 0
 322 00f8 1C4A     		ldr	r2, .L15+4
 323 00fa 3B6A     		ldr	r3, [r7, #32]
 324 00fc 1360     		str	r3, [r2]
 325              	.L11:
 682:../FreeRTOS/tasks.c **** 					}
 683:../FreeRTOS/tasks.c **** 					else
 684:../FreeRTOS/tasks.c **** 					{
 685:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
 686:../FreeRTOS/tasks.c **** 					}
 687:../FreeRTOS/tasks.c **** 				}
 688:../FreeRTOS/tasks.c **** 				else
 689:../FreeRTOS/tasks.c **** 				{
 690:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 691:../FreeRTOS/tasks.c **** 				}
 692:../FreeRTOS/tasks.c **** 			}
 693:../FreeRTOS/tasks.c **** 
 694:../FreeRTOS/tasks.c **** 			uxTaskNumber++;
 326              		.loc 1 694 0
 327 00fe 1D4B     		ldr	r3, .L15+12
 328 0100 1B68     		ldr	r3, [r3]
 329 0102 0133     		adds	r3, r3, #1
 330 0104 1B4A     		ldr	r2, .L15+12
 331 0106 1360     		str	r3, [r2]
 695:../FreeRTOS/tasks.c **** 
 696:../FreeRTOS/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 697:../FreeRTOS/tasks.c **** 			{
 698:../FreeRTOS/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 699:../FreeRTOS/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 700:../FreeRTOS/tasks.c **** 			}
 701:../FreeRTOS/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 702:../FreeRTOS/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 703:../FreeRTOS/tasks.c **** 
 704:../FreeRTOS/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 332              		.loc 1 704 0
 333 0108 3B6A     		ldr	r3, [r7, #32]
 334 010a DB6A     		ldr	r3, [r3, #44]
 335 010c 1A46     		mov	r2, r3
 336 010e 0123     		movs	r3, #1
 337 0110 03FA02F2 		lsl	r2, r3, r2
 338 0114 184B     		ldr	r3, .L15+16
 339 0116 1B68     		ldr	r3, [r3]
 340 0118 1343     		orrs	r3, r3, r2
 341 011a 174A     		ldr	r2, .L15+16
 342 011c 1360     		str	r3, [r2]
 343 011e 3B6A     		ldr	r3, [r7, #32]
 344 0120 DA6A     		ldr	r2, [r3, #44]
 345 0122 1346     		mov	r3, r2
 346 0124 9B00     		lsls	r3, r3, #2
 347 0126 1344     		add	r3, r3, r2
 348 0128 9B00     		lsls	r3, r3, #2
 349 012a 144A     		ldr	r2, .L15+20
 350 012c 1A44     		add	r2, r2, r3
 351 012e 3B6A     		ldr	r3, [r7, #32]
 352 0130 0433     		adds	r3, r3, #4
 353 0132 1046     		mov	r0, r2
 354 0134 1946     		mov	r1, r3
 355 0136 FFF7FEFF 		bl	vListInsertEnd
 705:../FreeRTOS/tasks.c **** 
 706:../FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 356              		.loc 1 706 0
 357 013a 0123     		movs	r3, #1
 358 013c 7B62     		str	r3, [r7, #36]
 707:../FreeRTOS/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 708:../FreeRTOS/tasks.c **** 		}
 709:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 359              		.loc 1 709 0
 360 013e FFF7FEFF 		bl	vPortExitCritical
 361 0142 02E0     		b	.L12
 362              	.L6:
 710:../FreeRTOS/tasks.c **** 	}
 711:../FreeRTOS/tasks.c **** 	else
 712:../FreeRTOS/tasks.c **** 	{
 713:../FreeRTOS/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 363              		.loc 1 713 0
 364 0144 4FF0FF33 		mov	r3, #-1
 365 0148 7B62     		str	r3, [r7, #36]
 366              	.L12:
 714:../FreeRTOS/tasks.c **** 		traceTASK_CREATE_FAILED();
 715:../FreeRTOS/tasks.c **** 	}
 716:../FreeRTOS/tasks.c **** 
 717:../FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 367              		.loc 1 717 0
 368 014a 7B6A     		ldr	r3, [r7, #36]
 369 014c 012B     		cmp	r3, #1
 370 014e 05D1     		bne	.L13
 718:../FreeRTOS/tasks.c **** 	{
 719:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 371              		.loc 1 719 0
 372 0150 074B     		ldr	r3, .L15+8
 373 0152 1B68     		ldr	r3, [r3]
 374 0154 002B     		cmp	r3, #0
 375 0156 01D0     		beq	.L13
 720:../FreeRTOS/tasks.c **** 		{
 721:../FreeRTOS/tasks.c **** 			/* If the created task is of a higher priority than the current task
 722:../FreeRTOS/tasks.c **** 			then it should run now. */
 723:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 376              		.loc 1 723 0
 377 0158 044B     		ldr	r3, .L15+4
 378 015a 1B68     		ldr	r3, [r3]
 379              	.L13:
 724:../FreeRTOS/tasks.c **** 			{
 725:../FreeRTOS/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 726:../FreeRTOS/tasks.c **** 			}
 727:../FreeRTOS/tasks.c **** 			else
 728:../FreeRTOS/tasks.c **** 			{
 729:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 730:../FreeRTOS/tasks.c **** 			}
 731:../FreeRTOS/tasks.c **** 		}
 732:../FreeRTOS/tasks.c **** 		else
 733:../FreeRTOS/tasks.c **** 		{
 734:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 735:../FreeRTOS/tasks.c **** 		}
 736:../FreeRTOS/tasks.c **** 	}
 737:../FreeRTOS/tasks.c **** 
 738:../FreeRTOS/tasks.c **** 	return xReturn;
 380              		.loc 1 738 0
 381 015c 7B6A     		ldr	r3, [r7, #36]
 739:../FreeRTOS/tasks.c **** }
 382              		.loc 1 739 0
 383 015e 1846     		mov	r0, r3
 384 0160 2837     		adds	r7, r7, #40
 385              		.cfi_def_cfa_offset 8
 386 0162 BD46     		mov	sp, r7
 387              		.cfi_def_cfa_register 13
 388              		@ sp needed
 389 0164 80BD     		pop	{r7, pc}
 390              	.L16:
 391 0166 00BF     		.align	2
 392              	.L15:
 393 0168 00000000 		.word	uxCurrentNumberOfTasks
 394 016c 00000000 		.word	pxCurrentTCB
 395 0170 00000000 		.word	xSchedulerRunning
 396 0174 00000000 		.word	uxTaskNumber
 397 0178 00000000 		.word	uxTopReadyPriority
 398 017c 00000000 		.word	pxReadyTasksLists
 399              		.cfi_endproc
 400              	.LFE4:
 402              		.section	.text.vTaskDelete,"ax",%progbits
 403              		.align	2
 404              		.global	vTaskDelete
 405              		.thumb
 406              		.thumb_func
 408              	vTaskDelete:
 409              	.LFB5:
 740:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 741:../FreeRTOS/tasks.c **** 
 742:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 743:../FreeRTOS/tasks.c **** 
 744:../FreeRTOS/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 745:../FreeRTOS/tasks.c **** 	{
 410              		.loc 1 745 0
 411              		.cfi_startproc
 412              		@ args = 0, pretend = 0, frame = 16
 413              		@ frame_needed = 1, uses_anonymous_args = 0
 414 0000 80B5     		push	{r7, lr}
 415              		.cfi_def_cfa_offset 8
 416              		.cfi_offset 7, -8
 417              		.cfi_offset 14, -4
 418 0002 84B0     		sub	sp, sp, #16
 419              		.cfi_def_cfa_offset 24
 420 0004 00AF     		add	r7, sp, #0
 421              		.cfi_def_cfa_register 7
 422 0006 7860     		str	r0, [r7, #4]
 746:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
 747:../FreeRTOS/tasks.c **** 
 748:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 423              		.loc 1 748 0
 424 0008 FFF7FEFF 		bl	vPortEnterCritical
 749:../FreeRTOS/tasks.c **** 		{
 750:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 751:../FreeRTOS/tasks.c **** 			being deleted. */
 752:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 425              		.loc 1 752 0
 426 000c 7B68     		ldr	r3, [r7, #4]
 427 000e 002B     		cmp	r3, #0
 428 0010 02D1     		bne	.L18
 429              		.loc 1 752 0 is_stmt 0 discriminator 1
 430 0012 334B     		ldr	r3, .L27
 431 0014 1B68     		ldr	r3, [r3]
 432 0016 00E0     		b	.L19
 433              	.L18:
 434              		.loc 1 752 0 discriminator 2
 435 0018 7B68     		ldr	r3, [r7, #4]
 436              	.L19:
 437              		.loc 1 752 0 discriminator 4
 438 001a FB60     		str	r3, [r7, #12]
 753:../FreeRTOS/tasks.c **** 
 754:../FreeRTOS/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 755:../FreeRTOS/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 756:../FreeRTOS/tasks.c **** 			the termination list and free up any memory allocated by the
 757:../FreeRTOS/tasks.c **** 			scheduler for the TCB and stack. */
 758:../FreeRTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 439              		.loc 1 758 0 is_stmt 1 discriminator 4
 440 001c FB68     		ldr	r3, [r7, #12]
 441 001e 0433     		adds	r3, r3, #4
 442 0020 1846     		mov	r0, r3
 443 0022 FFF7FEFF 		bl	uxListRemove
 444 0026 0346     		mov	r3, r0
 445 0028 002B     		cmp	r3, #0
 446 002a 15D1     		bne	.L20
 759:../FreeRTOS/tasks.c **** 			{
 760:../FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 447              		.loc 1 760 0
 448 002c FB68     		ldr	r3, [r7, #12]
 449 002e DA6A     		ldr	r2, [r3, #44]
 450 0030 2C49     		ldr	r1, .L27+4
 451 0032 1346     		mov	r3, r2
 452 0034 9B00     		lsls	r3, r3, #2
 453 0036 1344     		add	r3, r3, r2
 454 0038 9B00     		lsls	r3, r3, #2
 455 003a 0B44     		add	r3, r3, r1
 456 003c 1B68     		ldr	r3, [r3]
 457 003e 002B     		cmp	r3, #0
 458 0040 0AD1     		bne	.L20
 459              		.loc 1 760 0 is_stmt 0 discriminator 1
 460 0042 FB68     		ldr	r3, [r7, #12]
 461 0044 DB6A     		ldr	r3, [r3, #44]
 462 0046 1A46     		mov	r2, r3
 463 0048 0123     		movs	r3, #1
 464 004a 9340     		lsls	r3, r3, r2
 465 004c DA43     		mvns	r2, r3
 466 004e 264B     		ldr	r3, .L27+8
 467 0050 1B68     		ldr	r3, [r3]
 468 0052 1340     		ands	r3, r3, r2
 469 0054 244A     		ldr	r2, .L27+8
 470 0056 1360     		str	r3, [r2]
 471              	.L20:
 761:../FreeRTOS/tasks.c **** 			}
 762:../FreeRTOS/tasks.c **** 			else
 763:../FreeRTOS/tasks.c **** 			{
 764:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 765:../FreeRTOS/tasks.c **** 			}
 766:../FreeRTOS/tasks.c **** 
 767:../FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 768:../FreeRTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 472              		.loc 1 768 0 is_stmt 1
 473 0058 FB68     		ldr	r3, [r7, #12]
 474 005a 9B6A     		ldr	r3, [r3, #40]
 475 005c 002B     		cmp	r3, #0
 476 005e 04D0     		beq	.L22
 769:../FreeRTOS/tasks.c **** 			{
 770:../FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 477              		.loc 1 770 0
 478 0060 FB68     		ldr	r3, [r7, #12]
 479 0062 1833     		adds	r3, r3, #24
 480 0064 1846     		mov	r0, r3
 481 0066 FFF7FEFF 		bl	uxListRemove
 482              	.L22:
 771:../FreeRTOS/tasks.c **** 			}
 772:../FreeRTOS/tasks.c **** 			else
 773:../FreeRTOS/tasks.c **** 			{
 774:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 775:../FreeRTOS/tasks.c **** 			}
 776:../FreeRTOS/tasks.c **** 
 777:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 483              		.loc 1 777 0
 484 006a FB68     		ldr	r3, [r7, #12]
 485 006c 0433     		adds	r3, r3, #4
 486 006e 1F48     		ldr	r0, .L27+12
 487 0070 1946     		mov	r1, r3
 488 0072 FFF7FEFF 		bl	vListInsertEnd
 778:../FreeRTOS/tasks.c **** 
 779:../FreeRTOS/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 780:../FreeRTOS/tasks.c **** 			there is a task that has been deleted and that it should therefore
 781:../FreeRTOS/tasks.c **** 			check the xTasksWaitingTermination list. */
 782:../FreeRTOS/tasks.c **** 			++uxTasksDeleted;
 489              		.loc 1 782 0
 490 0076 1E4B     		ldr	r3, .L27+16
 491 0078 1B68     		ldr	r3, [r3]
 492 007a 0133     		adds	r3, r3, #1
 493 007c 1C4A     		ldr	r2, .L27+16
 494 007e 1360     		str	r3, [r2]
 783:../FreeRTOS/tasks.c **** 
 784:../FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 785:../FreeRTOS/tasks.c **** 			can detect that the task lists need re-generating. */
 786:../FreeRTOS/tasks.c **** 			uxTaskNumber++;
 495              		.loc 1 786 0
 496 0080 1C4B     		ldr	r3, .L27+20
 497 0082 1B68     		ldr	r3, [r3]
 498 0084 0133     		adds	r3, r3, #1
 499 0086 1B4A     		ldr	r2, .L27+20
 500 0088 1360     		str	r3, [r2]
 787:../FreeRTOS/tasks.c **** 
 788:../FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
 789:../FreeRTOS/tasks.c **** 		}
 790:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 501              		.loc 1 790 0
 502 008a FFF7FEFF 		bl	vPortExitCritical
 791:../FreeRTOS/tasks.c **** 
 792:../FreeRTOS/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
 793:../FreeRTOS/tasks.c **** 		been deleted. */
 794:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 503              		.loc 1 794 0
 504 008e 1A4B     		ldr	r3, .L27+24
 505 0090 1B68     		ldr	r3, [r3]
 506 0092 002B     		cmp	r3, #0
 507 0094 21D0     		beq	.L17
 795:../FreeRTOS/tasks.c **** 		{
 796:../FreeRTOS/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 508              		.loc 1 796 0
 509 0096 124B     		ldr	r3, .L27
 510 0098 1B68     		ldr	r3, [r3]
 511 009a FA68     		ldr	r2, [r7, #12]
 512 009c 9A42     		cmp	r2, r3
 513 009e 16D1     		bne	.L24
 797:../FreeRTOS/tasks.c **** 			{
 798:../FreeRTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 514              		.loc 1 798 0
 515 00a0 164B     		ldr	r3, .L27+28
 516 00a2 1B68     		ldr	r3, [r3]
 517 00a4 002B     		cmp	r3, #0
 518 00a6 09D0     		beq	.L25
 519              	.LBB108:
 520              	.LBB109:
 521              		.loc 2 215 0 discriminator 1
 522              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 523 00a8 4FF00703 			mov r3, #7												
 524 00ac 83F31188 		msr basepri, r3											
 525 00b0 BFF36F8F 		isb														
 526 00b4 BFF34F8F 		dsb														
 527              	
 528              	@ 0 "" 2
 529              		.thumb
 530 00b8 BB60     		str	r3, [r7, #8]
 531              	.L26:
 532              	.LBE109:
 533              	.LBE108:
 534              		.loc 1 798 0 discriminator 1
 535 00ba FEE7     		b	.L26
 536              	.L25:
 799:../FreeRTOS/tasks.c **** 
 800:../FreeRTOS/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
 801:../FreeRTOS/tasks.c **** 				in which Windows specific clean up operations are performed,
 802:../FreeRTOS/tasks.c **** 				after which it is not possible to yield away from this task -
 803:../FreeRTOS/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
 804:../FreeRTOS/tasks.c **** 				required. */
 805:../FreeRTOS/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 806:../FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 537              		.loc 1 806 0
 538 00bc 104B     		ldr	r3, .L27+32
 539 00be 4FF08052 		mov	r2, #268435456
 540 00c2 1A60     		str	r2, [r3]
 541              	@ 806 "../FreeRTOS/tasks.c" 1
 542 00c4 BFF34F8F 		dsb
 543              	@ 0 "" 2
 544              	@ 806 "../FreeRTOS/tasks.c" 1
 545 00c8 BFF36F8F 		isb
 546              	@ 0 "" 2
 547              		.thumb
 548 00cc 05E0     		b	.L17
 549              	.L24:
 807:../FreeRTOS/tasks.c **** 			}
 808:../FreeRTOS/tasks.c **** 			else
 809:../FreeRTOS/tasks.c **** 			{
 810:../FreeRTOS/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
 811:../FreeRTOS/tasks.c **** 				the task that has just been deleted. */
 812:../FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 550              		.loc 1 812 0
 551 00ce FFF7FEFF 		bl	vPortEnterCritical
 813:../FreeRTOS/tasks.c **** 				{
 814:../FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
 552              		.loc 1 814 0
 553 00d2 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 815:../FreeRTOS/tasks.c **** 				}
 816:../FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 554              		.loc 1 816 0
 555 00d6 FFF7FEFF 		bl	vPortExitCritical
 556              	.L17:
 817:../FreeRTOS/tasks.c **** 			}
 818:../FreeRTOS/tasks.c **** 		}
 819:../FreeRTOS/tasks.c **** 	}
 557              		.loc 1 819 0
 558 00da 1037     		adds	r7, r7, #16
 559              		.cfi_def_cfa_offset 8
 560 00dc BD46     		mov	sp, r7
 561              		.cfi_def_cfa_register 13
 562              		@ sp needed
 563 00de 80BD     		pop	{r7, pc}
 564              	.L28:
 565              		.align	2
 566              	.L27:
 567 00e0 00000000 		.word	pxCurrentTCB
 568 00e4 00000000 		.word	pxReadyTasksLists
 569 00e8 00000000 		.word	uxTopReadyPriority
 570 00ec 00000000 		.word	xTasksWaitingTermination
 571 00f0 00000000 		.word	uxTasksDeleted
 572 00f4 00000000 		.word	uxTaskNumber
 573 00f8 00000000 		.word	xSchedulerRunning
 574 00fc 00000000 		.word	uxSchedulerSuspended
 575 0100 04ED00E0 		.word	-536810236
 576              		.cfi_endproc
 577              	.LFE5:
 579              		.section	.text.vTaskDelayUntil,"ax",%progbits
 580              		.align	2
 581              		.global	vTaskDelayUntil
 582              		.thumb
 583              		.thumb_func
 585              	vTaskDelayUntil:
 586              	.LFB6:
 820:../FreeRTOS/tasks.c **** 
 821:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 822:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 823:../FreeRTOS/tasks.c **** 
 824:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 825:../FreeRTOS/tasks.c **** 
 826:../FreeRTOS/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
 827:../FreeRTOS/tasks.c **** 	{
 587              		.loc 1 827 0
 588              		.cfi_startproc
 589              		@ args = 0, pretend = 0, frame = 40
 590              		@ frame_needed = 1, uses_anonymous_args = 0
 591 0000 80B5     		push	{r7, lr}
 592              		.cfi_def_cfa_offset 8
 593              		.cfi_offset 7, -8
 594              		.cfi_offset 14, -4
 595 0002 8AB0     		sub	sp, sp, #40
 596              		.cfi_def_cfa_offset 48
 597 0004 00AF     		add	r7, sp, #0
 598              		.cfi_def_cfa_register 7
 599 0006 7860     		str	r0, [r7, #4]
 600 0008 3960     		str	r1, [r7]
 828:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
 829:../FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 601              		.loc 1 829 0
 602 000a 0023     		movs	r3, #0
 603 000c 7B62     		str	r3, [r7, #36]
 830:../FreeRTOS/tasks.c **** 
 831:../FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 604              		.loc 1 831 0
 605 000e 7B68     		ldr	r3, [r7, #4]
 606 0010 002B     		cmp	r3, #0
 607 0012 09D1     		bne	.L30
 608              	.LBB110:
 609              	.LBB111:
 610              		.loc 2 215 0 discriminator 1
 611              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 612 0014 4FF00703 			mov r3, #7												
 613 0018 83F31188 		msr basepri, r3											
 614 001c BFF36F8F 		isb														
 615 0020 BFF34F8F 		dsb														
 616              	
 617              	@ 0 "" 2
 618              		.thumb
 619 0024 7B61     		str	r3, [r7, #20]
 620              	.L31:
 621              	.LBE111:
 622              	.LBE110:
 623              		.loc 1 831 0 discriminator 1
 624 0026 FEE7     		b	.L31
 625              	.L30:
 832:../FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 626              		.loc 1 832 0
 627 0028 3B68     		ldr	r3, [r7]
 628 002a 002B     		cmp	r3, #0
 629 002c 09D1     		bne	.L32
 630              	.LBB112:
 631              	.LBB113:
 632              		.loc 2 215 0 discriminator 1
 633              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 634 002e 4FF00703 			mov r3, #7												
 635 0032 83F31188 		msr basepri, r3											
 636 0036 BFF36F8F 		isb														
 637 003a BFF34F8F 		dsb														
 638              	
 639              	@ 0 "" 2
 640              		.thumb
 641 003e 3B61     		str	r3, [r7, #16]
 642              	.L33:
 643              	.LBE113:
 644              	.LBE112:
 645              		.loc 1 832 0 discriminator 2
 646 0040 FEE7     		b	.L33
 647              	.L32:
 833:../FreeRTOS/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 648              		.loc 1 833 0
 649 0042 314B     		ldr	r3, .L42
 650 0044 1B68     		ldr	r3, [r3]
 651 0046 002B     		cmp	r3, #0
 652 0048 09D0     		beq	.L34
 653              	.LBB114:
 654              	.LBB115:
 655              		.loc 2 215 0 discriminator 1
 656              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 657 004a 4FF00703 			mov r3, #7												
 658 004e 83F31188 		msr basepri, r3											
 659 0052 BFF36F8F 		isb														
 660 0056 BFF34F8F 		dsb														
 661              	
 662              	@ 0 "" 2
 663              		.thumb
 664 005a FB60     		str	r3, [r7, #12]
 665              	.L35:
 666              	.LBE115:
 667              	.LBE114:
 668              		.loc 1 833 0 discriminator 3
 669 005c FEE7     		b	.L35
 670              	.L34:
 834:../FreeRTOS/tasks.c **** 
 835:../FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 671              		.loc 1 835 0
 672 005e FFF7FEFF 		bl	vTaskSuspendAll
 673              	.LBB116:
 836:../FreeRTOS/tasks.c **** 		{
 837:../FreeRTOS/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 838:../FreeRTOS/tasks.c **** 			block. */
 839:../FreeRTOS/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 674              		.loc 1 839 0
 675 0062 2A4B     		ldr	r3, .L42+4
 676 0064 1B68     		ldr	r3, [r3]
 677 0066 3B62     		str	r3, [r7, #32]
 840:../FreeRTOS/tasks.c **** 
 841:../FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 842:../FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 678              		.loc 1 842 0
 679 0068 7B68     		ldr	r3, [r7, #4]
 680 006a 1A68     		ldr	r2, [r3]
 681 006c 3B68     		ldr	r3, [r7]
 682 006e 1344     		add	r3, r3, r2
 683 0070 FB61     		str	r3, [r7, #28]
 843:../FreeRTOS/tasks.c **** 
 844:../FreeRTOS/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 684              		.loc 1 844 0
 685 0072 7B68     		ldr	r3, [r7, #4]
 686 0074 1A68     		ldr	r2, [r3]
 687 0076 3B6A     		ldr	r3, [r7, #32]
 688 0078 9A42     		cmp	r2, r3
 689 007a 0BD9     		bls	.L36
 845:../FreeRTOS/tasks.c **** 			{
 846:../FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
 847:../FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
 848:../FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 849:../FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
 850:../FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
 851:../FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 690              		.loc 1 851 0
 691 007c 7B68     		ldr	r3, [r7, #4]
 692 007e 1A68     		ldr	r2, [r3]
 693 0080 FB69     		ldr	r3, [r7, #28]
 694 0082 9A42     		cmp	r2, r3
 695 0084 11D9     		bls	.L37
 696              		.loc 1 851 0 is_stmt 0 discriminator 1
 697 0086 FA69     		ldr	r2, [r7, #28]
 698 0088 3B6A     		ldr	r3, [r7, #32]
 699 008a 9A42     		cmp	r2, r3
 700 008c 0DD9     		bls	.L37
 852:../FreeRTOS/tasks.c **** 				{
 853:../FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 701              		.loc 1 853 0 is_stmt 1
 702 008e 0123     		movs	r3, #1
 703 0090 7B62     		str	r3, [r7, #36]
 704 0092 0AE0     		b	.L37
 705              	.L36:
 854:../FreeRTOS/tasks.c **** 				}
 855:../FreeRTOS/tasks.c **** 				else
 856:../FreeRTOS/tasks.c **** 				{
 857:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 858:../FreeRTOS/tasks.c **** 				}
 859:../FreeRTOS/tasks.c **** 			}
 860:../FreeRTOS/tasks.c **** 			else
 861:../FreeRTOS/tasks.c **** 			{
 862:../FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 863:../FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 864:../FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
 865:../FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 706              		.loc 1 865 0
 707 0094 7B68     		ldr	r3, [r7, #4]
 708 0096 1A68     		ldr	r2, [r3]
 709 0098 FB69     		ldr	r3, [r7, #28]
 710 009a 9A42     		cmp	r2, r3
 711 009c 03D8     		bhi	.L38
 712              		.loc 1 865 0 is_stmt 0 discriminator 1
 713 009e FA69     		ldr	r2, [r7, #28]
 714 00a0 3B6A     		ldr	r3, [r7, #32]
 715 00a2 9A42     		cmp	r2, r3
 716 00a4 01D9     		bls	.L37
 717              	.L38:
 866:../FreeRTOS/tasks.c **** 				{
 867:../FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 718              		.loc 1 867 0 is_stmt 1
 719 00a6 0123     		movs	r3, #1
 720 00a8 7B62     		str	r3, [r7, #36]
 721              	.L37:
 868:../FreeRTOS/tasks.c **** 				}
 869:../FreeRTOS/tasks.c **** 				else
 870:../FreeRTOS/tasks.c **** 				{
 871:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 872:../FreeRTOS/tasks.c **** 				}
 873:../FreeRTOS/tasks.c **** 			}
 874:../FreeRTOS/tasks.c **** 
 875:../FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
 876:../FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 722              		.loc 1 876 0
 723 00aa 7B68     		ldr	r3, [r7, #4]
 724 00ac FA69     		ldr	r2, [r7, #28]
 725 00ae 1A60     		str	r2, [r3]
 877:../FreeRTOS/tasks.c **** 
 878:../FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 726              		.loc 1 878 0
 727 00b0 7B6A     		ldr	r3, [r7, #36]
 728 00b2 002B     		cmp	r3, #0
 729 00b4 17D0     		beq	.L39
 879:../FreeRTOS/tasks.c **** 			{
 880:../FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
 881:../FreeRTOS/tasks.c **** 
 882:../FreeRTOS/tasks.c **** 				/* Remove the task from the ready list before adding it to the
 883:../FreeRTOS/tasks.c **** 				blocked list as the same list item is used for both lists. */
 884:../FreeRTOS/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 730              		.loc 1 884 0
 731 00b6 164B     		ldr	r3, .L42+8
 732 00b8 1B68     		ldr	r3, [r3]
 733 00ba 0433     		adds	r3, r3, #4
 734 00bc 1846     		mov	r0, r3
 735 00be FFF7FEFF 		bl	uxListRemove
 736 00c2 0346     		mov	r3, r0
 737 00c4 002B     		cmp	r3, #0
 738 00c6 0BD1     		bne	.L40
 885:../FreeRTOS/tasks.c **** 				{
 886:../FreeRTOS/tasks.c **** 					/* The current task must be in a ready list, so there is
 887:../FreeRTOS/tasks.c **** 					no need to check, and the port reset macro can be called
 888:../FreeRTOS/tasks.c **** 					directly. */
 889:../FreeRTOS/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 739              		.loc 1 889 0
 740 00c8 114B     		ldr	r3, .L42+8
 741 00ca 1B68     		ldr	r3, [r3]
 742 00cc DB6A     		ldr	r3, [r3, #44]
 743 00ce 1A46     		mov	r2, r3
 744 00d0 0123     		movs	r3, #1
 745 00d2 9340     		lsls	r3, r3, r2
 746 00d4 DA43     		mvns	r2, r3
 747 00d6 0F4B     		ldr	r3, .L42+12
 748 00d8 1B68     		ldr	r3, [r3]
 749 00da 1340     		ands	r3, r3, r2
 750 00dc 0D4A     		ldr	r2, .L42+12
 751 00de 1360     		str	r3, [r2]
 752              	.L40:
 890:../FreeRTOS/tasks.c **** 				}
 891:../FreeRTOS/tasks.c **** 				else
 892:../FreeRTOS/tasks.c **** 				{
 893:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 894:../FreeRTOS/tasks.c **** 				}
 895:../FreeRTOS/tasks.c **** 
 896:../FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 753              		.loc 1 896 0
 754 00e0 F869     		ldr	r0, [r7, #28]
 755 00e2 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 756              	.L39:
 757              	.LBE116:
 897:../FreeRTOS/tasks.c **** 			}
 898:../FreeRTOS/tasks.c **** 			else
 899:../FreeRTOS/tasks.c **** 			{
 900:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 901:../FreeRTOS/tasks.c **** 			}
 902:../FreeRTOS/tasks.c **** 		}
 903:../FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 758              		.loc 1 903 0
 759 00e6 FFF7FEFF 		bl	xTaskResumeAll
 760 00ea B861     		str	r0, [r7, #24]
 904:../FreeRTOS/tasks.c **** 
 905:../FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 906:../FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 907:../FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 761              		.loc 1 907 0
 762 00ec BB69     		ldr	r3, [r7, #24]
 763 00ee 002B     		cmp	r3, #0
 764 00f0 07D1     		bne	.L29
 908:../FreeRTOS/tasks.c **** 		{
 909:../FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 765              		.loc 1 909 0
 766 00f2 094B     		ldr	r3, .L42+16
 767 00f4 4FF08052 		mov	r2, #268435456
 768 00f8 1A60     		str	r2, [r3]
 769              	@ 909 "../FreeRTOS/tasks.c" 1
 770 00fa BFF34F8F 		dsb
 771              	@ 0 "" 2
 772              	@ 909 "../FreeRTOS/tasks.c" 1
 773 00fe BFF36F8F 		isb
 774              	@ 0 "" 2
 775              		.thumb
 776              	.L29:
 910:../FreeRTOS/tasks.c **** 		}
 911:../FreeRTOS/tasks.c **** 		else
 912:../FreeRTOS/tasks.c **** 		{
 913:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 914:../FreeRTOS/tasks.c **** 		}
 915:../FreeRTOS/tasks.c **** 	}
 777              		.loc 1 915 0
 778 0102 2837     		adds	r7, r7, #40
 779              		.cfi_def_cfa_offset 8
 780 0104 BD46     		mov	sp, r7
 781              		.cfi_def_cfa_register 13
 782              		@ sp needed
 783 0106 80BD     		pop	{r7, pc}
 784              	.L43:
 785              		.align	2
 786              	.L42:
 787 0108 00000000 		.word	uxSchedulerSuspended
 788 010c 00000000 		.word	xTickCount
 789 0110 00000000 		.word	pxCurrentTCB
 790 0114 00000000 		.word	uxTopReadyPriority
 791 0118 04ED00E0 		.word	-536810236
 792              		.cfi_endproc
 793              	.LFE6:
 795              		.section	.text.vTaskDelay,"ax",%progbits
 796              		.align	2
 797              		.global	vTaskDelay
 798              		.thumb
 799              		.thumb_func
 801              	vTaskDelay:
 802              	.LFB7:
 916:../FreeRTOS/tasks.c **** 
 917:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 918:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 919:../FreeRTOS/tasks.c **** 
 920:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 921:../FreeRTOS/tasks.c **** 
 922:../FreeRTOS/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
 923:../FreeRTOS/tasks.c **** 	{
 803              		.loc 1 923 0
 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 24
 806              		@ frame_needed = 1, uses_anonymous_args = 0
 807 0000 80B5     		push	{r7, lr}
 808              		.cfi_def_cfa_offset 8
 809              		.cfi_offset 7, -8
 810              		.cfi_offset 14, -4
 811 0002 86B0     		sub	sp, sp, #24
 812              		.cfi_def_cfa_offset 32
 813 0004 00AF     		add	r7, sp, #0
 814              		.cfi_def_cfa_register 7
 815 0006 7860     		str	r0, [r7, #4]
 924:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
 925:../FreeRTOS/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 816              		.loc 1 925 0
 817 0008 0023     		movs	r3, #0
 818 000a 7B61     		str	r3, [r7, #20]
 926:../FreeRTOS/tasks.c **** 
 927:../FreeRTOS/tasks.c **** 
 928:../FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 929:../FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 819              		.loc 1 929 0
 820 000c 7B68     		ldr	r3, [r7, #4]
 821 000e 002B     		cmp	r3, #0
 822 0010 2FD0     		beq	.L45
 930:../FreeRTOS/tasks.c **** 		{
 931:../FreeRTOS/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 823              		.loc 1 931 0
 824 0012 1F4B     		ldr	r3, .L50
 825 0014 1B68     		ldr	r3, [r3]
 826 0016 002B     		cmp	r3, #0
 827 0018 09D0     		beq	.L46
 828              	.LBB117:
 829              	.LBB118:
 830              		.loc 2 215 0 discriminator 1
 831              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 832 001a 4FF00703 			mov r3, #7												
 833 001e 83F31188 		msr basepri, r3											
 834 0022 BFF36F8F 		isb														
 835 0026 BFF34F8F 		dsb														
 836              	
 837              	@ 0 "" 2
 838              		.thumb
 839 002a FB60     		str	r3, [r7, #12]
 840              	.L47:
 841              	.LBE118:
 842              	.LBE117:
 843              		.loc 1 931 0 discriminator 1
 844 002c FEE7     		b	.L47
 845              	.L46:
 932:../FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 846              		.loc 1 932 0
 847 002e FFF7FEFF 		bl	vTaskSuspendAll
 933:../FreeRTOS/tasks.c **** 			{
 934:../FreeRTOS/tasks.c **** 				traceTASK_DELAY();
 935:../FreeRTOS/tasks.c **** 
 936:../FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
 937:../FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
 938:../FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
 939:../FreeRTOS/tasks.c **** 				is resumed.
 940:../FreeRTOS/tasks.c **** 
 941:../FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
 942:../FreeRTOS/tasks.c **** 				executing task. */
 943:../FreeRTOS/tasks.c **** 
 944:../FreeRTOS/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 945:../FreeRTOS/tasks.c **** 				not a problem. */
 946:../FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 848              		.loc 1 946 0
 849 0032 184B     		ldr	r3, .L50+4
 850 0034 1A68     		ldr	r2, [r3]
 851 0036 7B68     		ldr	r3, [r7, #4]
 852 0038 1344     		add	r3, r3, r2
 853 003a 3B61     		str	r3, [r7, #16]
 947:../FreeRTOS/tasks.c **** 
 948:../FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 949:../FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 950:../FreeRTOS/tasks.c **** 				both lists. */
 951:../FreeRTOS/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 854              		.loc 1 951 0
 855 003c 164B     		ldr	r3, .L50+8
 856 003e 1B68     		ldr	r3, [r3]
 857 0040 0433     		adds	r3, r3, #4
 858 0042 1846     		mov	r0, r3
 859 0044 FFF7FEFF 		bl	uxListRemove
 860 0048 0346     		mov	r3, r0
 861 004a 002B     		cmp	r3, #0
 862 004c 0BD1     		bne	.L48
 952:../FreeRTOS/tasks.c **** 				{
 953:../FreeRTOS/tasks.c **** 					/* The current task must be in a ready list, so there is
 954:../FreeRTOS/tasks.c **** 					no need to check, and the port reset macro can be called
 955:../FreeRTOS/tasks.c **** 					directly. */
 956:../FreeRTOS/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 863              		.loc 1 956 0
 864 004e 124B     		ldr	r3, .L50+8
 865 0050 1B68     		ldr	r3, [r3]
 866 0052 DB6A     		ldr	r3, [r3, #44]
 867 0054 1A46     		mov	r2, r3
 868 0056 0123     		movs	r3, #1
 869 0058 9340     		lsls	r3, r3, r2
 870 005a DA43     		mvns	r2, r3
 871 005c 0F4B     		ldr	r3, .L50+12
 872 005e 1B68     		ldr	r3, [r3]
 873 0060 1340     		ands	r3, r3, r2
 874 0062 0E4A     		ldr	r2, .L50+12
 875 0064 1360     		str	r3, [r2]
 876              	.L48:
 957:../FreeRTOS/tasks.c **** 				}
 958:../FreeRTOS/tasks.c **** 				else
 959:../FreeRTOS/tasks.c **** 				{
 960:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 961:../FreeRTOS/tasks.c **** 				}
 962:../FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 877              		.loc 1 962 0
 878 0066 3869     		ldr	r0, [r7, #16]
 879 0068 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 963:../FreeRTOS/tasks.c **** 			}
 964:../FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 880              		.loc 1 964 0
 881 006c FFF7FEFF 		bl	xTaskResumeAll
 882 0070 7861     		str	r0, [r7, #20]
 883              	.L45:
 965:../FreeRTOS/tasks.c **** 		}
 966:../FreeRTOS/tasks.c **** 		else
 967:../FreeRTOS/tasks.c **** 		{
 968:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 969:../FreeRTOS/tasks.c **** 		}
 970:../FreeRTOS/tasks.c **** 
 971:../FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 972:../FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 973:../FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 884              		.loc 1 973 0
 885 0072 7B69     		ldr	r3, [r7, #20]
 886 0074 002B     		cmp	r3, #0
 887 0076 07D1     		bne	.L44
 974:../FreeRTOS/tasks.c **** 		{
 975:../FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 888              		.loc 1 975 0
 889 0078 094B     		ldr	r3, .L50+16
 890 007a 4FF08052 		mov	r2, #268435456
 891 007e 1A60     		str	r2, [r3]
 892              	@ 975 "../FreeRTOS/tasks.c" 1
 893 0080 BFF34F8F 		dsb
 894              	@ 0 "" 2
 895              	@ 975 "../FreeRTOS/tasks.c" 1
 896 0084 BFF36F8F 		isb
 897              	@ 0 "" 2
 898              		.thumb
 899              	.L44:
 976:../FreeRTOS/tasks.c **** 		}
 977:../FreeRTOS/tasks.c **** 		else
 978:../FreeRTOS/tasks.c **** 		{
 979:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 980:../FreeRTOS/tasks.c **** 		}
 981:../FreeRTOS/tasks.c **** 	}
 900              		.loc 1 981 0
 901 0088 1837     		adds	r7, r7, #24
 902              		.cfi_def_cfa_offset 8
 903 008a BD46     		mov	sp, r7
 904              		.cfi_def_cfa_register 13
 905              		@ sp needed
 906 008c 80BD     		pop	{r7, pc}
 907              	.L51:
 908 008e 00BF     		.align	2
 909              	.L50:
 910 0090 00000000 		.word	uxSchedulerSuspended
 911 0094 00000000 		.word	xTickCount
 912 0098 00000000 		.word	pxCurrentTCB
 913 009c 00000000 		.word	uxTopReadyPriority
 914 00a0 04ED00E0 		.word	-536810236
 915              		.cfi_endproc
 916              	.LFE7:
 918              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 919              		.align	2
 920              		.global	uxTaskPriorityGet
 921              		.thumb
 922              		.thumb_func
 924              	uxTaskPriorityGet:
 925              	.LFB8:
 982:../FreeRTOS/tasks.c **** 
 983:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 984:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 985:../FreeRTOS/tasks.c **** 
 986:../FreeRTOS/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 987:../FreeRTOS/tasks.c **** 
 988:../FreeRTOS/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
 989:../FreeRTOS/tasks.c **** 	{
 990:../FreeRTOS/tasks.c **** 	eTaskState eReturn;
 991:../FreeRTOS/tasks.c **** 	List_t *pxStateList;
 992:../FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 993:../FreeRTOS/tasks.c **** 
 994:../FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
 995:../FreeRTOS/tasks.c **** 
 996:../FreeRTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 997:../FreeRTOS/tasks.c **** 		{
 998:../FreeRTOS/tasks.c **** 			/* The task calling this function is querying its own state. */
 999:../FreeRTOS/tasks.c **** 			eReturn = eRunning;
1000:../FreeRTOS/tasks.c **** 		}
1001:../FreeRTOS/tasks.c **** 		else
1002:../FreeRTOS/tasks.c **** 		{
1003:../FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
1004:../FreeRTOS/tasks.c **** 			{
1005:../FreeRTOS/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
1006:../FreeRTOS/tasks.c **** 			}
1007:../FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
1008:../FreeRTOS/tasks.c **** 
1009:../FreeRTOS/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1010:../FreeRTOS/tasks.c **** 			{
1011:../FreeRTOS/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1012:../FreeRTOS/tasks.c **** 				lists. */
1013:../FreeRTOS/tasks.c **** 				eReturn = eBlocked;
1014:../FreeRTOS/tasks.c **** 			}
1015:../FreeRTOS/tasks.c **** 
1016:../FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1017:../FreeRTOS/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1018:../FreeRTOS/tasks.c **** 				{
1019:../FreeRTOS/tasks.c **** 					/* The task being queried is referenced from the suspended
1020:../FreeRTOS/tasks.c **** 					list.  Is it genuinely suspended or is it block
1021:../FreeRTOS/tasks.c **** 					indefinitely? */
1022:../FreeRTOS/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1023:../FreeRTOS/tasks.c **** 					{
1024:../FreeRTOS/tasks.c **** 						eReturn = eSuspended;
1025:../FreeRTOS/tasks.c **** 					}
1026:../FreeRTOS/tasks.c **** 					else
1027:../FreeRTOS/tasks.c **** 					{
1028:../FreeRTOS/tasks.c **** 						eReturn = eBlocked;
1029:../FreeRTOS/tasks.c **** 					}
1030:../FreeRTOS/tasks.c **** 				}
1031:../FreeRTOS/tasks.c **** 			#endif
1032:../FreeRTOS/tasks.c **** 
1033:../FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1034:../FreeRTOS/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
1035:../FreeRTOS/tasks.c **** 				{
1036:../FreeRTOS/tasks.c **** 					/* The task being queried is referenced from the deleted
1037:../FreeRTOS/tasks.c **** 					tasks list. */
1038:../FreeRTOS/tasks.c **** 					eReturn = eDeleted;
1039:../FreeRTOS/tasks.c **** 				}
1040:../FreeRTOS/tasks.c **** 			#endif
1041:../FreeRTOS/tasks.c **** 
1042:../FreeRTOS/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1043:../FreeRTOS/tasks.c **** 			{
1044:../FreeRTOS/tasks.c **** 				/* If the task is not in any other state, it must be in the
1045:../FreeRTOS/tasks.c **** 				Ready (including pending ready) state. */
1046:../FreeRTOS/tasks.c **** 				eReturn = eReady;
1047:../FreeRTOS/tasks.c **** 			}
1048:../FreeRTOS/tasks.c **** 		}
1049:../FreeRTOS/tasks.c **** 
1050:../FreeRTOS/tasks.c **** 		return eReturn;
1051:../FreeRTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1052:../FreeRTOS/tasks.c **** 
1053:../FreeRTOS/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1054:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1055:../FreeRTOS/tasks.c **** 
1056:../FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1057:../FreeRTOS/tasks.c **** 
1058:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1059:../FreeRTOS/tasks.c **** 	{
 926              		.loc 1 1059 0
 927              		.cfi_startproc
 928              		@ args = 0, pretend = 0, frame = 16
 929              		@ frame_needed = 1, uses_anonymous_args = 0
 930 0000 80B5     		push	{r7, lr}
 931              		.cfi_def_cfa_offset 8
 932              		.cfi_offset 7, -8
 933              		.cfi_offset 14, -4
 934 0002 84B0     		sub	sp, sp, #16
 935              		.cfi_def_cfa_offset 24
 936 0004 00AF     		add	r7, sp, #0
 937              		.cfi_def_cfa_register 7
 938 0006 7860     		str	r0, [r7, #4]
1060:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1061:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
1062:../FreeRTOS/tasks.c **** 
1063:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 939              		.loc 1 1063 0
 940 0008 FFF7FEFF 		bl	vPortEnterCritical
1064:../FreeRTOS/tasks.c **** 		{
1065:../FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
1066:../FreeRTOS/tasks.c **** 			priority of the calling function. */
1067:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 941              		.loc 1 1067 0
 942 000c 7B68     		ldr	r3, [r7, #4]
 943 000e 002B     		cmp	r3, #0
 944 0010 02D1     		bne	.L53
 945              		.loc 1 1067 0 is_stmt 0 discriminator 1
 946 0012 074B     		ldr	r3, .L56
 947 0014 1B68     		ldr	r3, [r3]
 948 0016 00E0     		b	.L54
 949              	.L53:
 950              		.loc 1 1067 0 discriminator 2
 951 0018 7B68     		ldr	r3, [r7, #4]
 952              	.L54:
 953              		.loc 1 1067 0 discriminator 4
 954 001a FB60     		str	r3, [r7, #12]
1068:../FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 955              		.loc 1 1068 0 is_stmt 1 discriminator 4
 956 001c FB68     		ldr	r3, [r7, #12]
 957 001e DB6A     		ldr	r3, [r3, #44]
 958 0020 BB60     		str	r3, [r7, #8]
1069:../FreeRTOS/tasks.c **** 		}
1070:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 959              		.loc 1 1070 0 discriminator 4
 960 0022 FFF7FEFF 		bl	vPortExitCritical
1071:../FreeRTOS/tasks.c **** 
1072:../FreeRTOS/tasks.c **** 		return uxReturn;
 961              		.loc 1 1072 0 discriminator 4
 962 0026 BB68     		ldr	r3, [r7, #8]
1073:../FreeRTOS/tasks.c **** 	}
 963              		.loc 1 1073 0 discriminator 4
 964 0028 1846     		mov	r0, r3
 965 002a 1037     		adds	r7, r7, #16
 966              		.cfi_def_cfa_offset 8
 967 002c BD46     		mov	sp, r7
 968              		.cfi_def_cfa_register 13
 969              		@ sp needed
 970 002e 80BD     		pop	{r7, pc}
 971              	.L57:
 972              		.align	2
 973              	.L56:
 974 0030 00000000 		.word	pxCurrentTCB
 975              		.cfi_endproc
 976              	.LFE8:
 978              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 979              		.align	2
 980              		.global	uxTaskPriorityGetFromISR
 981              		.thumb
 982              		.thumb_func
 984              	uxTaskPriorityGetFromISR:
 985              	.LFB9:
1074:../FreeRTOS/tasks.c **** 
1075:../FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1076:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1077:../FreeRTOS/tasks.c **** 
1078:../FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1079:../FreeRTOS/tasks.c **** 
1080:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1081:../FreeRTOS/tasks.c **** 	{
 986              		.loc 1 1081 0
 987              		.cfi_startproc
 988              		@ args = 0, pretend = 0, frame = 32
 989              		@ frame_needed = 1, uses_anonymous_args = 0
 990 0000 80B5     		push	{r7, lr}
 991              		.cfi_def_cfa_offset 8
 992              		.cfi_offset 7, -8
 993              		.cfi_offset 14, -4
 994 0002 88B0     		sub	sp, sp, #32
 995              		.cfi_def_cfa_offset 40
 996 0004 00AF     		add	r7, sp, #0
 997              		.cfi_def_cfa_register 7
 998 0006 7860     		str	r0, [r7, #4]
1082:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1083:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1084:../FreeRTOS/tasks.c **** 
1085:../FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1086:../FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1087:../FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1088:../FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1089:../FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1090:../FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1091:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1092:../FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1093:../FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1094:../FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1095:../FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1096:../FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1097:../FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1098:../FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1099:../FreeRTOS/tasks.c **** 		provided on the following link:
1100:../FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1101:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 999              		.loc 1 1101 0
 1000 0008 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1001              	.LBB119:
 1002              	.LBB120:
 216:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 217:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	mov %0, %1												\n"	\
 218:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	msr basepri, %0											\n" \
 219:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	isb														\n" \
 220:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	dsb														\n" \
 221:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 222:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	);
 223:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** }
 224:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 225:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 226:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 227:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 228:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** {
 229:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 230:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 231:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	__asm volatile
 1003              		.loc 2 231 0
 1004              	@ 231 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1005 000c EFF31182 			mrs r2, basepri											
 1006 0010 4FF00703 		mov r3, #7												
 1007 0014 83F31188 		msr basepri, r3											
 1008 0018 BFF36F8F 		isb														
 1009 001c BFF34F8F 		dsb														
 1010              	
 1011              	@ 0 "" 2
 1012              		.thumb
 1013 0020 3A61     		str	r2, [r7, #16]
 1014 0022 FB60     		str	r3, [r7, #12]
 232:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 233:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	mrs %0, basepri											\n" \
 234:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	mov %1, %2												\n"	\
 235:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	msr basepri, %1											\n" \
 236:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	isb														\n" \
 237:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		"	dsb														\n" \
 238:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 239:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	);
 240:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 241:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 242:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	warnings. */
 243:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	return ulOriginalBASEPRI;
 1015              		.loc 2 243 0
 1016 0024 3B69     		ldr	r3, [r7, #16]
 1017              	.LBE120:
 1018              	.LBE119:
1102:../FreeRTOS/tasks.c **** 
1103:../FreeRTOS/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1019              		.loc 1 1103 0
 1020 0026 FB61     		str	r3, [r7, #28]
1104:../FreeRTOS/tasks.c **** 		{
1105:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1106:../FreeRTOS/tasks.c **** 			task that is being queried. */
1107:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1021              		.loc 1 1107 0
 1022 0028 7B68     		ldr	r3, [r7, #4]
 1023 002a 002B     		cmp	r3, #0
 1024 002c 02D1     		bne	.L60
 1025              		.loc 1 1107 0 is_stmt 0 discriminator 1
 1026 002e 094B     		ldr	r3, .L63
 1027 0030 1B68     		ldr	r3, [r3]
 1028 0032 00E0     		b	.L61
 1029              	.L60:
 1030              		.loc 1 1107 0 discriminator 2
 1031 0034 7B68     		ldr	r3, [r7, #4]
 1032              	.L61:
 1033              		.loc 1 1107 0 discriminator 4
 1034 0036 BB61     		str	r3, [r7, #24]
1108:../FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1035              		.loc 1 1108 0 is_stmt 1 discriminator 4
 1036 0038 BB69     		ldr	r3, [r7, #24]
 1037 003a DB6A     		ldr	r3, [r3, #44]
 1038 003c 7B61     		str	r3, [r7, #20]
 1039 003e FB69     		ldr	r3, [r7, #28]
 1040 0040 BB60     		str	r3, [r7, #8]
 1041              	.LBB121:
 1042              	.LBB122:
 244:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** }
 245:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** /*-----------------------------------------------------------*/
 246:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 
 247:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 248:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** {
 249:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	__asm volatile
 1043              		.loc 2 249 0 discriminator 4
 1044 0042 BB68     		ldr	r3, [r7, #8]
 1045              	@ 249 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1046 0044 83F31188 			msr basepri, r3	
 1047              	@ 0 "" 2
 1048              		.thumb
 1049              	.LBE122:
 1050              	.LBE121:
1109:../FreeRTOS/tasks.c **** 		}
1110:../FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1111:../FreeRTOS/tasks.c **** 
1112:../FreeRTOS/tasks.c **** 		return uxReturn;
 1051              		.loc 1 1112 0 discriminator 4
 1052 0048 7B69     		ldr	r3, [r7, #20]
1113:../FreeRTOS/tasks.c **** 	}
 1053              		.loc 1 1113 0 discriminator 4
 1054 004a 1846     		mov	r0, r3
 1055 004c 2037     		adds	r7, r7, #32
 1056              		.cfi_def_cfa_offset 8
 1057 004e BD46     		mov	sp, r7
 1058              		.cfi_def_cfa_register 13
 1059              		@ sp needed
 1060 0050 80BD     		pop	{r7, pc}
 1061              	.L64:
 1062 0052 00BF     		.align	2
 1063              	.L63:
 1064 0054 00000000 		.word	pxCurrentTCB
 1065              		.cfi_endproc
 1066              	.LFE9:
 1068              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1069              		.align	2
 1070              		.global	vTaskPrioritySet
 1071              		.thumb
 1072              		.thumb_func
 1074              	vTaskPrioritySet:
 1075              	.LFB10:
1114:../FreeRTOS/tasks.c **** 
1115:../FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1116:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1117:../FreeRTOS/tasks.c **** 
1118:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1119:../FreeRTOS/tasks.c **** 
1120:../FreeRTOS/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1121:../FreeRTOS/tasks.c **** 	{
 1076              		.loc 1 1121 0
 1077              		.cfi_startproc
 1078              		@ args = 0, pretend = 0, frame = 32
 1079              		@ frame_needed = 1, uses_anonymous_args = 0
 1080 0000 80B5     		push	{r7, lr}
 1081              		.cfi_def_cfa_offset 8
 1082              		.cfi_offset 7, -8
 1083              		.cfi_offset 14, -4
 1084 0002 88B0     		sub	sp, sp, #32
 1085              		.cfi_def_cfa_offset 40
 1086 0004 00AF     		add	r7, sp, #0
 1087              		.cfi_def_cfa_register 7
 1088 0006 7860     		str	r0, [r7, #4]
 1089 0008 3960     		str	r1, [r7]
1122:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1123:../FreeRTOS/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1124:../FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1090              		.loc 1 1124 0
 1091 000a 0023     		movs	r3, #0
 1092 000c FB61     		str	r3, [r7, #28]
1125:../FreeRTOS/tasks.c **** 
1126:../FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 1093              		.loc 1 1126 0
 1094 000e 3B68     		ldr	r3, [r7]
 1095 0010 072B     		cmp	r3, #7
 1096 0012 09D9     		bls	.L66
 1097              	.LBB123:
 1098              	.LBB124:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1099              		.loc 2 215 0 discriminator 1
 1100              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1101 0014 4FF00703 			mov r3, #7												
 1102 0018 83F31188 		msr basepri, r3											
 1103 001c BFF36F8F 		isb														
 1104 0020 BFF34F8F 		dsb														
 1105              	
 1106              	@ 0 "" 2
 1107              		.thumb
 1108 0024 FB60     		str	r3, [r7, #12]
 1109              	.L67:
 1110              	.LBE124:
 1111              	.LBE123:
 1112              		.loc 1 1126 0 discriminator 1
 1113 0026 FEE7     		b	.L67
 1114              	.L66:
1127:../FreeRTOS/tasks.c **** 
1128:../FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
1129:../FreeRTOS/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1115              		.loc 1 1129 0
 1116 0028 3B68     		ldr	r3, [r7]
 1117 002a 072B     		cmp	r3, #7
 1118 002c 01D9     		bls	.L68
1130:../FreeRTOS/tasks.c **** 		{
1131:../FreeRTOS/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1119              		.loc 1 1131 0
 1120 002e 0723     		movs	r3, #7
 1121 0030 3B60     		str	r3, [r7]
 1122              	.L68:
1132:../FreeRTOS/tasks.c **** 		}
1133:../FreeRTOS/tasks.c **** 		else
1134:../FreeRTOS/tasks.c **** 		{
1135:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1136:../FreeRTOS/tasks.c **** 		}
1137:../FreeRTOS/tasks.c **** 
1138:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 1123              		.loc 1 1138 0
 1124 0032 FFF7FEFF 		bl	vPortEnterCritical
1139:../FreeRTOS/tasks.c **** 		{
1140:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1141:../FreeRTOS/tasks.c **** 			task that is being changed. */
1142:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1125              		.loc 1 1142 0
 1126 0036 7B68     		ldr	r3, [r7, #4]
 1127 0038 002B     		cmp	r3, #0
 1128 003a 02D1     		bne	.L69
 1129              		.loc 1 1142 0 is_stmt 0 discriminator 1
 1130 003c 3E4B     		ldr	r3, .L79
 1131 003e 1B68     		ldr	r3, [r3]
 1132 0040 00E0     		b	.L70
 1133              	.L69:
 1134              		.loc 1 1142 0 discriminator 2
 1135 0042 7B68     		ldr	r3, [r7, #4]
 1136              	.L70:
 1137              		.loc 1 1142 0 discriminator 4
 1138 0044 BB61     		str	r3, [r7, #24]
1143:../FreeRTOS/tasks.c **** 
1144:../FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1145:../FreeRTOS/tasks.c **** 
1146:../FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1147:../FreeRTOS/tasks.c **** 			{
1148:../FreeRTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1139              		.loc 1 1148 0 is_stmt 1 discriminator 4
 1140 0046 BB69     		ldr	r3, [r7, #24]
 1141 0048 9B6D     		ldr	r3, [r3, #88]
 1142 004a 7B61     		str	r3, [r7, #20]
1149:../FreeRTOS/tasks.c **** 			}
1150:../FreeRTOS/tasks.c **** 			#else
1151:../FreeRTOS/tasks.c **** 			{
1152:../FreeRTOS/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1153:../FreeRTOS/tasks.c **** 			}
1154:../FreeRTOS/tasks.c **** 			#endif
1155:../FreeRTOS/tasks.c **** 
1156:../FreeRTOS/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 1143              		.loc 1 1156 0 discriminator 4
 1144 004c 7A69     		ldr	r2, [r7, #20]
 1145 004e 3B68     		ldr	r3, [r7]
 1146 0050 9A42     		cmp	r2, r3
 1147 0052 6BD0     		beq	.L71
1157:../FreeRTOS/tasks.c **** 			{
1158:../FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
1159:../FreeRTOS/tasks.c **** 				priority than the calling task. */
1160:../FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 1148              		.loc 1 1160 0
 1149 0054 3A68     		ldr	r2, [r7]
 1150 0056 7B69     		ldr	r3, [r7, #20]
 1151 0058 9A42     		cmp	r2, r3
 1152 005a 0DD9     		bls	.L72
1161:../FreeRTOS/tasks.c **** 				{
1162:../FreeRTOS/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 1153              		.loc 1 1162 0
 1154 005c 364B     		ldr	r3, .L79
 1155 005e 1B68     		ldr	r3, [r3]
 1156 0060 BA69     		ldr	r2, [r7, #24]
 1157 0062 9A42     		cmp	r2, r3
 1158 0064 0FD0     		beq	.L73
1163:../FreeRTOS/tasks.c **** 					{
1164:../FreeRTOS/tasks.c **** 						/* The priority of a task other than the currently
1165:../FreeRTOS/tasks.c **** 						running task is being raised.  Is the priority being
1166:../FreeRTOS/tasks.c **** 						raised above that of the running task? */
1167:../FreeRTOS/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1159              		.loc 1 1167 0
 1160 0066 344B     		ldr	r3, .L79
 1161 0068 1B68     		ldr	r3, [r3]
 1162 006a DA6A     		ldr	r2, [r3, #44]
 1163 006c 3B68     		ldr	r3, [r7]
 1164 006e 9A42     		cmp	r2, r3
 1165 0070 09D8     		bhi	.L73
1168:../FreeRTOS/tasks.c **** 						{
1169:../FreeRTOS/tasks.c **** 							xYieldRequired = pdTRUE;
 1166              		.loc 1 1169 0
 1167 0072 0123     		movs	r3, #1
 1168 0074 FB61     		str	r3, [r7, #28]
 1169 0076 06E0     		b	.L73
 1170              	.L72:
1170:../FreeRTOS/tasks.c **** 						}
1171:../FreeRTOS/tasks.c **** 						else
1172:../FreeRTOS/tasks.c **** 						{
1173:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1174:../FreeRTOS/tasks.c **** 						}
1175:../FreeRTOS/tasks.c **** 					}
1176:../FreeRTOS/tasks.c **** 					else
1177:../FreeRTOS/tasks.c **** 					{
1178:../FreeRTOS/tasks.c **** 						/* The priority of the running task is being raised,
1179:../FreeRTOS/tasks.c **** 						but the running task must already be the highest
1180:../FreeRTOS/tasks.c **** 						priority task able to run so no yield is required. */
1181:../FreeRTOS/tasks.c **** 					}
1182:../FreeRTOS/tasks.c **** 				}
1183:../FreeRTOS/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 1171              		.loc 1 1183 0
 1172 0078 2F4B     		ldr	r3, .L79
 1173 007a 1B68     		ldr	r3, [r3]
 1174 007c BA69     		ldr	r2, [r7, #24]
 1175 007e 9A42     		cmp	r2, r3
 1176 0080 01D1     		bne	.L73
1184:../FreeRTOS/tasks.c **** 				{
1185:../FreeRTOS/tasks.c **** 					/* Setting the priority of the running task down means
1186:../FreeRTOS/tasks.c **** 					there may now be another task of higher priority that
1187:../FreeRTOS/tasks.c **** 					is ready to execute. */
1188:../FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
 1177              		.loc 1 1188 0
 1178 0082 0123     		movs	r3, #1
 1179 0084 FB61     		str	r3, [r7, #28]
 1180              	.L73:
1189:../FreeRTOS/tasks.c **** 				}
1190:../FreeRTOS/tasks.c **** 				else
1191:../FreeRTOS/tasks.c **** 				{
1192:../FreeRTOS/tasks.c **** 					/* Setting the priority of any other task down does not
1193:../FreeRTOS/tasks.c **** 					require a yield as the running task must be above the
1194:../FreeRTOS/tasks.c **** 					new priority of the task being modified. */
1195:../FreeRTOS/tasks.c **** 				}
1196:../FreeRTOS/tasks.c **** 
1197:../FreeRTOS/tasks.c **** 				/* Remember the ready list the task might be referenced from
1198:../FreeRTOS/tasks.c **** 				before its uxPriority member is changed so the
1199:../FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1200:../FreeRTOS/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1181              		.loc 1 1200 0
 1182 0086 BB69     		ldr	r3, [r7, #24]
 1183 0088 DB6A     		ldr	r3, [r3, #44]
 1184 008a 3B61     		str	r3, [r7, #16]
1201:../FreeRTOS/tasks.c **** 
1202:../FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1203:../FreeRTOS/tasks.c **** 				{
1204:../FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
1205:../FreeRTOS/tasks.c **** 					currently using an inherited priority. */
1206:../FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1185              		.loc 1 1206 0
 1186 008c BB69     		ldr	r3, [r7, #24]
 1187 008e 9A6D     		ldr	r2, [r3, #88]
 1188 0090 BB69     		ldr	r3, [r7, #24]
 1189 0092 DB6A     		ldr	r3, [r3, #44]
 1190 0094 9A42     		cmp	r2, r3
 1191 0096 02D1     		bne	.L74
1207:../FreeRTOS/tasks.c **** 					{
1208:../FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 1192              		.loc 1 1208 0
 1193 0098 BB69     		ldr	r3, [r7, #24]
 1194 009a 3A68     		ldr	r2, [r7]
 1195 009c DA62     		str	r2, [r3, #44]
 1196              	.L74:
1209:../FreeRTOS/tasks.c **** 					}
1210:../FreeRTOS/tasks.c **** 					else
1211:../FreeRTOS/tasks.c **** 					{
1212:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1213:../FreeRTOS/tasks.c **** 					}
1214:../FreeRTOS/tasks.c **** 
1215:../FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
1216:../FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 1197              		.loc 1 1216 0
 1198 009e BB69     		ldr	r3, [r7, #24]
 1199 00a0 3A68     		ldr	r2, [r7]
 1200 00a2 9A65     		str	r2, [r3, #88]
1217:../FreeRTOS/tasks.c **** 				}
1218:../FreeRTOS/tasks.c **** 				#else
1219:../FreeRTOS/tasks.c **** 				{
1220:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1221:../FreeRTOS/tasks.c **** 				}
1222:../FreeRTOS/tasks.c **** 				#endif
1223:../FreeRTOS/tasks.c **** 
1224:../FreeRTOS/tasks.c **** 				/* Only reset the event list item value if the value is not
1225:../FreeRTOS/tasks.c **** 				being used for anything else. */
1226:../FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 1201              		.loc 1 1226 0
 1202 00a4 BB69     		ldr	r3, [r7, #24]
 1203 00a6 9B69     		ldr	r3, [r3, #24]
 1204 00a8 002B     		cmp	r3, #0
 1205 00aa 04DB     		blt	.L75
1227:../FreeRTOS/tasks.c **** 				{
1228:../FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 1206              		.loc 1 1228 0
 1207 00ac 3B68     		ldr	r3, [r7]
 1208 00ae C3F10802 		rsb	r2, r3, #8
 1209 00b2 BB69     		ldr	r3, [r7, #24]
 1210 00b4 9A61     		str	r2, [r3, #24]
 1211              	.L75:
1229:../FreeRTOS/tasks.c **** 				}
1230:../FreeRTOS/tasks.c **** 				else
1231:../FreeRTOS/tasks.c **** 				{
1232:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1233:../FreeRTOS/tasks.c **** 				}
1234:../FreeRTOS/tasks.c **** 
1235:../FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1236:../FreeRTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
1237:../FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1238:../FreeRTOS/tasks.c **** 				in the list appropriate to its new priority. */
1239:../FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
 1212              		.loc 1 1239 0
 1213 00b6 BB69     		ldr	r3, [r7, #24]
 1214 00b8 5969     		ldr	r1, [r3, #20]
 1215 00ba 3A69     		ldr	r2, [r7, #16]
 1216 00bc 1346     		mov	r3, r2
 1217 00be 9B00     		lsls	r3, r3, #2
 1218 00c0 1344     		add	r3, r3, r2
 1219 00c2 9B00     		lsls	r3, r3, #2
 1220 00c4 1D4A     		ldr	r2, .L79+4
 1221 00c6 1344     		add	r3, r3, r2
 1222 00c8 9942     		cmp	r1, r3
 1223 00ca 01D1     		bne	.L76
 1224              		.loc 1 1239 0 is_stmt 0 discriminator 1
 1225 00cc 0123     		movs	r3, #1
 1226 00ce 00E0     		b	.L77
 1227              	.L76:
 1228              		.loc 1 1239 0 discriminator 2
 1229 00d0 0023     		movs	r3, #0
 1230              	.L77:
 1231              		.loc 1 1239 0 discriminator 4
 1232 00d2 002B     		cmp	r3, #0
 1233 00d4 2AD0     		beq	.L71
1240:../FreeRTOS/tasks.c **** 				{
1241:../FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1242:../FreeRTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1243:../FreeRTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
1244:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1234              		.loc 1 1244 0 is_stmt 1
 1235 00d6 BB69     		ldr	r3, [r7, #24]
 1236 00d8 0433     		adds	r3, r3, #4
 1237 00da 1846     		mov	r0, r3
 1238 00dc FFF7FEFF 		bl	uxListRemove
 1239 00e0 0346     		mov	r3, r0
 1240 00e2 002B     		cmp	r3, #0
 1241 00e4 09D1     		bne	.L78
1245:../FreeRTOS/tasks.c **** 					{
1246:../FreeRTOS/tasks.c **** 						/* It is known that the task is in its ready list so
1247:../FreeRTOS/tasks.c **** 						there is no need to check again and the port level
1248:../FreeRTOS/tasks.c **** 						reset macro can be called directly. */
1249:../FreeRTOS/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1242              		.loc 1 1249 0
 1243 00e6 3B69     		ldr	r3, [r7, #16]
 1244 00e8 0122     		movs	r2, #1
 1245 00ea 02FA03F3 		lsl	r3, r2, r3
 1246 00ee DA43     		mvns	r2, r3
 1247 00f0 134B     		ldr	r3, .L79+8
 1248 00f2 1B68     		ldr	r3, [r3]
 1249 00f4 1340     		ands	r3, r3, r2
 1250 00f6 124A     		ldr	r2, .L79+8
 1251 00f8 1360     		str	r3, [r2]
 1252              	.L78:
1250:../FreeRTOS/tasks.c **** 					}
1251:../FreeRTOS/tasks.c **** 					else
1252:../FreeRTOS/tasks.c **** 					{
1253:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1254:../FreeRTOS/tasks.c **** 					}
1255:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1253              		.loc 1 1255 0
 1254 00fa BB69     		ldr	r3, [r7, #24]
 1255 00fc DB6A     		ldr	r3, [r3, #44]
 1256 00fe 1A46     		mov	r2, r3
 1257 0100 0123     		movs	r3, #1
 1258 0102 03FA02F2 		lsl	r2, r3, r2
 1259 0106 0E4B     		ldr	r3, .L79+8
 1260 0108 1B68     		ldr	r3, [r3]
 1261 010a 1343     		orrs	r3, r3, r2
 1262 010c 0C4A     		ldr	r2, .L79+8
 1263 010e 1360     		str	r3, [r2]
 1264 0110 BB69     		ldr	r3, [r7, #24]
 1265 0112 DA6A     		ldr	r2, [r3, #44]
 1266 0114 1346     		mov	r3, r2
 1267 0116 9B00     		lsls	r3, r3, #2
 1268 0118 1344     		add	r3, r3, r2
 1269 011a 9B00     		lsls	r3, r3, #2
 1270 011c 074A     		ldr	r2, .L79+4
 1271 011e 1A44     		add	r2, r2, r3
 1272 0120 BB69     		ldr	r3, [r7, #24]
 1273 0122 0433     		adds	r3, r3, #4
 1274 0124 1046     		mov	r0, r2
 1275 0126 1946     		mov	r1, r3
 1276 0128 FFF7FEFF 		bl	vListInsertEnd
 1277              	.L71:
1256:../FreeRTOS/tasks.c **** 				}
1257:../FreeRTOS/tasks.c **** 				else
1258:../FreeRTOS/tasks.c **** 				{
1259:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1260:../FreeRTOS/tasks.c **** 				}
1261:../FreeRTOS/tasks.c **** 
1262:../FreeRTOS/tasks.c **** 				if( xYieldRequired == pdTRUE )
1263:../FreeRTOS/tasks.c **** 				{
1264:../FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1265:../FreeRTOS/tasks.c **** 				}
1266:../FreeRTOS/tasks.c **** 				else
1267:../FreeRTOS/tasks.c **** 				{
1268:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1269:../FreeRTOS/tasks.c **** 				}
1270:../FreeRTOS/tasks.c **** 
1271:../FreeRTOS/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1272:../FreeRTOS/tasks.c **** 				optimised task selection is not being used. */
1273:../FreeRTOS/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1274:../FreeRTOS/tasks.c **** 			}
1275:../FreeRTOS/tasks.c **** 		}
1276:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 1278              		.loc 1 1276 0
 1279 012c FFF7FEFF 		bl	vPortExitCritical
1277:../FreeRTOS/tasks.c **** 	}
 1280              		.loc 1 1277 0
 1281 0130 2037     		adds	r7, r7, #32
 1282              		.cfi_def_cfa_offset 8
 1283 0132 BD46     		mov	sp, r7
 1284              		.cfi_def_cfa_register 13
 1285              		@ sp needed
 1286 0134 80BD     		pop	{r7, pc}
 1287              	.L80:
 1288 0136 00BF     		.align	2
 1289              	.L79:
 1290 0138 00000000 		.word	pxCurrentTCB
 1291 013c 00000000 		.word	pxReadyTasksLists
 1292 0140 00000000 		.word	uxTopReadyPriority
 1293              		.cfi_endproc
 1294              	.LFE10:
 1296              		.section	.text.vTaskSuspend,"ax",%progbits
 1297              		.align	2
 1298              		.global	vTaskSuspend
 1299              		.thumb
 1300              		.thumb_func
 1302              	vTaskSuspend:
 1303              	.LFB11:
1278:../FreeRTOS/tasks.c **** 
1279:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1280:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1281:../FreeRTOS/tasks.c **** 
1282:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1283:../FreeRTOS/tasks.c **** 
1284:../FreeRTOS/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1285:../FreeRTOS/tasks.c **** 	{
 1304              		.loc 1 1285 0
 1305              		.cfi_startproc
 1306              		@ args = 0, pretend = 0, frame = 16
 1307              		@ frame_needed = 1, uses_anonymous_args = 0
 1308 0000 80B5     		push	{r7, lr}
 1309              		.cfi_def_cfa_offset 8
 1310              		.cfi_offset 7, -8
 1311              		.cfi_offset 14, -4
 1312 0002 84B0     		sub	sp, sp, #16
 1313              		.cfi_def_cfa_offset 24
 1314 0004 00AF     		add	r7, sp, #0
 1315              		.cfi_def_cfa_register 7
 1316 0006 7860     		str	r0, [r7, #4]
1286:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1287:../FreeRTOS/tasks.c **** 
1288:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 1317              		.loc 1 1288 0
 1318 0008 FFF7FEFF 		bl	vPortEnterCritical
1289:../FreeRTOS/tasks.c **** 		{
1290:../FreeRTOS/tasks.c **** 			/* If null is passed in here then it is the running task that is
1291:../FreeRTOS/tasks.c **** 			being suspended. */
1292:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1319              		.loc 1 1292 0
 1320 000c 7B68     		ldr	r3, [r7, #4]
 1321 000e 002B     		cmp	r3, #0
 1322 0010 02D1     		bne	.L82
 1323              		.loc 1 1292 0 is_stmt 0 discriminator 1
 1324 0012 374B     		ldr	r3, .L94
 1325 0014 1B68     		ldr	r3, [r3]
 1326 0016 00E0     		b	.L83
 1327              	.L82:
 1328              		.loc 1 1292 0 discriminator 2
 1329 0018 7B68     		ldr	r3, [r7, #4]
 1330              	.L83:
 1331              		.loc 1 1292 0 discriminator 4
 1332 001a FB60     		str	r3, [r7, #12]
1293:../FreeRTOS/tasks.c **** 
1294:../FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1295:../FreeRTOS/tasks.c **** 
1296:../FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1297:../FreeRTOS/tasks.c **** 			suspended list. */
1298:../FreeRTOS/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 1333              		.loc 1 1298 0 is_stmt 1 discriminator 4
 1334 001c FB68     		ldr	r3, [r7, #12]
 1335 001e 0433     		adds	r3, r3, #4
 1336 0020 1846     		mov	r0, r3
 1337 0022 FFF7FEFF 		bl	uxListRemove
 1338 0026 0346     		mov	r3, r0
 1339 0028 002B     		cmp	r3, #0
 1340 002a 15D1     		bne	.L84
1299:../FreeRTOS/tasks.c **** 			{
1300:../FreeRTOS/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1341              		.loc 1 1300 0
 1342 002c FB68     		ldr	r3, [r7, #12]
 1343 002e DA6A     		ldr	r2, [r3, #44]
 1344 0030 3049     		ldr	r1, .L94+4
 1345 0032 1346     		mov	r3, r2
 1346 0034 9B00     		lsls	r3, r3, #2
 1347 0036 1344     		add	r3, r3, r2
 1348 0038 9B00     		lsls	r3, r3, #2
 1349 003a 0B44     		add	r3, r3, r1
 1350 003c 1B68     		ldr	r3, [r3]
 1351 003e 002B     		cmp	r3, #0
 1352 0040 0AD1     		bne	.L84
 1353              		.loc 1 1300 0 is_stmt 0 discriminator 1
 1354 0042 FB68     		ldr	r3, [r7, #12]
 1355 0044 DB6A     		ldr	r3, [r3, #44]
 1356 0046 1A46     		mov	r2, r3
 1357 0048 0123     		movs	r3, #1
 1358 004a 9340     		lsls	r3, r3, r2
 1359 004c DA43     		mvns	r2, r3
 1360 004e 2A4B     		ldr	r3, .L94+8
 1361 0050 1B68     		ldr	r3, [r3]
 1362 0052 1340     		ands	r3, r3, r2
 1363 0054 284A     		ldr	r2, .L94+8
 1364 0056 1360     		str	r3, [r2]
 1365              	.L84:
1301:../FreeRTOS/tasks.c **** 			}
1302:../FreeRTOS/tasks.c **** 			else
1303:../FreeRTOS/tasks.c **** 			{
1304:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1305:../FreeRTOS/tasks.c **** 			}
1306:../FreeRTOS/tasks.c **** 
1307:../FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
1308:../FreeRTOS/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1366              		.loc 1 1308 0 is_stmt 1
 1367 0058 FB68     		ldr	r3, [r7, #12]
 1368 005a 9B6A     		ldr	r3, [r3, #40]
 1369 005c 002B     		cmp	r3, #0
 1370 005e 04D0     		beq	.L86
1309:../FreeRTOS/tasks.c **** 			{
1310:../FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1371              		.loc 1 1310 0
 1372 0060 FB68     		ldr	r3, [r7, #12]
 1373 0062 1833     		adds	r3, r3, #24
 1374 0064 1846     		mov	r0, r3
 1375 0066 FFF7FEFF 		bl	uxListRemove
 1376              	.L86:
1311:../FreeRTOS/tasks.c **** 			}
1312:../FreeRTOS/tasks.c **** 			else
1313:../FreeRTOS/tasks.c **** 			{
1314:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1315:../FreeRTOS/tasks.c **** 			}
1316:../FreeRTOS/tasks.c **** 
1317:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1377              		.loc 1 1317 0
 1378 006a FB68     		ldr	r3, [r7, #12]
 1379 006c 0433     		adds	r3, r3, #4
 1380 006e 2348     		ldr	r0, .L94+12
 1381 0070 1946     		mov	r1, r3
 1382 0072 FFF7FEFF 		bl	vListInsertEnd
1318:../FreeRTOS/tasks.c **** 		}
1319:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 1383              		.loc 1 1319 0
 1384 0076 FFF7FEFF 		bl	vPortExitCritical
1320:../FreeRTOS/tasks.c **** 
1321:../FreeRTOS/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1385              		.loc 1 1321 0
 1386 007a 1D4B     		ldr	r3, .L94
 1387 007c 1B68     		ldr	r3, [r3]
 1388 007e FA68     		ldr	r2, [r7, #12]
 1389 0080 9A42     		cmp	r2, r3
 1390 0082 27D1     		bne	.L87
1322:../FreeRTOS/tasks.c **** 		{
1323:../FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1391              		.loc 1 1323 0
 1392 0084 1E4B     		ldr	r3, .L94+16
 1393 0086 1B68     		ldr	r3, [r3]
 1394 0088 002B     		cmp	r3, #0
 1395 008a 16D0     		beq	.L88
1324:../FreeRTOS/tasks.c **** 			{
1325:../FreeRTOS/tasks.c **** 				/* The current task has just been suspended. */
1326:../FreeRTOS/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 1396              		.loc 1 1326 0
 1397 008c 1D4B     		ldr	r3, .L94+20
 1398 008e 1B68     		ldr	r3, [r3]
 1399 0090 002B     		cmp	r3, #0
 1400 0092 09D0     		beq	.L89
 1401              	.LBB125:
 1402              	.LBB126:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1403              		.loc 2 215 0 discriminator 1
 1404              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1405 0094 4FF00703 			mov r3, #7												
 1406 0098 83F31188 		msr basepri, r3											
 1407 009c BFF36F8F 		isb														
 1408 00a0 BFF34F8F 		dsb														
 1409              	
 1410              	@ 0 "" 2
 1411              		.thumb
 1412 00a4 BB60     		str	r3, [r7, #8]
 1413              	.L90:
 1414              	.LBE126:
 1415              	.LBE125:
 1416              		.loc 1 1326 0 discriminator 1
 1417 00a6 FEE7     		b	.L90
 1418              	.L89:
1327:../FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 1419              		.loc 1 1327 0
 1420 00a8 174B     		ldr	r3, .L94+24
 1421 00aa 4FF08052 		mov	r2, #268435456
 1422 00ae 1A60     		str	r2, [r3]
 1423              	@ 1327 "../FreeRTOS/tasks.c" 1
 1424 00b0 BFF34F8F 		dsb
 1425              	@ 0 "" 2
 1426              	@ 1327 "../FreeRTOS/tasks.c" 1
 1427 00b4 BFF36F8F 		isb
 1428              	@ 0 "" 2
 1429              		.thumb
 1430 00b8 16E0     		b	.L81
 1431              	.L88:
1328:../FreeRTOS/tasks.c **** 			}
1329:../FreeRTOS/tasks.c **** 			else
1330:../FreeRTOS/tasks.c **** 			{
1331:../FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1332:../FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1333:../FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
1334:../FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1432              		.loc 1 1334 0
 1433 00ba 104B     		ldr	r3, .L94+12
 1434 00bc 1A68     		ldr	r2, [r3]
 1435 00be 134B     		ldr	r3, .L94+28
 1436 00c0 1B68     		ldr	r3, [r3]
 1437 00c2 9A42     		cmp	r2, r3
 1438 00c4 03D1     		bne	.L92
1335:../FreeRTOS/tasks.c **** 				{
1336:../FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1337:../FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1338:../FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
1339:../FreeRTOS/tasks.c **** 					is. */
1340:../FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
 1439              		.loc 1 1340 0
 1440 00c6 0A4B     		ldr	r3, .L94
 1441 00c8 0022     		movs	r2, #0
 1442 00ca 1A60     		str	r2, [r3]
 1443 00cc 0CE0     		b	.L81
 1444              	.L92:
1341:../FreeRTOS/tasks.c **** 				}
1342:../FreeRTOS/tasks.c **** 				else
1343:../FreeRTOS/tasks.c **** 				{
1344:../FreeRTOS/tasks.c **** 					vTaskSwitchContext();
 1445              		.loc 1 1344 0
 1446 00ce FFF7FEFF 		bl	vTaskSwitchContext
 1447 00d2 09E0     		b	.L81
 1448              	.L87:
1345:../FreeRTOS/tasks.c **** 				}
1346:../FreeRTOS/tasks.c **** 			}
1347:../FreeRTOS/tasks.c **** 		}
1348:../FreeRTOS/tasks.c **** 		else
1349:../FreeRTOS/tasks.c **** 		{
1350:../FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1449              		.loc 1 1350 0
 1450 00d4 0A4B     		ldr	r3, .L94+16
 1451 00d6 1B68     		ldr	r3, [r3]
 1452 00d8 002B     		cmp	r3, #0
 1453 00da 05D0     		beq	.L81
1351:../FreeRTOS/tasks.c **** 			{
1352:../FreeRTOS/tasks.c **** 				/* A task other than the currently running task was suspended,
1353:../FreeRTOS/tasks.c **** 				reset the next expected unblock time in case it referred to the
1354:../FreeRTOS/tasks.c **** 				task that is now in the Suspended state. */
1355:../FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 1454              		.loc 1 1355 0
 1455 00dc FFF7FEFF 		bl	vPortEnterCritical
1356:../FreeRTOS/tasks.c **** 				{
1357:../FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
 1456              		.loc 1 1357 0
 1457 00e0 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1358:../FreeRTOS/tasks.c **** 				}
1359:../FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 1458              		.loc 1 1359 0
 1459 00e4 FFF7FEFF 		bl	vPortExitCritical
 1460              	.L81:
1360:../FreeRTOS/tasks.c **** 			}
1361:../FreeRTOS/tasks.c **** 			else
1362:../FreeRTOS/tasks.c **** 			{
1363:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1364:../FreeRTOS/tasks.c **** 			}
1365:../FreeRTOS/tasks.c **** 		}
1366:../FreeRTOS/tasks.c **** 	}
 1461              		.loc 1 1366 0
 1462 00e8 1037     		adds	r7, r7, #16
 1463              		.cfi_def_cfa_offset 8
 1464 00ea BD46     		mov	sp, r7
 1465              		.cfi_def_cfa_register 13
 1466              		@ sp needed
 1467 00ec 80BD     		pop	{r7, pc}
 1468              	.L95:
 1469 00ee 00BF     		.align	2
 1470              	.L94:
 1471 00f0 00000000 		.word	pxCurrentTCB
 1472 00f4 00000000 		.word	pxReadyTasksLists
 1473 00f8 00000000 		.word	uxTopReadyPriority
 1474 00fc 00000000 		.word	xSuspendedTaskList
 1475 0100 00000000 		.word	xSchedulerRunning
 1476 0104 00000000 		.word	uxSchedulerSuspended
 1477 0108 04ED00E0 		.word	-536810236
 1478 010c 00000000 		.word	uxCurrentNumberOfTasks
 1479              		.cfi_endproc
 1480              	.LFE11:
 1482              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1483              		.align	2
 1484              		.thumb
 1485              		.thumb_func
 1487              	prvTaskIsTaskSuspended:
 1488              	.LFB12:
1367:../FreeRTOS/tasks.c **** 
1368:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1369:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1370:../FreeRTOS/tasks.c **** 
1371:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1372:../FreeRTOS/tasks.c **** 
1373:../FreeRTOS/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1374:../FreeRTOS/tasks.c **** 	{
 1489              		.loc 1 1374 0
 1490              		.cfi_startproc
 1491              		@ args = 0, pretend = 0, frame = 24
 1492              		@ frame_needed = 1, uses_anonymous_args = 0
 1493              		@ link register save eliminated.
 1494 0000 80B4     		push	{r7}
 1495              		.cfi_def_cfa_offset 4
 1496              		.cfi_offset 7, -4
 1497 0002 87B0     		sub	sp, sp, #28
 1498              		.cfi_def_cfa_offset 32
 1499 0004 00AF     		add	r7, sp, #0
 1500              		.cfi_def_cfa_register 7
 1501 0006 7860     		str	r0, [r7, #4]
1375:../FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1502              		.loc 1 1375 0
 1503 0008 0023     		movs	r3, #0
 1504 000a 7B61     		str	r3, [r7, #20]
1376:../FreeRTOS/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1505              		.loc 1 1376 0
 1506 000c 7B68     		ldr	r3, [r7, #4]
 1507 000e 3B61     		str	r3, [r7, #16]
1377:../FreeRTOS/tasks.c **** 
1378:../FreeRTOS/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1379:../FreeRTOS/tasks.c **** 		section. */
1380:../FreeRTOS/tasks.c **** 
1381:../FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1382:../FreeRTOS/tasks.c **** 		configASSERT( xTask );
 1508              		.loc 1 1382 0
 1509 0010 7B68     		ldr	r3, [r7, #4]
 1510 0012 002B     		cmp	r3, #0
 1511 0014 09D1     		bne	.L97
 1512              	.LBB127:
 1513              	.LBB128:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1514              		.loc 2 215 0 discriminator 1
 1515              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1516 0016 4FF00703 			mov r3, #7												
 1517 001a 83F31188 		msr basepri, r3											
 1518 001e BFF36F8F 		isb														
 1519 0022 BFF34F8F 		dsb														
 1520              	
 1521              	@ 0 "" 2
 1522              		.thumb
 1523 0026 FB60     		str	r3, [r7, #12]
 1524              	.L98:
 1525              	.LBE128:
 1526              	.LBE127:
 1527              		.loc 1 1382 0 discriminator 1
 1528 0028 FEE7     		b	.L98
 1529              	.L97:
1383:../FreeRTOS/tasks.c **** 
1384:../FreeRTOS/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1385:../FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1530              		.loc 1 1385 0
 1531 002a 3B69     		ldr	r3, [r7, #16]
 1532 002c 5B69     		ldr	r3, [r3, #20]
 1533 002e 0F4A     		ldr	r2, .L105
 1534 0030 9342     		cmp	r3, r2
 1535 0032 01D1     		bne	.L99
 1536              		.loc 1 1385 0 is_stmt 0 discriminator 1
 1537 0034 0123     		movs	r3, #1
 1538 0036 00E0     		b	.L100
 1539              	.L99:
 1540              		.loc 1 1385 0 discriminator 2
 1541 0038 0023     		movs	r3, #0
 1542              	.L100:
 1543              		.loc 1 1385 0 discriminator 4
 1544 003a 002B     		cmp	r3, #0
 1545 003c 0FD0     		beq	.L101
1386:../FreeRTOS/tasks.c **** 		{
1387:../FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1388:../FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1546              		.loc 1 1388 0 is_stmt 1
 1547 003e 3B69     		ldr	r3, [r7, #16]
 1548 0040 9B6A     		ldr	r3, [r3, #40]
 1549 0042 0B4A     		ldr	r2, .L105+4
 1550 0044 9342     		cmp	r3, r2
 1551 0046 0AD0     		beq	.L101
1389:../FreeRTOS/tasks.c **** 			{
1390:../FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1391:../FreeRTOS/tasks.c **** 				state, or because is is blocked with no timeout? */
1392:../FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1552              		.loc 1 1392 0
 1553 0048 3B69     		ldr	r3, [r7, #16]
 1554 004a 9B6A     		ldr	r3, [r3, #40]
 1555 004c 002B     		cmp	r3, #0
 1556 004e 01D1     		bne	.L102
 1557              		.loc 1 1392 0 is_stmt 0 discriminator 1
 1558 0050 0123     		movs	r3, #1
 1559 0052 00E0     		b	.L103
 1560              	.L102:
 1561              		.loc 1 1392 0 discriminator 2
 1562 0054 0023     		movs	r3, #0
 1563              	.L103:
 1564              		.loc 1 1392 0 discriminator 4
 1565 0056 002B     		cmp	r3, #0
 1566 0058 01D0     		beq	.L101
1393:../FreeRTOS/tasks.c **** 				{
1394:../FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 1567              		.loc 1 1394 0 is_stmt 1
 1568 005a 0123     		movs	r3, #1
 1569 005c 7B61     		str	r3, [r7, #20]
 1570              	.L101:
1395:../FreeRTOS/tasks.c **** 				}
1396:../FreeRTOS/tasks.c **** 				else
1397:../FreeRTOS/tasks.c **** 				{
1398:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1399:../FreeRTOS/tasks.c **** 				}
1400:../FreeRTOS/tasks.c **** 			}
1401:../FreeRTOS/tasks.c **** 			else
1402:../FreeRTOS/tasks.c **** 			{
1403:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1404:../FreeRTOS/tasks.c **** 			}
1405:../FreeRTOS/tasks.c **** 		}
1406:../FreeRTOS/tasks.c **** 		else
1407:../FreeRTOS/tasks.c **** 		{
1408:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1409:../FreeRTOS/tasks.c **** 		}
1410:../FreeRTOS/tasks.c **** 
1411:../FreeRTOS/tasks.c **** 		return xReturn;
 1571              		.loc 1 1411 0
 1572 005e 7B69     		ldr	r3, [r7, #20]
1412:../FreeRTOS/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1573              		.loc 1 1412 0
 1574 0060 1846     		mov	r0, r3
 1575 0062 1C37     		adds	r7, r7, #28
 1576              		.cfi_def_cfa_offset 4
 1577 0064 BD46     		mov	sp, r7
 1578              		.cfi_def_cfa_register 13
 1579              		@ sp needed
 1580 0066 5DF8047B 		ldr	r7, [sp], #4
 1581              		.cfi_restore 7
 1582              		.cfi_def_cfa_offset 0
 1583 006a 7047     		bx	lr
 1584              	.L106:
 1585              		.align	2
 1586              	.L105:
 1587 006c 00000000 		.word	xSuspendedTaskList
 1588 0070 00000000 		.word	xPendingReadyList
 1589              		.cfi_endproc
 1590              	.LFE12:
 1592              		.section	.text.vTaskResume,"ax",%progbits
 1593              		.align	2
 1594              		.global	vTaskResume
 1595              		.thumb
 1596              		.thumb_func
 1598              	vTaskResume:
 1599              	.LFB13:
1413:../FreeRTOS/tasks.c **** 
1414:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1415:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1416:../FreeRTOS/tasks.c **** 
1417:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1418:../FreeRTOS/tasks.c **** 
1419:../FreeRTOS/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1420:../FreeRTOS/tasks.c **** 	{
 1600              		.loc 1 1420 0
 1601              		.cfi_startproc
 1602              		@ args = 0, pretend = 0, frame = 16
 1603              		@ frame_needed = 1, uses_anonymous_args = 0
 1604 0000 80B5     		push	{r7, lr}
 1605              		.cfi_def_cfa_offset 8
 1606              		.cfi_offset 7, -8
 1607              		.cfi_offset 14, -4
 1608 0002 84B0     		sub	sp, sp, #16
 1609              		.cfi_def_cfa_offset 24
 1610 0004 00AF     		add	r7, sp, #0
 1611              		.cfi_def_cfa_register 7
 1612 0006 7860     		str	r0, [r7, #4]
1421:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1613              		.loc 1 1421 0
 1614 0008 7B68     		ldr	r3, [r7, #4]
 1615 000a FB60     		str	r3, [r7, #12]
1422:../FreeRTOS/tasks.c **** 
1423:../FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
1424:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToResume );
 1616              		.loc 1 1424 0
 1617 000c 7B68     		ldr	r3, [r7, #4]
 1618 000e 002B     		cmp	r3, #0
 1619 0010 09D1     		bne	.L108
 1620              	.LBB129:
 1621              	.LBB130:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1622              		.loc 2 215 0 discriminator 1
 1623              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1624 0012 4FF00703 			mov r3, #7												
 1625 0016 83F31188 		msr basepri, r3											
 1626 001a BFF36F8F 		isb														
 1627 001e BFF34F8F 		dsb														
 1628              	
 1629              	@ 0 "" 2
 1630              		.thumb
 1631 0022 BB60     		str	r3, [r7, #8]
 1632              	.L109:
 1633              	.LBE130:
 1634              	.LBE129:
 1635              		.loc 1 1424 0 discriminator 1
 1636 0024 FEE7     		b	.L109
 1637              	.L108:
1425:../FreeRTOS/tasks.c **** 
1426:../FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1427:../FreeRTOS/tasks.c **** 		currently executing task. */
1428:../FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1638              		.loc 1 1428 0
 1639 0026 FB68     		ldr	r3, [r7, #12]
 1640 0028 002B     		cmp	r3, #0
 1641 002a 2ED0     		beq	.L107
 1642              		.loc 1 1428 0 is_stmt 0 discriminator 1
 1643 002c 184B     		ldr	r3, .L112
 1644 002e 1B68     		ldr	r3, [r3]
 1645 0030 FA68     		ldr	r2, [r7, #12]
 1646 0032 9A42     		cmp	r2, r3
 1647 0034 29D0     		beq	.L107
1429:../FreeRTOS/tasks.c **** 		{
1430:../FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 1648              		.loc 1 1430 0 is_stmt 1
 1649 0036 FFF7FEFF 		bl	vPortEnterCritical
1431:../FreeRTOS/tasks.c **** 			{
1432:../FreeRTOS/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1650              		.loc 1 1432 0
 1651 003a F868     		ldr	r0, [r7, #12]
 1652 003c FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1653 0040 0346     		mov	r3, r0
 1654 0042 012B     		cmp	r3, #1
 1655 0044 1FD1     		bne	.L111
1433:../FreeRTOS/tasks.c **** 				{
1434:../FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
1435:../FreeRTOS/tasks.c **** 
1436:../FreeRTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
1437:../FreeRTOS/tasks.c **** 					lists even if the scheduler is suspended. */
1438:../FreeRTOS/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1656              		.loc 1 1438 0
 1657 0046 FB68     		ldr	r3, [r7, #12]
 1658 0048 0433     		adds	r3, r3, #4
 1659 004a 1846     		mov	r0, r3
 1660 004c FFF7FEFF 		bl	uxListRemove
1439:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1661              		.loc 1 1439 0
 1662 0050 FB68     		ldr	r3, [r7, #12]
 1663 0052 DB6A     		ldr	r3, [r3, #44]
 1664 0054 1A46     		mov	r2, r3
 1665 0056 0123     		movs	r3, #1
 1666 0058 03FA02F2 		lsl	r2, r3, r2
 1667 005c 0D4B     		ldr	r3, .L112+4
 1668 005e 1B68     		ldr	r3, [r3]
 1669 0060 1343     		orrs	r3, r3, r2
 1670 0062 0C4A     		ldr	r2, .L112+4
 1671 0064 1360     		str	r3, [r2]
 1672 0066 FB68     		ldr	r3, [r7, #12]
 1673 0068 DA6A     		ldr	r2, [r3, #44]
 1674 006a 1346     		mov	r3, r2
 1675 006c 9B00     		lsls	r3, r3, #2
 1676 006e 1344     		add	r3, r3, r2
 1677 0070 9B00     		lsls	r3, r3, #2
 1678 0072 094A     		ldr	r2, .L112+8
 1679 0074 1A44     		add	r2, r2, r3
 1680 0076 FB68     		ldr	r3, [r7, #12]
 1681 0078 0433     		adds	r3, r3, #4
 1682 007a 1046     		mov	r0, r2
 1683 007c 1946     		mov	r1, r3
 1684 007e FFF7FEFF 		bl	vListInsertEnd
1440:../FreeRTOS/tasks.c **** 
1441:../FreeRTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
1442:../FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1685              		.loc 1 1442 0
 1686 0082 034B     		ldr	r3, .L112
 1687 0084 1B68     		ldr	r3, [r3]
 1688              	.L111:
1443:../FreeRTOS/tasks.c **** 					{
1444:../FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1445:../FreeRTOS/tasks.c **** 						but will leave the lists in the correct state for the
1446:../FreeRTOS/tasks.c **** 						next yield. */
1447:../FreeRTOS/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1448:../FreeRTOS/tasks.c **** 					}
1449:../FreeRTOS/tasks.c **** 					else
1450:../FreeRTOS/tasks.c **** 					{
1451:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1452:../FreeRTOS/tasks.c **** 					}
1453:../FreeRTOS/tasks.c **** 				}
1454:../FreeRTOS/tasks.c **** 				else
1455:../FreeRTOS/tasks.c **** 				{
1456:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1457:../FreeRTOS/tasks.c **** 				}
1458:../FreeRTOS/tasks.c **** 			}
1459:../FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 1689              		.loc 1 1459 0
 1690 0086 FFF7FEFF 		bl	vPortExitCritical
 1691              	.L107:
1460:../FreeRTOS/tasks.c **** 		}
1461:../FreeRTOS/tasks.c **** 		else
1462:../FreeRTOS/tasks.c **** 		{
1463:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1464:../FreeRTOS/tasks.c **** 		}
1465:../FreeRTOS/tasks.c **** 	}
 1692              		.loc 1 1465 0
 1693 008a 1037     		adds	r7, r7, #16
 1694              		.cfi_def_cfa_offset 8
 1695 008c BD46     		mov	sp, r7
 1696              		.cfi_def_cfa_register 13
 1697              		@ sp needed
 1698 008e 80BD     		pop	{r7, pc}
 1699              	.L113:
 1700              		.align	2
 1701              	.L112:
 1702 0090 00000000 		.word	pxCurrentTCB
 1703 0094 00000000 		.word	uxTopReadyPriority
 1704 0098 00000000 		.word	pxReadyTasksLists
 1705              		.cfi_endproc
 1706              	.LFE13:
 1708              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1709              		.align	2
 1710              		.global	xTaskResumeFromISR
 1711              		.thumb
 1712              		.thumb_func
 1714              	xTaskResumeFromISR:
 1715              	.LFB14:
1466:../FreeRTOS/tasks.c **** 
1467:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1468:../FreeRTOS/tasks.c **** 
1469:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1470:../FreeRTOS/tasks.c **** 
1471:../FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1472:../FreeRTOS/tasks.c **** 
1473:../FreeRTOS/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1474:../FreeRTOS/tasks.c **** 	{
 1716              		.loc 1 1474 0
 1717              		.cfi_startproc
 1718              		@ args = 0, pretend = 0, frame = 40
 1719              		@ frame_needed = 1, uses_anonymous_args = 0
 1720 0000 80B5     		push	{r7, lr}
 1721              		.cfi_def_cfa_offset 8
 1722              		.cfi_offset 7, -8
 1723              		.cfi_offset 14, -4
 1724 0002 8AB0     		sub	sp, sp, #40
 1725              		.cfi_def_cfa_offset 48
 1726 0004 00AF     		add	r7, sp, #0
 1727              		.cfi_def_cfa_register 7
 1728 0006 7860     		str	r0, [r7, #4]
1475:../FreeRTOS/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1729              		.loc 1 1475 0
 1730 0008 0023     		movs	r3, #0
 1731 000a 7B62     		str	r3, [r7, #36]
1476:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1732              		.loc 1 1476 0
 1733 000c 7B68     		ldr	r3, [r7, #4]
 1734 000e 3B62     		str	r3, [r7, #32]
1477:../FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1478:../FreeRTOS/tasks.c **** 
1479:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToResume );
 1735              		.loc 1 1479 0
 1736 0010 7B68     		ldr	r3, [r7, #4]
 1737 0012 002B     		cmp	r3, #0
 1738 0014 09D1     		bne	.L115
 1739              	.LBB131:
 1740              	.LBB132:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1741              		.loc 2 215 0 discriminator 1
 1742              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1743 0016 4FF00703 			mov r3, #7												
 1744 001a 83F31188 		msr basepri, r3											
 1745 001e BFF36F8F 		isb														
 1746 0022 BFF34F8F 		dsb														
 1747              	
 1748              	@ 0 "" 2
 1749              		.thumb
 1750 0026 BB61     		str	r3, [r7, #24]
 1751              	.L116:
 1752              	.LBE132:
 1753              	.LBE131:
 1754              		.loc 1 1479 0 discriminator 1
 1755 0028 FEE7     		b	.L116
 1756              	.L115:
1480:../FreeRTOS/tasks.c **** 
1481:../FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1482:../FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1483:../FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1484:../FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1485:../FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1486:../FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
1487:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1488:../FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1489:../FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
1490:../FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1491:../FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1492:../FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1493:../FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1494:../FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1495:../FreeRTOS/tasks.c **** 		provided on the following link:
1496:../FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1497:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1757              		.loc 1 1497 0
 1758 002a FFF7FEFF 		bl	vPortValidateInterruptPriority
 1759              	.LBB133:
 1760              	.LBB134:
 231:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1761              		.loc 2 231 0
 1762              	@ 231 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1763 002e EFF31182 			mrs r2, basepri											
 1764 0032 4FF00703 		mov r3, #7												
 1765 0036 83F31188 		msr basepri, r3											
 1766 003a BFF36F8F 		isb														
 1767 003e BFF34F8F 		dsb														
 1768              	
 1769              	@ 0 "" 2
 1770              		.thumb
 1771 0042 7A61     		str	r2, [r7, #20]
 1772 0044 3B61     		str	r3, [r7, #16]
 243:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** }
 1773              		.loc 2 243 0
 1774 0046 7B69     		ldr	r3, [r7, #20]
 1775              	.LBE134:
 1776              	.LBE133:
1498:../FreeRTOS/tasks.c **** 
1499:../FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1777              		.loc 1 1499 0
 1778 0048 FB61     		str	r3, [r7, #28]
1500:../FreeRTOS/tasks.c **** 		{
1501:../FreeRTOS/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1779              		.loc 1 1501 0
 1780 004a 386A     		ldr	r0, [r7, #32]
 1781 004c FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1782 0050 0346     		mov	r3, r0
 1783 0052 012B     		cmp	r3, #1
 1784 0054 31D1     		bne	.L118
1502:../FreeRTOS/tasks.c **** 			{
1503:../FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1504:../FreeRTOS/tasks.c **** 
1505:../FreeRTOS/tasks.c **** 				/* Check the ready lists can be accessed. */
1506:../FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1785              		.loc 1 1506 0
 1786 0056 1E4B     		ldr	r3, .L123
 1787 0058 1B68     		ldr	r3, [r3]
 1788 005a 002B     		cmp	r3, #0
 1789 005c 27D1     		bne	.L119
1507:../FreeRTOS/tasks.c **** 				{
1508:../FreeRTOS/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1509:../FreeRTOS/tasks.c **** 					suspended list to the ready list directly. */
1510:../FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1790              		.loc 1 1510 0
 1791 005e 3B6A     		ldr	r3, [r7, #32]
 1792 0060 DA6A     		ldr	r2, [r3, #44]
 1793 0062 1C4B     		ldr	r3, .L123+4
 1794 0064 1B68     		ldr	r3, [r3]
 1795 0066 DB6A     		ldr	r3, [r3, #44]
 1796 0068 9A42     		cmp	r2, r3
 1797 006a 01D3     		bcc	.L120
1511:../FreeRTOS/tasks.c **** 					{
1512:../FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 1798              		.loc 1 1512 0
 1799 006c 0123     		movs	r3, #1
 1800 006e 7B62     		str	r3, [r7, #36]
 1801              	.L120:
1513:../FreeRTOS/tasks.c **** 					}
1514:../FreeRTOS/tasks.c **** 					else
1515:../FreeRTOS/tasks.c **** 					{
1516:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1517:../FreeRTOS/tasks.c **** 					}
1518:../FreeRTOS/tasks.c **** 
1519:../FreeRTOS/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1802              		.loc 1 1519 0
 1803 0070 3B6A     		ldr	r3, [r7, #32]
 1804 0072 0433     		adds	r3, r3, #4
 1805 0074 1846     		mov	r0, r3
 1806 0076 FFF7FEFF 		bl	uxListRemove
1520:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1807              		.loc 1 1520 0
 1808 007a 3B6A     		ldr	r3, [r7, #32]
 1809 007c DB6A     		ldr	r3, [r3, #44]
 1810 007e 1A46     		mov	r2, r3
 1811 0080 0123     		movs	r3, #1
 1812 0082 03FA02F2 		lsl	r2, r3, r2
 1813 0086 144B     		ldr	r3, .L123+8
 1814 0088 1B68     		ldr	r3, [r3]
 1815 008a 1343     		orrs	r3, r3, r2
 1816 008c 124A     		ldr	r2, .L123+8
 1817 008e 1360     		str	r3, [r2]
 1818 0090 3B6A     		ldr	r3, [r7, #32]
 1819 0092 DA6A     		ldr	r2, [r3, #44]
 1820 0094 1346     		mov	r3, r2
 1821 0096 9B00     		lsls	r3, r3, #2
 1822 0098 1344     		add	r3, r3, r2
 1823 009a 9B00     		lsls	r3, r3, #2
 1824 009c 0F4A     		ldr	r2, .L123+12
 1825 009e 1A44     		add	r2, r2, r3
 1826 00a0 3B6A     		ldr	r3, [r7, #32]
 1827 00a2 0433     		adds	r3, r3, #4
 1828 00a4 1046     		mov	r0, r2
 1829 00a6 1946     		mov	r1, r3
 1830 00a8 FFF7FEFF 		bl	vListInsertEnd
 1831 00ac 05E0     		b	.L118
 1832              	.L119:
1521:../FreeRTOS/tasks.c **** 				}
1522:../FreeRTOS/tasks.c **** 				else
1523:../FreeRTOS/tasks.c **** 				{
1524:../FreeRTOS/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1525:../FreeRTOS/tasks.c **** 					is held in the pending ready list until the scheduler is
1526:../FreeRTOS/tasks.c **** 					unsuspended. */
1527:../FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1833              		.loc 1 1527 0
 1834 00ae 3B6A     		ldr	r3, [r7, #32]
 1835 00b0 1833     		adds	r3, r3, #24
 1836 00b2 0B48     		ldr	r0, .L123+16
 1837 00b4 1946     		mov	r1, r3
 1838 00b6 FFF7FEFF 		bl	vListInsertEnd
 1839              	.L118:
 1840 00ba FB69     		ldr	r3, [r7, #28]
 1841 00bc FB60     		str	r3, [r7, #12]
 1842              	.LBB135:
 1843              	.LBB136:
 1844              		.loc 2 249 0
 1845 00be FB68     		ldr	r3, [r7, #12]
 1846              	@ 249 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1847 00c0 83F31188 			msr basepri, r3	
 1848              	@ 0 "" 2
 1849              		.thumb
 1850              	.LBE136:
 1851              	.LBE135:
1528:../FreeRTOS/tasks.c **** 				}
1529:../FreeRTOS/tasks.c **** 			}
1530:../FreeRTOS/tasks.c **** 			else
1531:../FreeRTOS/tasks.c **** 			{
1532:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1533:../FreeRTOS/tasks.c **** 			}
1534:../FreeRTOS/tasks.c **** 		}
1535:../FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1536:../FreeRTOS/tasks.c **** 
1537:../FreeRTOS/tasks.c **** 		return xYieldRequired;
 1852              		.loc 1 1537 0
 1853 00c4 7B6A     		ldr	r3, [r7, #36]
1538:../FreeRTOS/tasks.c **** 	}
 1854              		.loc 1 1538 0
 1855 00c6 1846     		mov	r0, r3
 1856 00c8 2837     		adds	r7, r7, #40
 1857              		.cfi_def_cfa_offset 8
 1858 00ca BD46     		mov	sp, r7
 1859              		.cfi_def_cfa_register 13
 1860              		@ sp needed
 1861 00cc 80BD     		pop	{r7, pc}
 1862              	.L124:
 1863 00ce 00BF     		.align	2
 1864              	.L123:
 1865 00d0 00000000 		.word	uxSchedulerSuspended
 1866 00d4 00000000 		.word	pxCurrentTCB
 1867 00d8 00000000 		.word	uxTopReadyPriority
 1868 00dc 00000000 		.word	pxReadyTasksLists
 1869 00e0 00000000 		.word	xPendingReadyList
 1870              		.cfi_endproc
 1871              	.LFE14:
 1873              		.section	.rodata
 1874              		.align	2
 1875              	.LC0:
 1876 0000 49444C45 		.ascii	"IDLE\000"
 1876      00
 1877              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1878              		.align	2
 1879              		.global	vTaskStartScheduler
 1880              		.thumb
 1881              		.thumb_func
 1883              	vTaskStartScheduler:
 1884              	.LFB15:
1539:../FreeRTOS/tasks.c **** 
1540:../FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1541:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1542:../FreeRTOS/tasks.c **** 
1543:../FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1544:../FreeRTOS/tasks.c **** {
 1885              		.loc 1 1544 0
 1886              		.cfi_startproc
 1887              		@ args = 0, pretend = 0, frame = 16
 1888              		@ frame_needed = 1, uses_anonymous_args = 0
 1889 0000 80B5     		push	{r7, lr}
 1890              		.cfi_def_cfa_offset 8
 1891              		.cfi_offset 7, -8
 1892              		.cfi_offset 14, -4
 1893 0002 88B0     		sub	sp, sp, #32
 1894              		.cfi_def_cfa_offset 40
 1895 0004 04AF     		add	r7, sp, #16
 1896              		.cfi_def_cfa 7, 24
1545:../FreeRTOS/tasks.c **** BaseType_t xReturn;
1546:../FreeRTOS/tasks.c **** 
1547:../FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1548:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1549:../FreeRTOS/tasks.c **** 	{
1550:../FreeRTOS/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1551:../FreeRTOS/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1552:../FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1553:../FreeRTOS/tasks.c **** 	}
1554:../FreeRTOS/tasks.c **** 	#else
1555:../FreeRTOS/tasks.c **** 	{
1556:../FreeRTOS/tasks.c **** 		/* Create the idle task without storing its handle. */
1557:../FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
 1897              		.loc 1 1557 0
 1898 0006 0023     		movs	r3, #0
 1899 0008 0093     		str	r3, [sp]
 1900 000a 0023     		movs	r3, #0
 1901 000c 0193     		str	r3, [sp, #4]
 1902 000e 0023     		movs	r3, #0
 1903 0010 0293     		str	r3, [sp, #8]
 1904 0012 0023     		movs	r3, #0
 1905 0014 0393     		str	r3, [sp, #12]
 1906 0016 1B48     		ldr	r0, .L130
 1907 0018 1B49     		ldr	r1, .L130+4
 1908 001a 8022     		movs	r2, #128
 1909 001c 0023     		movs	r3, #0
 1910 001e FFF7FEFF 		bl	xTaskGenericCreate
 1911 0022 F860     		str	r0, [r7, #12]
1558:../FreeRTOS/tasks.c **** 	}
1559:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1560:../FreeRTOS/tasks.c **** 
1561:../FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1562:../FreeRTOS/tasks.c **** 	{
1563:../FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
 1912              		.loc 1 1563 0
 1913 0024 FB68     		ldr	r3, [r7, #12]
 1914 0026 012B     		cmp	r3, #1
 1915 0028 02D1     		bne	.L126
1564:../FreeRTOS/tasks.c **** 		{
1565:../FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1916              		.loc 1 1565 0
 1917 002a FFF7FEFF 		bl	xTimerCreateTimerTask
 1918 002e F860     		str	r0, [r7, #12]
 1919              	.L126:
1566:../FreeRTOS/tasks.c **** 		}
1567:../FreeRTOS/tasks.c **** 		else
1568:../FreeRTOS/tasks.c **** 		{
1569:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1570:../FreeRTOS/tasks.c **** 		}
1571:../FreeRTOS/tasks.c **** 	}
1572:../FreeRTOS/tasks.c **** 	#endif /* configUSE_TIMERS */
1573:../FreeRTOS/tasks.c **** 
1574:../FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 1920              		.loc 1 1574 0
 1921 0030 FB68     		ldr	r3, [r7, #12]
 1922 0032 012B     		cmp	r3, #1
 1923 0034 15D1     		bne	.L127
 1924              	.LBB137:
 1925              	.LBB138:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1926              		.loc 2 215 0
 1927              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1928 0036 4FF00703 			mov r3, #7												
 1929 003a 83F31188 		msr basepri, r3											
 1930 003e BFF36F8F 		isb														
 1931 0042 BFF34F8F 		dsb														
 1932              	
 1933              	@ 0 "" 2
 1934              		.thumb
 1935 0046 BB60     		str	r3, [r7, #8]
 1936              	.LBE138:
 1937              	.LBE137:
1575:../FreeRTOS/tasks.c **** 	{
1576:../FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1577:../FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1578:../FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1579:../FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1580:../FreeRTOS/tasks.c **** 		starts to run. */
1581:../FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
1582:../FreeRTOS/tasks.c **** 
1583:../FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1584:../FreeRTOS/tasks.c **** 		{
1585:../FreeRTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1586:../FreeRTOS/tasks.c **** 			structure specific to the task that will run first. */
1587:../FreeRTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1588:../FreeRTOS/tasks.c **** 		}
1589:../FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1590:../FreeRTOS/tasks.c **** 
1591:../FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1938              		.loc 1 1591 0
 1939 0048 104B     		ldr	r3, .L130+8
 1940 004a 4FF0FF32 		mov	r2, #-1
 1941 004e 1A60     		str	r2, [r3]
1592:../FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1942              		.loc 1 1592 0
 1943 0050 0F4B     		ldr	r3, .L130+12
 1944 0052 0122     		movs	r2, #1
 1945 0054 1A60     		str	r2, [r3]
1593:../FreeRTOS/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1946              		.loc 1 1593 0
 1947 0056 0F4B     		ldr	r3, .L130+16
 1948 0058 0022     		movs	r2, #0
 1949 005a 1A60     		str	r2, [r3]
1594:../FreeRTOS/tasks.c **** 
1595:../FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1596:../FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1597:../FreeRTOS/tasks.c **** 		the run time counter time base. */
1598:../FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1599:../FreeRTOS/tasks.c **** 
1600:../FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1601:../FreeRTOS/tasks.c **** 		portable interface. */
1602:../FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1950              		.loc 1 1602 0
 1951 005c FFF7FEFF 		bl	xPortStartScheduler
 1952 0060 0CE0     		b	.L125
 1953              	.L127:
1603:../FreeRTOS/tasks.c **** 		{
1604:../FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1605:../FreeRTOS/tasks.c **** 			function will not return. */
1606:../FreeRTOS/tasks.c **** 		}
1607:../FreeRTOS/tasks.c **** 		else
1608:../FreeRTOS/tasks.c **** 		{
1609:../FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1610:../FreeRTOS/tasks.c **** 		}
1611:../FreeRTOS/tasks.c **** 	}
1612:../FreeRTOS/tasks.c **** 	else
1613:../FreeRTOS/tasks.c **** 	{
1614:../FreeRTOS/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1615:../FreeRTOS/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1616:../FreeRTOS/tasks.c **** 		or the timer task. */
1617:../FreeRTOS/tasks.c **** 		configASSERT( xReturn );
 1954              		.loc 1 1617 0
 1955 0062 FB68     		ldr	r3, [r7, #12]
 1956 0064 002B     		cmp	r3, #0
 1957 0066 09D1     		bne	.L125
 1958              	.LBB139:
 1959              	.LBB140:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 1960              		.loc 2 215 0 discriminator 1
 1961              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 1962 0068 4FF00703 			mov r3, #7												
 1963 006c 83F31188 		msr basepri, r3											
 1964 0070 BFF36F8F 		isb														
 1965 0074 BFF34F8F 		dsb														
 1966              	
 1967              	@ 0 "" 2
 1968              		.thumb
 1969 0078 7B60     		str	r3, [r7, #4]
 1970              	.L129:
 1971              	.LBE140:
 1972              	.LBE139:
 1973              		.loc 1 1617 0 discriminator 2
 1974 007a FEE7     		b	.L129
 1975              	.L125:
1618:../FreeRTOS/tasks.c **** 	}
1619:../FreeRTOS/tasks.c **** }
 1976              		.loc 1 1619 0
 1977 007c 1037     		adds	r7, r7, #16
 1978              		.cfi_def_cfa_offset 8
 1979 007e BD46     		mov	sp, r7
 1980              		.cfi_def_cfa_register 13
 1981              		@ sp needed
 1982 0080 80BD     		pop	{r7, pc}
 1983              	.L131:
 1984 0082 00BF     		.align	2
 1985              	.L130:
 1986 0084 00000000 		.word	prvIdleTask
 1987 0088 00000000 		.word	.LC0
 1988 008c 00000000 		.word	xNextTaskUnblockTime
 1989 0090 00000000 		.word	xSchedulerRunning
 1990 0094 00000000 		.word	xTickCount
 1991              		.cfi_endproc
 1992              	.LFE15:
 1994              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1995              		.align	2
 1996              		.global	vTaskEndScheduler
 1997              		.thumb
 1998              		.thumb_func
 2000              	vTaskEndScheduler:
 2001              	.LFB16:
1620:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1621:../FreeRTOS/tasks.c **** 
1622:../FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
1623:../FreeRTOS/tasks.c **** {
 2002              		.loc 1 1623 0
 2003              		.cfi_startproc
 2004              		@ args = 0, pretend = 0, frame = 8
 2005              		@ frame_needed = 1, uses_anonymous_args = 0
 2006 0000 80B5     		push	{r7, lr}
 2007              		.cfi_def_cfa_offset 8
 2008              		.cfi_offset 7, -8
 2009              		.cfi_offset 14, -4
 2010 0002 82B0     		sub	sp, sp, #8
 2011              		.cfi_def_cfa_offset 16
 2012 0004 00AF     		add	r7, sp, #0
 2013              		.cfi_def_cfa_register 7
 2014              	.LBB141:
 2015              	.LBB142:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 2016              		.loc 2 215 0
 2017              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2018 0006 4FF00703 			mov r3, #7												
 2019 000a 83F31188 		msr basepri, r3											
 2020 000e BFF36F8F 		isb														
 2021 0012 BFF34F8F 		dsb														
 2022              	
 2023              	@ 0 "" 2
 2024              		.thumb
 2025 0016 7B60     		str	r3, [r7, #4]
 2026              	.LBE142:
 2027              	.LBE141:
1624:../FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1625:../FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1626:../FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1627:../FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
1628:../FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 2028              		.loc 1 1628 0
 2029 0018 034B     		ldr	r3, .L133
 2030 001a 0022     		movs	r2, #0
 2031 001c 1A60     		str	r2, [r3]
1629:../FreeRTOS/tasks.c **** 	vPortEndScheduler();
 2032              		.loc 1 1629 0
 2033 001e FFF7FEFF 		bl	vPortEndScheduler
1630:../FreeRTOS/tasks.c **** }
 2034              		.loc 1 1630 0
 2035 0022 0837     		adds	r7, r7, #8
 2036              		.cfi_def_cfa_offset 8
 2037 0024 BD46     		mov	sp, r7
 2038              		.cfi_def_cfa_register 13
 2039              		@ sp needed
 2040 0026 80BD     		pop	{r7, pc}
 2041              	.L134:
 2042              		.align	2
 2043              	.L133:
 2044 0028 00000000 		.word	xSchedulerRunning
 2045              		.cfi_endproc
 2046              	.LFE16:
 2048              		.section	.text.vTaskSuspendAll,"ax",%progbits
 2049              		.align	2
 2050              		.global	vTaskSuspendAll
 2051              		.thumb
 2052              		.thumb_func
 2054              	vTaskSuspendAll:
 2055              	.LFB17:
1631:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1632:../FreeRTOS/tasks.c **** 
1633:../FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
1634:../FreeRTOS/tasks.c **** {
 2056              		.loc 1 1634 0
 2057              		.cfi_startproc
 2058              		@ args = 0, pretend = 0, frame = 0
 2059              		@ frame_needed = 1, uses_anonymous_args = 0
 2060              		@ link register save eliminated.
 2061 0000 80B4     		push	{r7}
 2062              		.cfi_def_cfa_offset 4
 2063              		.cfi_offset 7, -4
 2064 0002 00AF     		add	r7, sp, #0
 2065              		.cfi_def_cfa_register 7
1635:../FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1636:../FreeRTOS/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1637:../FreeRTOS/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1638:../FreeRTOS/tasks.c **** 	http://goo.gl/wu4acr */
1639:../FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
 2066              		.loc 1 1639 0
 2067 0004 044B     		ldr	r3, .L136
 2068 0006 1B68     		ldr	r3, [r3]
 2069 0008 0133     		adds	r3, r3, #1
 2070 000a 034A     		ldr	r2, .L136
 2071 000c 1360     		str	r3, [r2]
1640:../FreeRTOS/tasks.c **** }
 2072              		.loc 1 1640 0
 2073 000e BD46     		mov	sp, r7
 2074              		.cfi_def_cfa_register 13
 2075              		@ sp needed
 2076 0010 5DF8047B 		ldr	r7, [sp], #4
 2077              		.cfi_restore 7
 2078              		.cfi_def_cfa_offset 0
 2079 0014 7047     		bx	lr
 2080              	.L137:
 2081 0016 00BF     		.align	2
 2082              	.L136:
 2083 0018 00000000 		.word	uxSchedulerSuspended
 2084              		.cfi_endproc
 2085              	.LFE17:
 2087              		.section	.text.xTaskResumeAll,"ax",%progbits
 2088              		.align	2
 2089              		.global	xTaskResumeAll
 2090              		.thumb
 2091              		.thumb_func
 2093              	xTaskResumeAll:
 2094              	.LFB18:
1641:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1642:../FreeRTOS/tasks.c **** 
1643:../FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1644:../FreeRTOS/tasks.c **** 
1645:../FreeRTOS/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1646:../FreeRTOS/tasks.c **** 	{
1647:../FreeRTOS/tasks.c **** 	TickType_t xReturn;
1648:../FreeRTOS/tasks.c **** 
1649:../FreeRTOS/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1650:../FreeRTOS/tasks.c **** 		{
1651:../FreeRTOS/tasks.c **** 			xReturn = 0;
1652:../FreeRTOS/tasks.c **** 		}
1653:../FreeRTOS/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1654:../FreeRTOS/tasks.c **** 		{
1655:../FreeRTOS/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1656:../FreeRTOS/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1657:../FreeRTOS/tasks.c **** 			processed. */
1658:../FreeRTOS/tasks.c **** 			xReturn = 0;
1659:../FreeRTOS/tasks.c **** 		}
1660:../FreeRTOS/tasks.c **** 		else
1661:../FreeRTOS/tasks.c **** 		{
1662:../FreeRTOS/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1663:../FreeRTOS/tasks.c **** 		}
1664:../FreeRTOS/tasks.c **** 
1665:../FreeRTOS/tasks.c **** 		return xReturn;
1666:../FreeRTOS/tasks.c **** 	}
1667:../FreeRTOS/tasks.c **** 
1668:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1669:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1670:../FreeRTOS/tasks.c **** 
1671:../FreeRTOS/tasks.c **** BaseType_t xTaskResumeAll( void )
1672:../FreeRTOS/tasks.c **** {
 2095              		.loc 1 1672 0
 2096              		.cfi_startproc
 2097              		@ args = 0, pretend = 0, frame = 16
 2098              		@ frame_needed = 1, uses_anonymous_args = 0
 2099 0000 80B5     		push	{r7, lr}
 2100              		.cfi_def_cfa_offset 8
 2101              		.cfi_offset 7, -8
 2102              		.cfi_offset 14, -4
 2103 0002 84B0     		sub	sp, sp, #16
 2104              		.cfi_def_cfa_offset 24
 2105 0004 00AF     		add	r7, sp, #0
 2106              		.cfi_def_cfa_register 7
1673:../FreeRTOS/tasks.c **** TCB_t *pxTCB;
1674:../FreeRTOS/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 2107              		.loc 1 1674 0
 2108 0006 0023     		movs	r3, #0
 2109 0008 FB60     		str	r3, [r7, #12]
1675:../FreeRTOS/tasks.c **** 
1676:../FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1677:../FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1678:../FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 2110              		.loc 1 1678 0
 2111 000a 394B     		ldr	r3, .L149
 2112 000c 1B68     		ldr	r3, [r3]
 2113 000e 002B     		cmp	r3, #0
 2114 0010 09D1     		bne	.L139
 2115              	.LBB143:
 2116              	.LBB144:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 2117              		.loc 2 215 0 discriminator 1
 2118              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2119 0012 4FF00703 			mov r3, #7												
 2120 0016 83F31188 		msr basepri, r3											
 2121 001a BFF36F8F 		isb														
 2122 001e BFF34F8F 		dsb														
 2123              	
 2124              	@ 0 "" 2
 2125              		.thumb
 2126 0022 7B60     		str	r3, [r7, #4]
 2127              	.L140:
 2128              	.LBE144:
 2129              	.LBE143:
 2130              		.loc 1 1678 0 discriminator 1
 2131 0024 FEE7     		b	.L140
 2132              	.L139:
1679:../FreeRTOS/tasks.c **** 
1680:../FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1681:../FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1682:../FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1683:../FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1684:../FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1685:../FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 2133              		.loc 1 1685 0
 2134 0026 FFF7FEFF 		bl	vPortEnterCritical
1686:../FreeRTOS/tasks.c **** 	{
1687:../FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
 2135              		.loc 1 1687 0
 2136 002a 314B     		ldr	r3, .L149
 2137 002c 1B68     		ldr	r3, [r3]
 2138 002e 013B     		subs	r3, r3, #1
 2139 0030 2F4A     		ldr	r2, .L149
 2140 0032 1360     		str	r3, [r2]
1688:../FreeRTOS/tasks.c **** 
1689:../FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2141              		.loc 1 1689 0
 2142 0034 2E4B     		ldr	r3, .L149
 2143 0036 1B68     		ldr	r3, [r3]
 2144 0038 002B     		cmp	r3, #0
 2145 003a 51D1     		bne	.L141
1690:../FreeRTOS/tasks.c **** 		{
1691:../FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2146              		.loc 1 1691 0
 2147 003c 2D4B     		ldr	r3, .L149+4
 2148 003e 1B68     		ldr	r3, [r3]
 2149 0040 002B     		cmp	r3, #0
 2150 0042 4DD0     		beq	.L141
1692:../FreeRTOS/tasks.c **** 			{
1693:../FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1694:../FreeRTOS/tasks.c **** 				appropriate ready list. */
1695:../FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2151              		.loc 1 1695 0
 2152 0044 30E0     		b	.L142
 2153              	.L143:
1696:../FreeRTOS/tasks.c **** 				{
1697:../FreeRTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 2154              		.loc 1 1697 0
 2155 0046 2C4B     		ldr	r3, .L149+8
 2156 0048 DB68     		ldr	r3, [r3, #12]
 2157 004a DB68     		ldr	r3, [r3, #12]
 2158 004c BB60     		str	r3, [r7, #8]
1698:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2159              		.loc 1 1698 0
 2160 004e BB68     		ldr	r3, [r7, #8]
 2161 0050 1833     		adds	r3, r3, #24
 2162 0052 1846     		mov	r0, r3
 2163 0054 FFF7FEFF 		bl	uxListRemove
1699:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2164              		.loc 1 1699 0
 2165 0058 BB68     		ldr	r3, [r7, #8]
 2166 005a 0433     		adds	r3, r3, #4
 2167 005c 1846     		mov	r0, r3
 2168 005e FFF7FEFF 		bl	uxListRemove
1700:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2169              		.loc 1 1700 0
 2170 0062 BB68     		ldr	r3, [r7, #8]
 2171 0064 DB6A     		ldr	r3, [r3, #44]
 2172 0066 1A46     		mov	r2, r3
 2173 0068 0123     		movs	r3, #1
 2174 006a 03FA02F2 		lsl	r2, r3, r2
 2175 006e 234B     		ldr	r3, .L149+12
 2176 0070 1B68     		ldr	r3, [r3]
 2177 0072 1343     		orrs	r3, r3, r2
 2178 0074 214A     		ldr	r2, .L149+12
 2179 0076 1360     		str	r3, [r2]
 2180 0078 BB68     		ldr	r3, [r7, #8]
 2181 007a DA6A     		ldr	r2, [r3, #44]
 2182 007c 1346     		mov	r3, r2
 2183 007e 9B00     		lsls	r3, r3, #2
 2184 0080 1344     		add	r3, r3, r2
 2185 0082 9B00     		lsls	r3, r3, #2
 2186 0084 1E4A     		ldr	r2, .L149+16
 2187 0086 1A44     		add	r2, r2, r3
 2188 0088 BB68     		ldr	r3, [r7, #8]
 2189 008a 0433     		adds	r3, r3, #4
 2190 008c 1046     		mov	r0, r2
 2191 008e 1946     		mov	r1, r3
 2192 0090 FFF7FEFF 		bl	vListInsertEnd
1701:../FreeRTOS/tasks.c **** 
1702:../FreeRTOS/tasks.c **** 					/* If the moved task has a priority higher than the current
1703:../FreeRTOS/tasks.c **** 					task then a yield must be performed. */
1704:../FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2193              		.loc 1 1704 0
 2194 0094 BB68     		ldr	r3, [r7, #8]
 2195 0096 DA6A     		ldr	r2, [r3, #44]
 2196 0098 1A4B     		ldr	r3, .L149+20
 2197 009a 1B68     		ldr	r3, [r3]
 2198 009c DB6A     		ldr	r3, [r3, #44]
 2199 009e 9A42     		cmp	r2, r3
 2200 00a0 02D3     		bcc	.L142
1705:../FreeRTOS/tasks.c **** 					{
1706:../FreeRTOS/tasks.c **** 						xYieldPending = pdTRUE;
 2201              		.loc 1 1706 0
 2202 00a2 194B     		ldr	r3, .L149+24
 2203 00a4 0122     		movs	r2, #1
 2204 00a6 1A60     		str	r2, [r3]
 2205              	.L142:
1695:../FreeRTOS/tasks.c **** 				{
 2206              		.loc 1 1695 0
 2207 00a8 134B     		ldr	r3, .L149+8
 2208 00aa 1B68     		ldr	r3, [r3]
 2209 00ac 002B     		cmp	r3, #0
 2210 00ae CAD1     		bne	.L143
1707:../FreeRTOS/tasks.c **** 					}
1708:../FreeRTOS/tasks.c **** 					else
1709:../FreeRTOS/tasks.c **** 					{
1710:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1711:../FreeRTOS/tasks.c **** 					}
1712:../FreeRTOS/tasks.c **** 				}
1713:../FreeRTOS/tasks.c **** 
1714:../FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1715:../FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does
1716:../FreeRTOS/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1717:../FreeRTOS/tasks.c **** 				time. */
1718:../FreeRTOS/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
 2211              		.loc 1 1718 0
 2212 00b0 164B     		ldr	r3, .L149+28
 2213 00b2 1B68     		ldr	r3, [r3]
 2214 00b4 002B     		cmp	r3, #0
 2215 00b6 11D0     		beq	.L144
1719:../FreeRTOS/tasks.c **** 				{
1720:../FreeRTOS/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
 2216              		.loc 1 1720 0
 2217 00b8 0CE0     		b	.L145
 2218              	.L147:
1721:../FreeRTOS/tasks.c **** 					{
1722:../FreeRTOS/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 2219              		.loc 1 1722 0
 2220 00ba FFF7FEFF 		bl	xTaskIncrementTick
 2221 00be 0346     		mov	r3, r0
 2222 00c0 002B     		cmp	r3, #0
 2223 00c2 02D0     		beq	.L146
1723:../FreeRTOS/tasks.c **** 						{
1724:../FreeRTOS/tasks.c **** 							xYieldPending = pdTRUE;
 2224              		.loc 1 1724 0
 2225 00c4 104B     		ldr	r3, .L149+24
 2226 00c6 0122     		movs	r2, #1
 2227 00c8 1A60     		str	r2, [r3]
 2228              	.L146:
1725:../FreeRTOS/tasks.c **** 						}
1726:../FreeRTOS/tasks.c **** 						else
1727:../FreeRTOS/tasks.c **** 						{
1728:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1729:../FreeRTOS/tasks.c **** 						}
1730:../FreeRTOS/tasks.c **** 						--uxPendedTicks;
 2229              		.loc 1 1730 0
 2230 00ca 104B     		ldr	r3, .L149+28
 2231 00cc 1B68     		ldr	r3, [r3]
 2232 00ce 013B     		subs	r3, r3, #1
 2233 00d0 0E4A     		ldr	r2, .L149+28
 2234 00d2 1360     		str	r3, [r2]
 2235              	.L145:
1720:../FreeRTOS/tasks.c **** 					{
 2236              		.loc 1 1720 0
 2237 00d4 0D4B     		ldr	r3, .L149+28
 2238 00d6 1B68     		ldr	r3, [r3]
 2239 00d8 002B     		cmp	r3, #0
 2240 00da EED1     		bne	.L147
 2241              	.L144:
1731:../FreeRTOS/tasks.c **** 					}
1732:../FreeRTOS/tasks.c **** 				}
1733:../FreeRTOS/tasks.c **** 				else
1734:../FreeRTOS/tasks.c **** 				{
1735:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1736:../FreeRTOS/tasks.c **** 				}
1737:../FreeRTOS/tasks.c **** 
1738:../FreeRTOS/tasks.c **** 				if( xYieldPending == pdTRUE )
 2242              		.loc 1 1738 0
 2243 00dc 0A4B     		ldr	r3, .L149+24
 2244 00de 1B68     		ldr	r3, [r3]
 2245              	.L141:
1739:../FreeRTOS/tasks.c **** 				{
1740:../FreeRTOS/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1741:../FreeRTOS/tasks.c **** 					{
1742:../FreeRTOS/tasks.c **** 						xAlreadyYielded = pdTRUE;
1743:../FreeRTOS/tasks.c **** 					}
1744:../FreeRTOS/tasks.c **** 					#endif
1745:../FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1746:../FreeRTOS/tasks.c **** 				}
1747:../FreeRTOS/tasks.c **** 				else
1748:../FreeRTOS/tasks.c **** 				{
1749:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1750:../FreeRTOS/tasks.c **** 				}
1751:../FreeRTOS/tasks.c **** 			}
1752:../FreeRTOS/tasks.c **** 		}
1753:../FreeRTOS/tasks.c **** 		else
1754:../FreeRTOS/tasks.c **** 		{
1755:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1756:../FreeRTOS/tasks.c **** 		}
1757:../FreeRTOS/tasks.c **** 	}
1758:../FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 2246              		.loc 1 1758 0
 2247 00e0 FFF7FEFF 		bl	vPortExitCritical
1759:../FreeRTOS/tasks.c **** 
1760:../FreeRTOS/tasks.c **** 	return xAlreadyYielded;
 2248              		.loc 1 1760 0
 2249 00e4 FB68     		ldr	r3, [r7, #12]
1761:../FreeRTOS/tasks.c **** }
 2250              		.loc 1 1761 0
 2251 00e6 1846     		mov	r0, r3
 2252 00e8 1037     		adds	r7, r7, #16
 2253              		.cfi_def_cfa_offset 8
 2254 00ea BD46     		mov	sp, r7
 2255              		.cfi_def_cfa_register 13
 2256              		@ sp needed
 2257 00ec 80BD     		pop	{r7, pc}
 2258              	.L150:
 2259 00ee 00BF     		.align	2
 2260              	.L149:
 2261 00f0 00000000 		.word	uxSchedulerSuspended
 2262 00f4 00000000 		.word	uxCurrentNumberOfTasks
 2263 00f8 00000000 		.word	xPendingReadyList
 2264 00fc 00000000 		.word	uxTopReadyPriority
 2265 0100 00000000 		.word	pxReadyTasksLists
 2266 0104 00000000 		.word	pxCurrentTCB
 2267 0108 00000000 		.word	xYieldPending
 2268 010c 00000000 		.word	uxPendedTicks
 2269              		.cfi_endproc
 2270              	.LFE18:
 2272              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2273              		.align	2
 2274              		.global	xTaskGetTickCount
 2275              		.thumb
 2276              		.thumb_func
 2278              	xTaskGetTickCount:
 2279              	.LFB19:
1762:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1763:../FreeRTOS/tasks.c **** 
1764:../FreeRTOS/tasks.c **** TickType_t xTaskGetTickCount( void )
1765:../FreeRTOS/tasks.c **** {
 2280              		.loc 1 1765 0
 2281              		.cfi_startproc
 2282              		@ args = 0, pretend = 0, frame = 8
 2283              		@ frame_needed = 1, uses_anonymous_args = 0
 2284              		@ link register save eliminated.
 2285 0000 80B4     		push	{r7}
 2286              		.cfi_def_cfa_offset 4
 2287              		.cfi_offset 7, -4
 2288 0002 83B0     		sub	sp, sp, #12
 2289              		.cfi_def_cfa_offset 16
 2290 0004 00AF     		add	r7, sp, #0
 2291              		.cfi_def_cfa_register 7
1766:../FreeRTOS/tasks.c **** TickType_t xTicks;
1767:../FreeRTOS/tasks.c **** 
1768:../FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1769:../FreeRTOS/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
1770:../FreeRTOS/tasks.c **** 	{
1771:../FreeRTOS/tasks.c **** 		xTicks = xTickCount;
 2292              		.loc 1 1771 0
 2293 0006 054B     		ldr	r3, .L153
 2294 0008 1B68     		ldr	r3, [r3]
 2295 000a 7B60     		str	r3, [r7, #4]
1772:../FreeRTOS/tasks.c **** 	}
1773:../FreeRTOS/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
1774:../FreeRTOS/tasks.c **** 
1775:../FreeRTOS/tasks.c **** 	return xTicks;
 2296              		.loc 1 1775 0
 2297 000c 7B68     		ldr	r3, [r7, #4]
1776:../FreeRTOS/tasks.c **** }
 2298              		.loc 1 1776 0
 2299 000e 1846     		mov	r0, r3
 2300 0010 0C37     		adds	r7, r7, #12
 2301              		.cfi_def_cfa_offset 4
 2302 0012 BD46     		mov	sp, r7
 2303              		.cfi_def_cfa_register 13
 2304              		@ sp needed
 2305 0014 5DF8047B 		ldr	r7, [sp], #4
 2306              		.cfi_restore 7
 2307              		.cfi_def_cfa_offset 0
 2308 0018 7047     		bx	lr
 2309              	.L154:
 2310 001a 00BF     		.align	2
 2311              	.L153:
 2312 001c 00000000 		.word	xTickCount
 2313              		.cfi_endproc
 2314              	.LFE19:
 2316              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2317              		.align	2
 2318              		.global	xTaskGetTickCountFromISR
 2319              		.thumb
 2320              		.thumb_func
 2322              	xTaskGetTickCountFromISR:
 2323              	.LFB20:
1777:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1778:../FreeRTOS/tasks.c **** 
1779:../FreeRTOS/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1780:../FreeRTOS/tasks.c **** {
 2324              		.loc 1 1780 0
 2325              		.cfi_startproc
 2326              		@ args = 0, pretend = 0, frame = 8
 2327              		@ frame_needed = 1, uses_anonymous_args = 0
 2328 0000 80B5     		push	{r7, lr}
 2329              		.cfi_def_cfa_offset 8
 2330              		.cfi_offset 7, -8
 2331              		.cfi_offset 14, -4
 2332 0002 82B0     		sub	sp, sp, #8
 2333              		.cfi_def_cfa_offset 16
 2334 0004 00AF     		add	r7, sp, #0
 2335              		.cfi_def_cfa_register 7
1781:../FreeRTOS/tasks.c **** TickType_t xReturn;
1782:../FreeRTOS/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1783:../FreeRTOS/tasks.c **** 
1784:../FreeRTOS/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1785:../FreeRTOS/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1786:../FreeRTOS/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
1787:../FreeRTOS/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1788:../FreeRTOS/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1789:../FreeRTOS/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1790:../FreeRTOS/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1791:../FreeRTOS/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1792:../FreeRTOS/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1793:../FreeRTOS/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1794:../FreeRTOS/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1795:../FreeRTOS/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1796:../FreeRTOS/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1797:../FreeRTOS/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1798:../FreeRTOS/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2336              		.loc 1 1798 0
 2337 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
1799:../FreeRTOS/tasks.c **** 
1800:../FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2338              		.loc 1 1800 0
 2339 000a 0023     		movs	r3, #0
 2340 000c 7B60     		str	r3, [r7, #4]
1801:../FreeRTOS/tasks.c **** 	{
1802:../FreeRTOS/tasks.c **** 		xReturn = xTickCount;
 2341              		.loc 1 1802 0
 2342 000e 044B     		ldr	r3, .L157
 2343 0010 1B68     		ldr	r3, [r3]
 2344 0012 3B60     		str	r3, [r7]
1803:../FreeRTOS/tasks.c **** 	}
1804:../FreeRTOS/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1805:../FreeRTOS/tasks.c **** 
1806:../FreeRTOS/tasks.c **** 	return xReturn;
 2345              		.loc 1 1806 0
 2346 0014 3B68     		ldr	r3, [r7]
1807:../FreeRTOS/tasks.c **** }
 2347              		.loc 1 1807 0
 2348 0016 1846     		mov	r0, r3
 2349 0018 0837     		adds	r7, r7, #8
 2350              		.cfi_def_cfa_offset 8
 2351 001a BD46     		mov	sp, r7
 2352              		.cfi_def_cfa_register 13
 2353              		@ sp needed
 2354 001c 80BD     		pop	{r7, pc}
 2355              	.L158:
 2356 001e 00BF     		.align	2
 2357              	.L157:
 2358 0020 00000000 		.word	xTickCount
 2359              		.cfi_endproc
 2360              	.LFE20:
 2362              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2363              		.align	2
 2364              		.global	uxTaskGetNumberOfTasks
 2365              		.thumb
 2366              		.thumb_func
 2368              	uxTaskGetNumberOfTasks:
 2369              	.LFB21:
1808:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1809:../FreeRTOS/tasks.c **** 
1810:../FreeRTOS/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1811:../FreeRTOS/tasks.c **** {
 2370              		.loc 1 1811 0
 2371              		.cfi_startproc
 2372              		@ args = 0, pretend = 0, frame = 0
 2373              		@ frame_needed = 1, uses_anonymous_args = 0
 2374              		@ link register save eliminated.
 2375 0000 80B4     		push	{r7}
 2376              		.cfi_def_cfa_offset 4
 2377              		.cfi_offset 7, -4
 2378 0002 00AF     		add	r7, sp, #0
 2379              		.cfi_def_cfa_register 7
1812:../FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
1813:../FreeRTOS/tasks.c **** 	BaseType_t. */
1814:../FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 2380              		.loc 1 1814 0
 2381 0004 034B     		ldr	r3, .L161
 2382 0006 1B68     		ldr	r3, [r3]
1815:../FreeRTOS/tasks.c **** }
 2383              		.loc 1 1815 0
 2384 0008 1846     		mov	r0, r3
 2385 000a BD46     		mov	sp, r7
 2386              		.cfi_def_cfa_register 13
 2387              		@ sp needed
 2388 000c 5DF8047B 		ldr	r7, [sp], #4
 2389              		.cfi_restore 7
 2390              		.cfi_def_cfa_offset 0
 2391 0010 7047     		bx	lr
 2392              	.L162:
 2393 0012 00BF     		.align	2
 2394              	.L161:
 2395 0014 00000000 		.word	uxCurrentNumberOfTasks
 2396              		.cfi_endproc
 2397              	.LFE21:
 2399              		.section	.text.pcTaskGetTaskName,"ax",%progbits
 2400              		.align	2
 2401              		.global	pcTaskGetTaskName
 2402              		.thumb
 2403              		.thumb_func
 2405              	pcTaskGetTaskName:
 2406              	.LFB22:
1816:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1817:../FreeRTOS/tasks.c **** 
1818:../FreeRTOS/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1819:../FreeRTOS/tasks.c **** 
1820:../FreeRTOS/tasks.c **** 	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allow
1821:../FreeRTOS/tasks.c **** 	{
 2407              		.loc 1 1821 0
 2408              		.cfi_startproc
 2409              		@ args = 0, pretend = 0, frame = 16
 2410              		@ frame_needed = 1, uses_anonymous_args = 0
 2411              		@ link register save eliminated.
 2412 0000 80B4     		push	{r7}
 2413              		.cfi_def_cfa_offset 4
 2414              		.cfi_offset 7, -4
 2415 0002 85B0     		sub	sp, sp, #20
 2416              		.cfi_def_cfa_offset 24
 2417 0004 00AF     		add	r7, sp, #0
 2418              		.cfi_def_cfa_register 7
 2419 0006 7860     		str	r0, [r7, #4]
1822:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
1823:../FreeRTOS/tasks.c **** 
1824:../FreeRTOS/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1825:../FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2420              		.loc 1 1825 0
 2421 0008 7B68     		ldr	r3, [r7, #4]
 2422 000a 002B     		cmp	r3, #0
 2423 000c 02D1     		bne	.L164
 2424              		.loc 1 1825 0 is_stmt 0 discriminator 1
 2425 000e 0D4B     		ldr	r3, .L169
 2426 0010 1B68     		ldr	r3, [r3]
 2427 0012 00E0     		b	.L165
 2428              	.L164:
 2429              		.loc 1 1825 0 discriminator 2
 2430 0014 7B68     		ldr	r3, [r7, #4]
 2431              	.L165:
 2432              		.loc 1 1825 0 discriminator 4
 2433 0016 FB60     		str	r3, [r7, #12]
1826:../FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
 2434              		.loc 1 1826 0 is_stmt 1 discriminator 4
 2435 0018 FB68     		ldr	r3, [r7, #12]
 2436 001a 002B     		cmp	r3, #0
 2437 001c 09D1     		bne	.L166
 2438              	.LBB145:
 2439              	.LBB146:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 2440              		.loc 2 215 0 discriminator 1
 2441              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2442 001e 4FF00703 			mov r3, #7												
 2443 0022 83F31188 		msr basepri, r3											
 2444 0026 BFF36F8F 		isb														
 2445 002a BFF34F8F 		dsb														
 2446              	
 2447              	@ 0 "" 2
 2448              		.thumb
 2449 002e BB60     		str	r3, [r7, #8]
 2450              	.L167:
 2451              	.LBE146:
 2452              	.LBE145:
 2453              		.loc 1 1826 0 discriminator 1
 2454 0030 FEE7     		b	.L167
 2455              	.L166:
1827:../FreeRTOS/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
 2456              		.loc 1 1827 0
 2457 0032 FB68     		ldr	r3, [r7, #12]
 2458 0034 3433     		adds	r3, r3, #52
1828:../FreeRTOS/tasks.c **** 	}
 2459              		.loc 1 1828 0
 2460 0036 1846     		mov	r0, r3
 2461 0038 1437     		adds	r7, r7, #20
 2462              		.cfi_def_cfa_offset 4
 2463 003a BD46     		mov	sp, r7
 2464              		.cfi_def_cfa_register 13
 2465              		@ sp needed
 2466 003c 5DF8047B 		ldr	r7, [sp], #4
 2467              		.cfi_restore 7
 2468              		.cfi_def_cfa_offset 0
 2469 0040 7047     		bx	lr
 2470              	.L170:
 2471 0042 00BF     		.align	2
 2472              	.L169:
 2473 0044 00000000 		.word	pxCurrentTCB
 2474              		.cfi_endproc
 2475              	.LFE22:
 2477              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2478              		.align	2
 2479              		.global	xTaskIncrementTick
 2480              		.thumb
 2481              		.thumb_func
 2483              	xTaskIncrementTick:
 2484              	.LFB23:
1829:../FreeRTOS/tasks.c **** 
1830:../FreeRTOS/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1831:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1832:../FreeRTOS/tasks.c **** 
1833:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1834:../FreeRTOS/tasks.c **** 
1835:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
1836:../FreeRTOS/tasks.c **** 	{
1837:../FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1838:../FreeRTOS/tasks.c **** 
1839:../FreeRTOS/tasks.c **** 		vTaskSuspendAll();
1840:../FreeRTOS/tasks.c **** 		{
1841:../FreeRTOS/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1842:../FreeRTOS/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1843:../FreeRTOS/tasks.c **** 			{
1844:../FreeRTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1845:../FreeRTOS/tasks.c **** 				task in the Ready state. */
1846:../FreeRTOS/tasks.c **** 				do
1847:../FreeRTOS/tasks.c **** 				{
1848:../FreeRTOS/tasks.c **** 					uxQueue--;
1849:../FreeRTOS/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1850:../FreeRTOS/tasks.c **** 
1851:../FreeRTOS/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
1852:../FreeRTOS/tasks.c **** 
1853:../FreeRTOS/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1854:../FreeRTOS/tasks.c **** 				task in the Blocked state. */
1855:../FreeRTOS/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayed
1856:../FreeRTOS/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflo
1857:../FreeRTOS/tasks.c **** 
1858:../FreeRTOS/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1859:../FreeRTOS/tasks.c **** 				{
1860:../FreeRTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1861:../FreeRTOS/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1862:../FreeRTOS/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1863:../FreeRTOS/tasks.c **** 				}
1864:../FreeRTOS/tasks.c **** 				#endif
1865:../FreeRTOS/tasks.c **** 
1866:../FreeRTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1867:../FreeRTOS/tasks.c **** 				{
1868:../FreeRTOS/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1869:../FreeRTOS/tasks.c **** 					each task in the Suspended state. */
1870:../FreeRTOS/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1871:../FreeRTOS/tasks.c **** 				}
1872:../FreeRTOS/tasks.c **** 				#endif
1873:../FreeRTOS/tasks.c **** 
1874:../FreeRTOS/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1875:../FreeRTOS/tasks.c **** 				{
1876:../FreeRTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
1877:../FreeRTOS/tasks.c **** 					{
1878:../FreeRTOS/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1879:../FreeRTOS/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1880:../FreeRTOS/tasks.c **** 						#else
1881:../FreeRTOS/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1882:../FreeRTOS/tasks.c **** 						#endif
1883:../FreeRTOS/tasks.c **** 					}
1884:../FreeRTOS/tasks.c **** 				}
1885:../FreeRTOS/tasks.c **** 				#else
1886:../FreeRTOS/tasks.c **** 				{
1887:../FreeRTOS/tasks.c **** 					if( pulTotalRunTime != NULL )
1888:../FreeRTOS/tasks.c **** 					{
1889:../FreeRTOS/tasks.c **** 						*pulTotalRunTime = 0;
1890:../FreeRTOS/tasks.c **** 					}
1891:../FreeRTOS/tasks.c **** 				}
1892:../FreeRTOS/tasks.c **** 				#endif
1893:../FreeRTOS/tasks.c **** 			}
1894:../FreeRTOS/tasks.c **** 			else
1895:../FreeRTOS/tasks.c **** 			{
1896:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1897:../FreeRTOS/tasks.c **** 			}
1898:../FreeRTOS/tasks.c **** 		}
1899:../FreeRTOS/tasks.c **** 		( void ) xTaskResumeAll();
1900:../FreeRTOS/tasks.c **** 
1901:../FreeRTOS/tasks.c **** 		return uxTask;
1902:../FreeRTOS/tasks.c **** 	}
1903:../FreeRTOS/tasks.c **** 
1904:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1905:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1906:../FreeRTOS/tasks.c **** 
1907:../FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1908:../FreeRTOS/tasks.c **** 
1909:../FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
1910:../FreeRTOS/tasks.c **** 	{
1911:../FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1912:../FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1913:../FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1914:../FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
1915:../FreeRTOS/tasks.c **** 	}
1916:../FreeRTOS/tasks.c **** 
1917:../FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1918:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1919:../FreeRTOS/tasks.c **** 
1920:../FreeRTOS/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1921:../FreeRTOS/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1922:../FreeRTOS/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1923:../FreeRTOS/tasks.c **** 1. */
1924:../FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1925:../FreeRTOS/tasks.c **** 
1926:../FreeRTOS/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
1927:../FreeRTOS/tasks.c **** 	{
1928:../FreeRTOS/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1929:../FreeRTOS/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1930:../FreeRTOS/tasks.c **** 		each stepped tick. */
1931:../FreeRTOS/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1932:../FreeRTOS/tasks.c **** 		xTickCount += xTicksToJump;
1933:../FreeRTOS/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1934:../FreeRTOS/tasks.c **** 	}
1935:../FreeRTOS/tasks.c **** 
1936:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1937:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1938:../FreeRTOS/tasks.c **** 
1939:../FreeRTOS/tasks.c **** BaseType_t xTaskIncrementTick( void )
1940:../FreeRTOS/tasks.c **** {
 2485              		.loc 1 1940 0
 2486              		.cfi_startproc
 2487              		@ args = 0, pretend = 0, frame = 24
 2488              		@ frame_needed = 1, uses_anonymous_args = 0
 2489 0000 80B5     		push	{r7, lr}
 2490              		.cfi_def_cfa_offset 8
 2491              		.cfi_offset 7, -8
 2492              		.cfi_offset 14, -4
 2493 0002 86B0     		sub	sp, sp, #24
 2494              		.cfi_def_cfa_offset 32
 2495 0004 00AF     		add	r7, sp, #0
 2496              		.cfi_def_cfa_register 7
1941:../FreeRTOS/tasks.c **** TCB_t * pxTCB;
1942:../FreeRTOS/tasks.c **** TickType_t xItemValue;
1943:../FreeRTOS/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2497              		.loc 1 1943 0
 2498 0006 0023     		movs	r3, #0
 2499 0008 7B61     		str	r3, [r7, #20]
1944:../FreeRTOS/tasks.c **** 
1945:../FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1946:../FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1947:../FreeRTOS/tasks.c **** 	tasks to be unblocked. */
1948:../FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1949:../FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2500              		.loc 1 1949 0
 2501 000a 474B     		ldr	r3, .L185
 2502 000c 1B68     		ldr	r3, [r3]
 2503 000e 002B     		cmp	r3, #0
 2504 0010 7DD1     		bne	.L172
1950:../FreeRTOS/tasks.c **** 	{
1951:../FreeRTOS/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1952:../FreeRTOS/tasks.c **** 		delayed lists if it wraps to 0. */
1953:../FreeRTOS/tasks.c **** 		++xTickCount;
 2505              		.loc 1 1953 0
 2506 0012 464B     		ldr	r3, .L185+4
 2507 0014 1B68     		ldr	r3, [r3]
 2508 0016 0133     		adds	r3, r3, #1
 2509 0018 444A     		ldr	r2, .L185+4
 2510 001a 1360     		str	r3, [r2]
 2511              	.LBB147:
1954:../FreeRTOS/tasks.c **** 
1955:../FreeRTOS/tasks.c **** 		{
1956:../FreeRTOS/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1957:../FreeRTOS/tasks.c **** 			block. */
1958:../FreeRTOS/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 2512              		.loc 1 1958 0
 2513 001c 434B     		ldr	r3, .L185+4
 2514 001e 1B68     		ldr	r3, [r3]
 2515 0020 3B61     		str	r3, [r7, #16]
1959:../FreeRTOS/tasks.c **** 
1960:../FreeRTOS/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
 2516              		.loc 1 1960 0
 2517 0022 3B69     		ldr	r3, [r7, #16]
 2518 0024 002B     		cmp	r3, #0
 2519 0026 1FD1     		bne	.L173
 2520              	.LBB148:
1961:../FreeRTOS/tasks.c **** 			{
1962:../FreeRTOS/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 2521              		.loc 1 1962 0
 2522 0028 414B     		ldr	r3, .L185+8
 2523 002a 1B68     		ldr	r3, [r3]
 2524 002c 1B68     		ldr	r3, [r3]
 2525 002e 002B     		cmp	r3, #0
 2526 0030 09D0     		beq	.L174
 2527              	.LBB149:
 2528              	.LBB150:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 2529              		.loc 2 215 0 discriminator 1
 2530              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2531 0032 4FF00703 			mov r3, #7												
 2532 0036 83F31188 		msr basepri, r3											
 2533 003a BFF36F8F 		isb														
 2534 003e BFF34F8F 		dsb														
 2535              	
 2536              	@ 0 "" 2
 2537              		.thumb
 2538 0042 3B60     		str	r3, [r7]
 2539              	.L175:
 2540              	.LBE150:
 2541              	.LBE149:
 2542              		.loc 1 1962 0 discriminator 1
 2543 0044 FEE7     		b	.L175
 2544              	.L174:
 2545              		.loc 1 1962 0 is_stmt 0 discriminator 2
 2546 0046 3A4B     		ldr	r3, .L185+8
 2547 0048 1B68     		ldr	r3, [r3]
 2548 004a FB60     		str	r3, [r7, #12]
 2549 004c 394B     		ldr	r3, .L185+12
 2550 004e 1B68     		ldr	r3, [r3]
 2551 0050 374A     		ldr	r2, .L185+8
 2552 0052 1360     		str	r3, [r2]
 2553 0054 374A     		ldr	r2, .L185+12
 2554 0056 FB68     		ldr	r3, [r7, #12]
 2555 0058 1360     		str	r3, [r2]
 2556 005a 374B     		ldr	r3, .L185+16
 2557 005c 1B68     		ldr	r3, [r3]
 2558 005e 0133     		adds	r3, r3, #1
 2559 0060 354A     		ldr	r2, .L185+16
 2560 0062 1360     		str	r3, [r2]
 2561 0064 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2562              	.L173:
 2563              	.LBE148:
1963:../FreeRTOS/tasks.c **** 			}
1964:../FreeRTOS/tasks.c **** 			else
1965:../FreeRTOS/tasks.c **** 			{
1966:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1967:../FreeRTOS/tasks.c **** 			}
1968:../FreeRTOS/tasks.c **** 
1969:../FreeRTOS/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in
1970:../FreeRTOS/tasks.c **** 			the	queue in the order of their wake time - meaning once one task
1971:../FreeRTOS/tasks.c **** 			has been found whose block time has not expired there is no need to
1972:../FreeRTOS/tasks.c **** 			look any further down the list. */
1973:../FreeRTOS/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 2564              		.loc 1 1973 0 is_stmt 1
 2565 0068 344B     		ldr	r3, .L185+20
 2566 006a 1B68     		ldr	r3, [r3]
 2567 006c 3A69     		ldr	r2, [r7, #16]
 2568 006e 9A42     		cmp	r2, r3
 2569 0070 46D3     		bcc	.L176
 2570              	.L182:
1974:../FreeRTOS/tasks.c **** 			{
1975:../FreeRTOS/tasks.c **** 				for( ;; )
1976:../FreeRTOS/tasks.c **** 				{
1977:../FreeRTOS/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2571              		.loc 1 1977 0
 2572 0072 2F4B     		ldr	r3, .L185+8
 2573 0074 1B68     		ldr	r3, [r3]
 2574 0076 1B68     		ldr	r3, [r3]
 2575 0078 002B     		cmp	r3, #0
 2576 007a 01D1     		bne	.L177
 2577              		.loc 1 1977 0 is_stmt 0 discriminator 1
 2578 007c 0123     		movs	r3, #1
 2579 007e 00E0     		b	.L178
 2580              	.L177:
 2581              		.loc 1 1977 0 discriminator 2
 2582 0080 0023     		movs	r3, #0
 2583              	.L178:
 2584              		.loc 1 1977 0 discriminator 4
 2585 0082 002B     		cmp	r3, #0
 2586 0084 04D0     		beq	.L179
1978:../FreeRTOS/tasks.c **** 					{
1979:../FreeRTOS/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime
1980:../FreeRTOS/tasks.c **** 						to the maximum possible value so it is extremely
1981:../FreeRTOS/tasks.c **** 						unlikely that the
1982:../FreeRTOS/tasks.c **** 						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1983:../FreeRTOS/tasks.c **** 						next time through. */
1984:../FreeRTOS/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 2587              		.loc 1 1984 0 is_stmt 1
 2588 0086 2D4B     		ldr	r3, .L185+20
 2589 0088 4FF0FF32 		mov	r2, #-1
 2590 008c 1A60     		str	r2, [r3]
1985:../FreeRTOS/tasks.c **** 						break;
 2591              		.loc 1 1985 0
 2592 008e 37E0     		b	.L176
 2593              	.L179:
1986:../FreeRTOS/tasks.c **** 					}
1987:../FreeRTOS/tasks.c **** 					else
1988:../FreeRTOS/tasks.c **** 					{
1989:../FreeRTOS/tasks.c **** 						/* The delayed list is not empty, get the value of the
1990:../FreeRTOS/tasks.c **** 						item at the head of the delayed list.  This is the time
1991:../FreeRTOS/tasks.c **** 						at which the task at the head of the delayed list must
1992:../FreeRTOS/tasks.c **** 						be removed from the Blocked state. */
1993:../FreeRTOS/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2594              		.loc 1 1993 0
 2595 0090 274B     		ldr	r3, .L185+8
 2596 0092 1B68     		ldr	r3, [r3]
 2597 0094 DB68     		ldr	r3, [r3, #12]
 2598 0096 DB68     		ldr	r3, [r3, #12]
 2599 0098 BB60     		str	r3, [r7, #8]
1994:../FreeRTOS/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2600              		.loc 1 1994 0
 2601 009a BB68     		ldr	r3, [r7, #8]
 2602 009c 5B68     		ldr	r3, [r3, #4]
 2603 009e 7B60     		str	r3, [r7, #4]
1995:../FreeRTOS/tasks.c **** 
1996:../FreeRTOS/tasks.c **** 						if( xConstTickCount < xItemValue )
 2604              		.loc 1 1996 0
 2605 00a0 3A69     		ldr	r2, [r7, #16]
 2606 00a2 7B68     		ldr	r3, [r7, #4]
 2607 00a4 9A42     		cmp	r2, r3
 2608 00a6 03D2     		bcs	.L180
1997:../FreeRTOS/tasks.c **** 						{
1998:../FreeRTOS/tasks.c **** 							/* It is not time to unblock this item yet, but the
1999:../FreeRTOS/tasks.c **** 							item value is the time at which the task at the head
2000:../FreeRTOS/tasks.c **** 							of the blocked list must be removed from the Blocked
2001:../FreeRTOS/tasks.c **** 							state -	so record the item value in
2002:../FreeRTOS/tasks.c **** 							xNextTaskUnblockTime. */
2003:../FreeRTOS/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 2609              		.loc 1 2003 0
 2610 00a8 244A     		ldr	r2, .L185+20
 2611 00aa 7B68     		ldr	r3, [r7, #4]
 2612 00ac 1360     		str	r3, [r2]
2004:../FreeRTOS/tasks.c **** 							break;
 2613              		.loc 1 2004 0
 2614 00ae 27E0     		b	.L176
 2615              	.L180:
2005:../FreeRTOS/tasks.c **** 						}
2006:../FreeRTOS/tasks.c **** 						else
2007:../FreeRTOS/tasks.c **** 						{
2008:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2009:../FreeRTOS/tasks.c **** 						}
2010:../FreeRTOS/tasks.c **** 
2011:../FreeRTOS/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
2012:../FreeRTOS/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2616              		.loc 1 2012 0
 2617 00b0 BB68     		ldr	r3, [r7, #8]
 2618 00b2 0433     		adds	r3, r3, #4
 2619 00b4 1846     		mov	r0, r3
 2620 00b6 FFF7FEFF 		bl	uxListRemove
2013:../FreeRTOS/tasks.c **** 
2014:../FreeRTOS/tasks.c **** 						/* Is the task waiting on an event also?  If so remove
2015:../FreeRTOS/tasks.c **** 						it from the event list. */
2016:../FreeRTOS/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2621              		.loc 1 2016 0
 2622 00ba BB68     		ldr	r3, [r7, #8]
 2623 00bc 9B6A     		ldr	r3, [r3, #40]
 2624 00be 002B     		cmp	r3, #0
 2625 00c0 04D0     		beq	.L181
2017:../FreeRTOS/tasks.c **** 						{
2018:../FreeRTOS/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2626              		.loc 1 2018 0
 2627 00c2 BB68     		ldr	r3, [r7, #8]
 2628 00c4 1833     		adds	r3, r3, #24
 2629 00c6 1846     		mov	r0, r3
 2630 00c8 FFF7FEFF 		bl	uxListRemove
 2631              	.L181:
2019:../FreeRTOS/tasks.c **** 						}
2020:../FreeRTOS/tasks.c **** 						else
2021:../FreeRTOS/tasks.c **** 						{
2022:../FreeRTOS/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2023:../FreeRTOS/tasks.c **** 						}
2024:../FreeRTOS/tasks.c **** 
2025:../FreeRTOS/tasks.c **** 						/* Place the unblocked task into the appropriate ready
2026:../FreeRTOS/tasks.c **** 						list. */
2027:../FreeRTOS/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 2632              		.loc 1 2027 0
 2633 00cc BB68     		ldr	r3, [r7, #8]
 2634 00ce DB6A     		ldr	r3, [r3, #44]
 2635 00d0 1A46     		mov	r2, r3
 2636 00d2 0123     		movs	r3, #1
 2637 00d4 03FA02F2 		lsl	r2, r3, r2
 2638 00d8 194B     		ldr	r3, .L185+24
 2639 00da 1B68     		ldr	r3, [r3]
 2640 00dc 1343     		orrs	r3, r3, r2
 2641 00de 184A     		ldr	r2, .L185+24
 2642 00e0 1360     		str	r3, [r2]
 2643 00e2 BB68     		ldr	r3, [r7, #8]
 2644 00e4 DA6A     		ldr	r2, [r3, #44]
 2645 00e6 1346     		mov	r3, r2
 2646 00e8 9B00     		lsls	r3, r3, #2
 2647 00ea 1344     		add	r3, r3, r2
 2648 00ec 9B00     		lsls	r3, r3, #2
 2649 00ee 154A     		ldr	r2, .L185+28
 2650 00f0 1A44     		add	r2, r2, r3
 2651 00f2 BB68     		ldr	r3, [r7, #8]
 2652 00f4 0433     		adds	r3, r3, #4
 2653 00f6 1046     		mov	r0, r2
 2654 00f8 1946     		mov	r1, r3
 2655 00fa FFF7FEFF 		bl	vListInsertEnd
2028:../FreeRTOS/tasks.c **** 
2029:../FreeRTOS/tasks.c **** 						/* A task being unblocked cannot cause an immediate
2030:../FreeRTOS/tasks.c **** 						context switch if preemption is turned off. */
2031:../FreeRTOS/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
2032:../FreeRTOS/tasks.c **** 						{
2033:../FreeRTOS/tasks.c **** 							/* Preemption is on, but a context switch should
2034:../FreeRTOS/tasks.c **** 							only be performed if the unblocked task has a
2035:../FreeRTOS/tasks.c **** 							priority that is equal to or higher than the
2036:../FreeRTOS/tasks.c **** 							currently executing task. */
2037:../FreeRTOS/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2038:../FreeRTOS/tasks.c **** 							{
2039:../FreeRTOS/tasks.c **** 								xSwitchRequired = pdTRUE;
2040:../FreeRTOS/tasks.c **** 							}
2041:../FreeRTOS/tasks.c **** 							else
2042:../FreeRTOS/tasks.c **** 							{
2043:../FreeRTOS/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2044:../FreeRTOS/tasks.c **** 							}
2045:../FreeRTOS/tasks.c **** 						}
2046:../FreeRTOS/tasks.c **** 						#endif /* configUSE_PREEMPTION */
2047:../FreeRTOS/tasks.c **** 					}
2048:../FreeRTOS/tasks.c **** 				}
 2656              		.loc 1 2048 0
 2657 00fe B8E7     		b	.L182
 2658              	.L176:
 2659              	.LBE147:
2049:../FreeRTOS/tasks.c **** 			}
2050:../FreeRTOS/tasks.c **** 		}
2051:../FreeRTOS/tasks.c **** 
2052:../FreeRTOS/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2053:../FreeRTOS/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2054:../FreeRTOS/tasks.c **** 		writer has not explicitly turned time slicing off. */
2055:../FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2056:../FreeRTOS/tasks.c **** 		{
2057:../FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2058:../FreeRTOS/tasks.c **** 			{
2059:../FreeRTOS/tasks.c **** 				xSwitchRequired = pdTRUE;
2060:../FreeRTOS/tasks.c **** 			}
2061:../FreeRTOS/tasks.c **** 			else
2062:../FreeRTOS/tasks.c **** 			{
2063:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2064:../FreeRTOS/tasks.c **** 			}
2065:../FreeRTOS/tasks.c **** 		}
2066:../FreeRTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2067:../FreeRTOS/tasks.c **** 
2068:../FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2069:../FreeRTOS/tasks.c **** 		{
2070:../FreeRTOS/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2071:../FreeRTOS/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2072:../FreeRTOS/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
 2660              		.loc 1 2072 0
 2661 0100 114B     		ldr	r3, .L185+32
 2662 0102 1B68     		ldr	r3, [r3]
 2663 0104 002B     		cmp	r3, #0
 2664 0106 09D1     		bne	.L183
2073:../FreeRTOS/tasks.c **** 			{
2074:../FreeRTOS/tasks.c **** 				vApplicationTickHook();
 2665              		.loc 1 2074 0
 2666 0108 FFF7FEFF 		bl	vApplicationTickHook
 2667 010c 06E0     		b	.L183
 2668              	.L172:
2075:../FreeRTOS/tasks.c **** 			}
2076:../FreeRTOS/tasks.c **** 			else
2077:../FreeRTOS/tasks.c **** 			{
2078:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2079:../FreeRTOS/tasks.c **** 			}
2080:../FreeRTOS/tasks.c **** 		}
2081:../FreeRTOS/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2082:../FreeRTOS/tasks.c **** 	}
2083:../FreeRTOS/tasks.c **** 	else
2084:../FreeRTOS/tasks.c **** 	{
2085:../FreeRTOS/tasks.c **** 		++uxPendedTicks;
 2669              		.loc 1 2085 0
 2670 010e 0E4B     		ldr	r3, .L185+32
 2671 0110 1B68     		ldr	r3, [r3]
 2672 0112 0133     		adds	r3, r3, #1
 2673 0114 0C4A     		ldr	r2, .L185+32
 2674 0116 1360     		str	r3, [r2]
2086:../FreeRTOS/tasks.c **** 
2087:../FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2088:../FreeRTOS/tasks.c **** 		scheduler is locked. */
2089:../FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2090:../FreeRTOS/tasks.c **** 		{
2091:../FreeRTOS/tasks.c **** 			vApplicationTickHook();
 2675              		.loc 1 2091 0
 2676 0118 FFF7FEFF 		bl	vApplicationTickHook
 2677              	.L183:
2092:../FreeRTOS/tasks.c **** 		}
2093:../FreeRTOS/tasks.c **** 		#endif
2094:../FreeRTOS/tasks.c **** 	}
2095:../FreeRTOS/tasks.c **** 
2096:../FreeRTOS/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2097:../FreeRTOS/tasks.c **** 	{
2098:../FreeRTOS/tasks.c **** 		if( xYieldPending != pdFALSE )
2099:../FreeRTOS/tasks.c **** 		{
2100:../FreeRTOS/tasks.c **** 			xSwitchRequired = pdTRUE;
2101:../FreeRTOS/tasks.c **** 		}
2102:../FreeRTOS/tasks.c **** 		else
2103:../FreeRTOS/tasks.c **** 		{
2104:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2105:../FreeRTOS/tasks.c **** 		}
2106:../FreeRTOS/tasks.c **** 	}
2107:../FreeRTOS/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2108:../FreeRTOS/tasks.c **** 
2109:../FreeRTOS/tasks.c **** 	return xSwitchRequired;
 2678              		.loc 1 2109 0
 2679 011c 7B69     		ldr	r3, [r7, #20]
2110:../FreeRTOS/tasks.c **** }
 2680              		.loc 1 2110 0
 2681 011e 1846     		mov	r0, r3
 2682 0120 1837     		adds	r7, r7, #24
 2683              		.cfi_def_cfa_offset 8
 2684 0122 BD46     		mov	sp, r7
 2685              		.cfi_def_cfa_register 13
 2686              		@ sp needed
 2687 0124 80BD     		pop	{r7, pc}
 2688              	.L186:
 2689 0126 00BF     		.align	2
 2690              	.L185:
 2691 0128 00000000 		.word	uxSchedulerSuspended
 2692 012c 00000000 		.word	xTickCount
 2693 0130 00000000 		.word	pxDelayedTaskList
 2694 0134 00000000 		.word	pxOverflowDelayedTaskList
 2695 0138 00000000 		.word	xNumOfOverflows
 2696 013c 00000000 		.word	xNextTaskUnblockTime
 2697 0140 00000000 		.word	uxTopReadyPriority
 2698 0144 00000000 		.word	pxReadyTasksLists
 2699 0148 00000000 		.word	uxPendedTicks
 2700              		.cfi_endproc
 2701              	.LFE23:
 2703              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2704              		.align	2
 2705              		.global	vTaskSwitchContext
 2706              		.thumb
 2707              		.thumb_func
 2709              	vTaskSwitchContext:
 2710              	.LFB24:
2111:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2112:../FreeRTOS/tasks.c **** 
2113:../FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2114:../FreeRTOS/tasks.c **** 
2115:../FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2116:../FreeRTOS/tasks.c **** 	{
2117:../FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2118:../FreeRTOS/tasks.c **** 
2119:../FreeRTOS/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2120:../FreeRTOS/tasks.c **** 		getting set. */
2121:../FreeRTOS/tasks.c **** 		if( xTask == NULL )
2122:../FreeRTOS/tasks.c **** 		{
2123:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2124:../FreeRTOS/tasks.c **** 		}
2125:../FreeRTOS/tasks.c **** 		else
2126:../FreeRTOS/tasks.c **** 		{
2127:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2128:../FreeRTOS/tasks.c **** 		}
2129:../FreeRTOS/tasks.c **** 
2130:../FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2131:../FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2132:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
2133:../FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2134:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
2135:../FreeRTOS/tasks.c **** 	}
2136:../FreeRTOS/tasks.c **** 
2137:../FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2138:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2139:../FreeRTOS/tasks.c **** 
2140:../FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2141:../FreeRTOS/tasks.c **** 
2142:../FreeRTOS/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2143:../FreeRTOS/tasks.c **** 	{
2144:../FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2145:../FreeRTOS/tasks.c **** 	TaskHookFunction_t xReturn;
2146:../FreeRTOS/tasks.c **** 
2147:../FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2148:../FreeRTOS/tasks.c **** 		if( xTask == NULL )
2149:../FreeRTOS/tasks.c **** 		{
2150:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2151:../FreeRTOS/tasks.c **** 		}
2152:../FreeRTOS/tasks.c **** 		else
2153:../FreeRTOS/tasks.c **** 		{
2154:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2155:../FreeRTOS/tasks.c **** 		}
2156:../FreeRTOS/tasks.c **** 
2157:../FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2158:../FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
2159:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
2160:../FreeRTOS/tasks.c **** 		{
2161:../FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2162:../FreeRTOS/tasks.c **** 		}
2163:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
2164:../FreeRTOS/tasks.c **** 
2165:../FreeRTOS/tasks.c **** 		return xReturn;
2166:../FreeRTOS/tasks.c **** 	}
2167:../FreeRTOS/tasks.c **** 
2168:../FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2169:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2170:../FreeRTOS/tasks.c **** 
2171:../FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2172:../FreeRTOS/tasks.c **** 
2173:../FreeRTOS/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2174:../FreeRTOS/tasks.c **** 	{
2175:../FreeRTOS/tasks.c **** 	TCB_t *xTCB;
2176:../FreeRTOS/tasks.c **** 	BaseType_t xReturn;
2177:../FreeRTOS/tasks.c **** 
2178:../FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2179:../FreeRTOS/tasks.c **** 		if( xTask == NULL )
2180:../FreeRTOS/tasks.c **** 		{
2181:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2182:../FreeRTOS/tasks.c **** 		}
2183:../FreeRTOS/tasks.c **** 		else
2184:../FreeRTOS/tasks.c **** 		{
2185:../FreeRTOS/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2186:../FreeRTOS/tasks.c **** 		}
2187:../FreeRTOS/tasks.c **** 
2188:../FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2189:../FreeRTOS/tasks.c **** 		{
2190:../FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2191:../FreeRTOS/tasks.c **** 		}
2192:../FreeRTOS/tasks.c **** 		else
2193:../FreeRTOS/tasks.c **** 		{
2194:../FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
2195:../FreeRTOS/tasks.c **** 		}
2196:../FreeRTOS/tasks.c **** 
2197:../FreeRTOS/tasks.c **** 		return xReturn;
2198:../FreeRTOS/tasks.c **** 	}
2199:../FreeRTOS/tasks.c **** 
2200:../FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2201:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2202:../FreeRTOS/tasks.c **** 
2203:../FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
2204:../FreeRTOS/tasks.c **** {
 2711              		.loc 1 2204 0
 2712              		.cfi_startproc
 2713              		@ args = 0, pretend = 0, frame = 24
 2714              		@ frame_needed = 1, uses_anonymous_args = 0
 2715 0000 80B5     		push	{r7, lr}
 2716              		.cfi_def_cfa_offset 8
 2717              		.cfi_offset 7, -8
 2718              		.cfi_offset 14, -4
 2719 0002 86B0     		sub	sp, sp, #24
 2720              		.cfi_def_cfa_offset 32
 2721 0004 00AF     		add	r7, sp, #0
 2722              		.cfi_def_cfa_register 7
2205:../FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2723              		.loc 1 2205 0
 2724 0006 2D4B     		ldr	r3, .L195
 2725 0008 1B68     		ldr	r3, [r3]
 2726 000a 002B     		cmp	r3, #0
 2727 000c 03D0     		beq	.L188
2206:../FreeRTOS/tasks.c **** 	{
2207:../FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2208:../FreeRTOS/tasks.c **** 		switch. */
2209:../FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
 2728              		.loc 1 2209 0
 2729 000e 2C4B     		ldr	r3, .L195+4
 2730 0010 0122     		movs	r2, #1
 2731 0012 1A60     		str	r2, [r3]
 2732 0014 4FE0     		b	.L187
 2733              	.L188:
2210:../FreeRTOS/tasks.c **** 	}
2211:../FreeRTOS/tasks.c **** 	else
2212:../FreeRTOS/tasks.c **** 	{
2213:../FreeRTOS/tasks.c **** 		xYieldPending = pdFALSE;
 2734              		.loc 1 2213 0
 2735 0016 2A4B     		ldr	r3, .L195+4
 2736 0018 0022     		movs	r2, #0
 2737 001a 1A60     		str	r2, [r3]
2214:../FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
2215:../FreeRTOS/tasks.c **** 
2216:../FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2217:../FreeRTOS/tasks.c **** 		{
2218:../FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2219:../FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2220:../FreeRTOS/tasks.c **** 				#else
2221:../FreeRTOS/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2222:../FreeRTOS/tasks.c **** 				#endif
2223:../FreeRTOS/tasks.c **** 
2224:../FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the
2225:../FreeRTOS/tasks.c **** 				accumulated	time so far.  The time the task started running was
2226:../FreeRTOS/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2227:../FreeRTOS/tasks.c **** 				protection here	so count values are only valid until the timer
2228:../FreeRTOS/tasks.c **** 				overflows.  The guard against negative values is to protect
2229:../FreeRTOS/tasks.c **** 				against suspect run time stat counter implementations - which
2230:../FreeRTOS/tasks.c **** 				are provided by the application, not the kernel. */
2231:../FreeRTOS/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2232:../FreeRTOS/tasks.c **** 				{
2233:../FreeRTOS/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2234:../FreeRTOS/tasks.c **** 				}
2235:../FreeRTOS/tasks.c **** 				else
2236:../FreeRTOS/tasks.c **** 				{
2237:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2238:../FreeRTOS/tasks.c **** 				}
2239:../FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2240:../FreeRTOS/tasks.c **** 		}
2241:../FreeRTOS/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2242:../FreeRTOS/tasks.c **** 
2243:../FreeRTOS/tasks.c **** 		/* Check for stack overflow, if configured. */
2244:../FreeRTOS/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2738              		.loc 1 2244 0
 2739 001c 294B     		ldr	r3, .L195+8
 2740 001e 1B68     		ldr	r3, [r3]
 2741 0020 1A68     		ldr	r2, [r3]
 2742 0022 284B     		ldr	r3, .L195+8
 2743 0024 1B68     		ldr	r3, [r3]
 2744 0026 1B6B     		ldr	r3, [r3, #48]
 2745 0028 9A42     		cmp	r2, r3
 2746 002a 08D8     		bhi	.L190
 2747              		.loc 1 2244 0 is_stmt 0 discriminator 1
 2748 002c 254B     		ldr	r3, .L195+8
 2749 002e 1A68     		ldr	r2, [r3]
 2750 0030 244B     		ldr	r3, .L195+8
 2751 0032 1B68     		ldr	r3, [r3]
 2752 0034 3433     		adds	r3, r3, #52
 2753 0036 1046     		mov	r0, r2
 2754 0038 1946     		mov	r1, r3
 2755 003a FFF7FEFF 		bl	vApplicationStackOverflowHook
 2756              	.L190:
 2757              	.LBB151:
2245:../FreeRTOS/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
2246:../FreeRTOS/tasks.c **** 
2247:../FreeRTOS/tasks.c **** 		/* Select a new task to run using either the generic C or port
2248:../FreeRTOS/tasks.c **** 		optimised asm code. */
2249:../FreeRTOS/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2758              		.loc 1 2249 0 is_stmt 1
 2759 003e 224B     		ldr	r3, .L195+12
 2760 0040 1B68     		ldr	r3, [r3]
 2761 0042 FB60     		str	r3, [r7, #12]
 2762              	.LBB152:
 2763              	.LBB153:
 176:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 		return ucReturn;
 2764              		.loc 2 176 0
 2765 0044 FB68     		ldr	r3, [r7, #12]
 2766              	@ 176 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2767 0046 B3FA83F3 		clz r3, r3
 2768              	@ 0 "" 2
 2769              		.thumb
 2770 004a FB72     		strb	r3, [r7, #11]
 177:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	}
 2771              		.loc 2 177 0
 2772 004c FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 2773              	.LBE153:
 2774              	.LBE152:
 2775              		.loc 1 2249 0
 2776 004e C3F11F03 		rsb	r3, r3, #31
 2777 0052 7B61     		str	r3, [r7, #20]
 2778 0054 1D49     		ldr	r1, .L195+16
 2779 0056 7A69     		ldr	r2, [r7, #20]
 2780 0058 1346     		mov	r3, r2
 2781 005a 9B00     		lsls	r3, r3, #2
 2782 005c 1344     		add	r3, r3, r2
 2783 005e 9B00     		lsls	r3, r3, #2
 2784 0060 0B44     		add	r3, r3, r1
 2785 0062 1B68     		ldr	r3, [r3]
 2786 0064 002B     		cmp	r3, #0
 2787 0066 09D1     		bne	.L192
 2788              	.LBB154:
 2789              	.LBB155:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 2790              		.loc 2 215 0 discriminator 1
 2791              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2792 0068 4FF00703 			mov r3, #7												
 2793 006c 83F31188 		msr basepri, r3											
 2794 0070 BFF36F8F 		isb														
 2795 0074 BFF34F8F 		dsb														
 2796              	
 2797              	@ 0 "" 2
 2798              		.thumb
 2799 0078 7B60     		str	r3, [r7, #4]
 2800              	.L193:
 2801              	.LBE155:
 2802              	.LBE154:
 2803              		.loc 1 2249 0 discriminator 1
 2804 007a FEE7     		b	.L193
 2805              	.L192:
 2806              	.LBB156:
 2807              		.loc 1 2249 0 is_stmt 0 discriminator 2
 2808 007c 7A69     		ldr	r2, [r7, #20]
 2809 007e 1346     		mov	r3, r2
 2810 0080 9B00     		lsls	r3, r3, #2
 2811 0082 1344     		add	r3, r3, r2
 2812 0084 9B00     		lsls	r3, r3, #2
 2813 0086 114A     		ldr	r2, .L195+16
 2814 0088 1344     		add	r3, r3, r2
 2815 008a 3B61     		str	r3, [r7, #16]
 2816 008c 3B69     		ldr	r3, [r7, #16]
 2817 008e 5B68     		ldr	r3, [r3, #4]
 2818 0090 5A68     		ldr	r2, [r3, #4]
 2819 0092 3B69     		ldr	r3, [r7, #16]
 2820 0094 5A60     		str	r2, [r3, #4]
 2821 0096 3B69     		ldr	r3, [r7, #16]
 2822 0098 5A68     		ldr	r2, [r3, #4]
 2823 009a 3B69     		ldr	r3, [r7, #16]
 2824 009c 0833     		adds	r3, r3, #8
 2825 009e 9A42     		cmp	r2, r3
 2826 00a0 04D1     		bne	.L194
 2827              		.loc 1 2249 0 discriminator 3
 2828 00a2 3B69     		ldr	r3, [r7, #16]
 2829 00a4 5B68     		ldr	r3, [r3, #4]
 2830 00a6 5A68     		ldr	r2, [r3, #4]
 2831 00a8 3B69     		ldr	r3, [r7, #16]
 2832 00aa 5A60     		str	r2, [r3, #4]
 2833              	.L194:
 2834              		.loc 1 2249 0 discriminator 5
 2835 00ac 3B69     		ldr	r3, [r7, #16]
 2836 00ae 5B68     		ldr	r3, [r3, #4]
 2837 00b0 DB68     		ldr	r3, [r3, #12]
 2838 00b2 044A     		ldr	r2, .L195+8
 2839 00b4 1360     		str	r3, [r2]
 2840              	.L187:
 2841              	.LBE156:
 2842              	.LBE151:
2250:../FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
2251:../FreeRTOS/tasks.c **** 
2252:../FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2253:../FreeRTOS/tasks.c **** 		{
2254:../FreeRTOS/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2255:../FreeRTOS/tasks.c **** 			structure specific to this task. */
2256:../FreeRTOS/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2257:../FreeRTOS/tasks.c **** 		}
2258:../FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2259:../FreeRTOS/tasks.c **** 	}
2260:../FreeRTOS/tasks.c **** }
 2843              		.loc 1 2260 0 is_stmt 1
 2844 00b6 1837     		adds	r7, r7, #24
 2845              		.cfi_def_cfa_offset 8
 2846 00b8 BD46     		mov	sp, r7
 2847              		.cfi_def_cfa_register 13
 2848              		@ sp needed
 2849 00ba 80BD     		pop	{r7, pc}
 2850              	.L196:
 2851              		.align	2
 2852              	.L195:
 2853 00bc 00000000 		.word	uxSchedulerSuspended
 2854 00c0 00000000 		.word	xYieldPending
 2855 00c4 00000000 		.word	pxCurrentTCB
 2856 00c8 00000000 		.word	uxTopReadyPriority
 2857 00cc 00000000 		.word	pxReadyTasksLists
 2858              		.cfi_endproc
 2859              	.LFE24:
 2861              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2862              		.align	2
 2863              		.global	vTaskPlaceOnEventList
 2864              		.thumb
 2865              		.thumb_func
 2867              	vTaskPlaceOnEventList:
 2868              	.LFB25:
2261:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2262:../FreeRTOS/tasks.c **** 
2263:../FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2264:../FreeRTOS/tasks.c **** {
 2869              		.loc 1 2264 0
 2870              		.cfi_startproc
 2871              		@ args = 0, pretend = 0, frame = 16
 2872              		@ frame_needed = 1, uses_anonymous_args = 0
 2873 0000 80B5     		push	{r7, lr}
 2874              		.cfi_def_cfa_offset 8
 2875              		.cfi_offset 7, -8
 2876              		.cfi_offset 14, -4
 2877 0002 84B0     		sub	sp, sp, #16
 2878              		.cfi_def_cfa_offset 24
 2879 0004 00AF     		add	r7, sp, #0
 2880              		.cfi_def_cfa_register 7
 2881 0006 7860     		str	r0, [r7, #4]
 2882 0008 3960     		str	r1, [r7]
2265:../FreeRTOS/tasks.c **** TickType_t xTimeToWake;
2266:../FreeRTOS/tasks.c **** 
2267:../FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
 2883              		.loc 1 2267 0
 2884 000a 7B68     		ldr	r3, [r7, #4]
 2885 000c 002B     		cmp	r3, #0
 2886 000e 09D1     		bne	.L198
 2887              	.LBB157:
 2888              	.LBB158:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 2889              		.loc 2 215 0 discriminator 1
 2890              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 2891 0010 4FF00703 			mov r3, #7												
 2892 0014 83F31188 		msr basepri, r3											
 2893 0018 BFF36F8F 		isb														
 2894 001c BFF34F8F 		dsb														
 2895              	
 2896              	@ 0 "" 2
 2897              		.thumb
 2898 0020 BB60     		str	r3, [r7, #8]
 2899              	.L199:
 2900              	.LBE158:
 2901              	.LBE157:
 2902              		.loc 1 2267 0 discriminator 1
 2903 0022 FEE7     		b	.L199
 2904              	.L198:
2268:../FreeRTOS/tasks.c **** 
2269:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2270:../FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2271:../FreeRTOS/tasks.c **** 
2272:../FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2273:../FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2274:../FreeRTOS/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2275:../FreeRTOS/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2276:../FreeRTOS/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2905              		.loc 1 2276 0
 2906 0024 194B     		ldr	r3, .L203
 2907 0026 1B68     		ldr	r3, [r3]
 2908 0028 1833     		adds	r3, r3, #24
 2909 002a 7868     		ldr	r0, [r7, #4]
 2910 002c 1946     		mov	r1, r3
 2911 002e FFF7FEFF 		bl	vListInsert
2277:../FreeRTOS/tasks.c **** 
2278:../FreeRTOS/tasks.c **** 	/* The task must be removed from from the ready list before it is added to
2279:../FreeRTOS/tasks.c **** 	the blocked list as the same list item is used for both lists.  Exclusive
2280:../FreeRTOS/tasks.c **** 	access to the ready lists guaranteed because the scheduler is locked. */
2281:../FreeRTOS/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 2912              		.loc 1 2281 0
 2913 0032 164B     		ldr	r3, .L203
 2914 0034 1B68     		ldr	r3, [r3]
 2915 0036 0433     		adds	r3, r3, #4
 2916 0038 1846     		mov	r0, r3
 2917 003a FFF7FEFF 		bl	uxListRemove
 2918 003e 0346     		mov	r3, r0
 2919 0040 002B     		cmp	r3, #0
 2920 0042 0BD1     		bne	.L200
2282:../FreeRTOS/tasks.c **** 	{
2283:../FreeRTOS/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2284:../FreeRTOS/tasks.c **** 		check, and the port reset macro can be called directly. */
2285:../FreeRTOS/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 2921              		.loc 1 2285 0
 2922 0044 114B     		ldr	r3, .L203
 2923 0046 1B68     		ldr	r3, [r3]
 2924 0048 DB6A     		ldr	r3, [r3, #44]
 2925 004a 1A46     		mov	r2, r3
 2926 004c 0123     		movs	r3, #1
 2927 004e 9340     		lsls	r3, r3, r2
 2928 0050 DA43     		mvns	r2, r3
 2929 0052 0F4B     		ldr	r3, .L203+4
 2930 0054 1B68     		ldr	r3, [r3]
 2931 0056 1340     		ands	r3, r3, r2
 2932 0058 0D4A     		ldr	r2, .L203+4
 2933 005a 1360     		str	r3, [r2]
 2934              	.L200:
2286:../FreeRTOS/tasks.c **** 	}
2287:../FreeRTOS/tasks.c **** 	else
2288:../FreeRTOS/tasks.c **** 	{
2289:../FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2290:../FreeRTOS/tasks.c **** 	}
2291:../FreeRTOS/tasks.c **** 
2292:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2293:../FreeRTOS/tasks.c **** 	{
2294:../FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2935              		.loc 1 2294 0
 2936 005c 3B68     		ldr	r3, [r7]
 2937 005e B3F1FF3F 		cmp	r3, #-1
 2938 0062 07D1     		bne	.L201
2295:../FreeRTOS/tasks.c **** 		{
2296:../FreeRTOS/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2297:../FreeRTOS/tasks.c **** 			list to ensure the task is not woken by a timing event.  It will
2298:../FreeRTOS/tasks.c **** 			block indefinitely. */
2299:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2939              		.loc 1 2299 0
 2940 0064 094B     		ldr	r3, .L203
 2941 0066 1B68     		ldr	r3, [r3]
 2942 0068 0433     		adds	r3, r3, #4
 2943 006a 0A48     		ldr	r0, .L203+8
 2944 006c 1946     		mov	r1, r3
 2945 006e FFF7FEFF 		bl	vListInsertEnd
 2946 0072 07E0     		b	.L197
 2947              	.L201:
2300:../FreeRTOS/tasks.c **** 		}
2301:../FreeRTOS/tasks.c **** 		else
2302:../FreeRTOS/tasks.c **** 		{
2303:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2304:../FreeRTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2305:../FreeRTOS/tasks.c **** 			scheduler will handle it. */
2306:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2948              		.loc 1 2306 0
 2949 0074 084B     		ldr	r3, .L203+12
 2950 0076 1A68     		ldr	r2, [r3]
 2951 0078 3B68     		ldr	r3, [r7]
 2952 007a 1344     		add	r3, r3, r2
 2953 007c FB60     		str	r3, [r7, #12]
2307:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2954              		.loc 1 2307 0
 2955 007e F868     		ldr	r0, [r7, #12]
 2956 0080 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2957              	.L197:
2308:../FreeRTOS/tasks.c **** 		}
2309:../FreeRTOS/tasks.c **** 	}
2310:../FreeRTOS/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2311:../FreeRTOS/tasks.c **** 	{
2312:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2313:../FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the scheduler
2314:../FreeRTOS/tasks.c **** 			will handle it. */
2315:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2316:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2317:../FreeRTOS/tasks.c **** 	}
2318:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2319:../FreeRTOS/tasks.c **** }
 2958              		.loc 1 2319 0
 2959 0084 1037     		adds	r7, r7, #16
 2960              		.cfi_def_cfa_offset 8
 2961 0086 BD46     		mov	sp, r7
 2962              		.cfi_def_cfa_register 13
 2963              		@ sp needed
 2964 0088 80BD     		pop	{r7, pc}
 2965              	.L204:
 2966 008a 00BF     		.align	2
 2967              	.L203:
 2968 008c 00000000 		.word	pxCurrentTCB
 2969 0090 00000000 		.word	uxTopReadyPriority
 2970 0094 00000000 		.word	xSuspendedTaskList
 2971 0098 00000000 		.word	xTickCount
 2972              		.cfi_endproc
 2973              	.LFE25:
 2975              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2976              		.align	2
 2977              		.global	vTaskPlaceOnUnorderedEventList
 2978              		.thumb
 2979              		.thumb_func
 2981              	vTaskPlaceOnUnorderedEventList:
 2982              	.LFB26:
2320:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2321:../FreeRTOS/tasks.c **** 
2322:../FreeRTOS/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2323:../FreeRTOS/tasks.c **** {
 2983              		.loc 1 2323 0
 2984              		.cfi_startproc
 2985              		@ args = 0, pretend = 0, frame = 32
 2986              		@ frame_needed = 1, uses_anonymous_args = 0
 2987 0000 80B5     		push	{r7, lr}
 2988              		.cfi_def_cfa_offset 8
 2989              		.cfi_offset 7, -8
 2990              		.cfi_offset 14, -4
 2991 0002 88B0     		sub	sp, sp, #32
 2992              		.cfi_def_cfa_offset 40
 2993 0004 00AF     		add	r7, sp, #0
 2994              		.cfi_def_cfa_register 7
 2995 0006 F860     		str	r0, [r7, #12]
 2996 0008 B960     		str	r1, [r7, #8]
 2997 000a 7A60     		str	r2, [r7, #4]
2324:../FreeRTOS/tasks.c **** TickType_t xTimeToWake;
2325:../FreeRTOS/tasks.c **** 
2326:../FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
 2998              		.loc 1 2326 0
 2999 000c FB68     		ldr	r3, [r7, #12]
 3000 000e 002B     		cmp	r3, #0
 3001 0010 09D1     		bne	.L206
 3002              	.LBB159:
 3003              	.LBB160:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3004              		.loc 2 215 0 discriminator 1
 3005              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3006 0012 4FF00703 			mov r3, #7												
 3007 0016 83F31188 		msr basepri, r3											
 3008 001a BFF36F8F 		isb														
 3009 001e BFF34F8F 		dsb														
 3010              	
 3011              	@ 0 "" 2
 3012              		.thumb
 3013 0022 BB61     		str	r3, [r7, #24]
 3014              	.L207:
 3015              	.LBE160:
 3016              	.LBE159:
 3017              		.loc 1 2326 0 discriminator 1
 3018 0024 FEE7     		b	.L207
 3019              	.L206:
2327:../FreeRTOS/tasks.c **** 
2328:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2329:../FreeRTOS/tasks.c **** 	the event groups implementation. */
2330:../FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
 3020              		.loc 1 2330 0
 3021 0026 234B     		ldr	r3, .L213
 3022 0028 1B68     		ldr	r3, [r3]
 3023 002a 002B     		cmp	r3, #0
 3024 002c 09D1     		bne	.L208
 3025              	.LBB161:
 3026              	.LBB162:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3027              		.loc 2 215 0 discriminator 1
 3028              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3029 002e 4FF00703 			mov r3, #7												
 3030 0032 83F31188 		msr basepri, r3											
 3031 0036 BFF36F8F 		isb														
 3032 003a BFF34F8F 		dsb														
 3033              	
 3034              	@ 0 "" 2
 3035              		.thumb
 3036 003e 7B61     		str	r3, [r7, #20]
 3037              	.L209:
 3038              	.LBE162:
 3039              	.LBE161:
 3040              		.loc 1 2330 0 discriminator 2
 3041 0040 FEE7     		b	.L209
 3042              	.L208:
2331:../FreeRTOS/tasks.c **** 
2332:../FreeRTOS/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2333:../FreeRTOS/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2334:../FreeRTOS/tasks.c **** 	task that is not in the Blocked state. */
2335:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 3043              		.loc 1 2335 0
 3044 0042 1D4B     		ldr	r3, .L213+4
 3045 0044 1B68     		ldr	r3, [r3]
 3046 0046 BA68     		ldr	r2, [r7, #8]
 3047 0048 42F00042 		orr	r2, r2, #-2147483648
 3048 004c 9A61     		str	r2, [r3, #24]
2336:../FreeRTOS/tasks.c **** 
2337:../FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2338:../FreeRTOS/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2339:../FreeRTOS/tasks.c **** 	event group implementation - and interrupts don't access event groups
2340:../FreeRTOS/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2341:../FreeRTOS/tasks.c **** 	the task level). */
2342:../FreeRTOS/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 3049              		.loc 1 2342 0
 3050 004e 1A4B     		ldr	r3, .L213+4
 3051 0050 1B68     		ldr	r3, [r3]
 3052 0052 1833     		adds	r3, r3, #24
 3053 0054 F868     		ldr	r0, [r7, #12]
 3054 0056 1946     		mov	r1, r3
 3055 0058 FFF7FEFF 		bl	vListInsertEnd
2343:../FreeRTOS/tasks.c **** 
2344:../FreeRTOS/tasks.c **** 	/* The task must be removed from the ready list before it is added to the
2345:../FreeRTOS/tasks.c **** 	blocked list.  Exclusive access can be assured to the ready list as the
2346:../FreeRTOS/tasks.c **** 	scheduler is locked. */
2347:../FreeRTOS/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 3056              		.loc 1 2347 0
 3057 005c 164B     		ldr	r3, .L213+4
 3058 005e 1B68     		ldr	r3, [r3]
 3059 0060 0433     		adds	r3, r3, #4
 3060 0062 1846     		mov	r0, r3
 3061 0064 FFF7FEFF 		bl	uxListRemove
 3062 0068 0346     		mov	r3, r0
 3063 006a 002B     		cmp	r3, #0
 3064 006c 0BD1     		bne	.L210
2348:../FreeRTOS/tasks.c **** 	{
2349:../FreeRTOS/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2350:../FreeRTOS/tasks.c **** 		check, and the port reset macro can be called directly. */
2351:../FreeRTOS/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 3065              		.loc 1 2351 0
 3066 006e 124B     		ldr	r3, .L213+4
 3067 0070 1B68     		ldr	r3, [r3]
 3068 0072 DB6A     		ldr	r3, [r3, #44]
 3069 0074 1A46     		mov	r2, r3
 3070 0076 0123     		movs	r3, #1
 3071 0078 9340     		lsls	r3, r3, r2
 3072 007a DA43     		mvns	r2, r3
 3073 007c 0F4B     		ldr	r3, .L213+8
 3074 007e 1B68     		ldr	r3, [r3]
 3075 0080 1340     		ands	r3, r3, r2
 3076 0082 0E4A     		ldr	r2, .L213+8
 3077 0084 1360     		str	r3, [r2]
 3078              	.L210:
2352:../FreeRTOS/tasks.c **** 	}
2353:../FreeRTOS/tasks.c **** 	else
2354:../FreeRTOS/tasks.c **** 	{
2355:../FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2356:../FreeRTOS/tasks.c **** 	}
2357:../FreeRTOS/tasks.c **** 
2358:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2359:../FreeRTOS/tasks.c **** 	{
2360:../FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 3079              		.loc 1 2360 0
 3080 0086 7B68     		ldr	r3, [r7, #4]
 3081 0088 B3F1FF3F 		cmp	r3, #-1
 3082 008c 07D1     		bne	.L211
2361:../FreeRTOS/tasks.c **** 		{
2362:../FreeRTOS/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2363:../FreeRTOS/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
2364:../FreeRTOS/tasks.c **** 			indefinitely. */
2365:../FreeRTOS/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3083              		.loc 1 2365 0
 3084 008e 0A4B     		ldr	r3, .L213+4
 3085 0090 1B68     		ldr	r3, [r3]
 3086 0092 0433     		adds	r3, r3, #4
 3087 0094 0A48     		ldr	r0, .L213+12
 3088 0096 1946     		mov	r1, r3
 3089 0098 FFF7FEFF 		bl	vListInsertEnd
 3090 009c 07E0     		b	.L205
 3091              	.L211:
2366:../FreeRTOS/tasks.c **** 		}
2367:../FreeRTOS/tasks.c **** 		else
2368:../FreeRTOS/tasks.c **** 		{
2369:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2370:../FreeRTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2371:../FreeRTOS/tasks.c **** 			kernel will manage it correctly. */
2372:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 3092              		.loc 1 2372 0
 3093 009e 094B     		ldr	r3, .L213+16
 3094 00a0 1A68     		ldr	r2, [r3]
 3095 00a2 7B68     		ldr	r3, [r7, #4]
 3096 00a4 1344     		add	r3, r3, r2
 3097 00a6 FB61     		str	r3, [r7, #28]
2373:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 3098              		.loc 1 2373 0
 3099 00a8 F869     		ldr	r0, [r7, #28]
 3100 00aa FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3101              	.L205:
2374:../FreeRTOS/tasks.c **** 		}
2375:../FreeRTOS/tasks.c **** 	}
2376:../FreeRTOS/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2377:../FreeRTOS/tasks.c **** 	{
2378:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2379:../FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the kernel
2380:../FreeRTOS/tasks.c **** 			will manage it correctly. */
2381:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2382:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2383:../FreeRTOS/tasks.c **** 	}
2384:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2385:../FreeRTOS/tasks.c **** }
 3102              		.loc 1 2385 0
 3103 00ae 2037     		adds	r7, r7, #32
 3104              		.cfi_def_cfa_offset 8
 3105 00b0 BD46     		mov	sp, r7
 3106              		.cfi_def_cfa_register 13
 3107              		@ sp needed
 3108 00b2 80BD     		pop	{r7, pc}
 3109              	.L214:
 3110              		.align	2
 3111              	.L213:
 3112 00b4 00000000 		.word	uxSchedulerSuspended
 3113 00b8 00000000 		.word	pxCurrentTCB
 3114 00bc 00000000 		.word	uxTopReadyPriority
 3115 00c0 00000000 		.word	xSuspendedTaskList
 3116 00c4 00000000 		.word	xTickCount
 3117              		.cfi_endproc
 3118              	.LFE26:
 3120              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 3121              		.align	2
 3122              		.global	vTaskPlaceOnEventListRestricted
 3123              		.thumb
 3124              		.thumb_func
 3126              	vTaskPlaceOnEventListRestricted:
 3127              	.LFB27:
2386:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2387:../FreeRTOS/tasks.c **** 
2388:../FreeRTOS/tasks.c **** #if configUSE_TIMERS == 1
2389:../FreeRTOS/tasks.c **** 
2390:../FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, c
2391:../FreeRTOS/tasks.c **** 	{
 3128              		.loc 1 2391 0
 3129              		.cfi_startproc
 3130              		@ args = 0, pretend = 0, frame = 24
 3131              		@ frame_needed = 1, uses_anonymous_args = 0
 3132 0000 80B5     		push	{r7, lr}
 3133              		.cfi_def_cfa_offset 8
 3134              		.cfi_offset 7, -8
 3135              		.cfi_offset 14, -4
 3136 0002 86B0     		sub	sp, sp, #24
 3137              		.cfi_def_cfa_offset 32
 3138 0004 00AF     		add	r7, sp, #0
 3139              		.cfi_def_cfa_register 7
 3140 0006 F860     		str	r0, [r7, #12]
 3141 0008 B960     		str	r1, [r7, #8]
 3142 000a 7A60     		str	r2, [r7, #4]
2392:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
2393:../FreeRTOS/tasks.c **** 
2394:../FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
 3143              		.loc 1 2394 0
 3144 000c FB68     		ldr	r3, [r7, #12]
 3145 000e 002B     		cmp	r3, #0
 3146 0010 09D1     		bne	.L216
 3147              	.LBB163:
 3148              	.LBB164:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3149              		.loc 2 215 0 discriminator 1
 3150              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3151 0012 4FF00703 			mov r3, #7												
 3152 0016 83F31188 		msr basepri, r3											
 3153 001a BFF36F8F 		isb														
 3154 001e BFF34F8F 		dsb														
 3155              	
 3156              	@ 0 "" 2
 3157              		.thumb
 3158 0022 3B61     		str	r3, [r7, #16]
 3159              	.L217:
 3160              	.LBE164:
 3161              	.LBE163:
 3162              		.loc 1 2394 0 discriminator 1
 3163 0024 FEE7     		b	.L217
 3164              	.L216:
2395:../FreeRTOS/tasks.c **** 
2396:../FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
2397:../FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2398:../FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2399:../FreeRTOS/tasks.c **** 		it should be called with the scheduler suspended. */
2400:../FreeRTOS/tasks.c **** 
2401:../FreeRTOS/tasks.c **** 
2402:../FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2403:../FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
2404:../FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2405:../FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
2406:../FreeRTOS/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 3165              		.loc 1 2406 0
 3166 0026 194B     		ldr	r3, .L221
 3167 0028 1B68     		ldr	r3, [r3]
 3168 002a 1833     		adds	r3, r3, #24
 3169 002c F868     		ldr	r0, [r7, #12]
 3170 002e 1946     		mov	r1, r3
 3171 0030 FFF7FEFF 		bl	vListInsertEnd
2407:../FreeRTOS/tasks.c **** 
2408:../FreeRTOS/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
2409:../FreeRTOS/tasks.c **** 		blocked list as the same list item is used for both lists.  This
2410:../FreeRTOS/tasks.c **** 		function is called with the scheduler locked so interrupts will not
2411:../FreeRTOS/tasks.c **** 		access the lists at the same time. */
2412:../FreeRTOS/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 3172              		.loc 1 2412 0
 3173 0034 154B     		ldr	r3, .L221
 3174 0036 1B68     		ldr	r3, [r3]
 3175 0038 0433     		adds	r3, r3, #4
 3176 003a 1846     		mov	r0, r3
 3177 003c FFF7FEFF 		bl	uxListRemove
 3178 0040 0346     		mov	r3, r0
 3179 0042 002B     		cmp	r3, #0
 3180 0044 0BD1     		bne	.L218
2413:../FreeRTOS/tasks.c **** 		{
2414:../FreeRTOS/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
2415:../FreeRTOS/tasks.c **** 			check, and the port reset macro can be called directly. */
2416:../FreeRTOS/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 3181              		.loc 1 2416 0
 3182 0046 114B     		ldr	r3, .L221
 3183 0048 1B68     		ldr	r3, [r3]
 3184 004a DB6A     		ldr	r3, [r3, #44]
 3185 004c 1A46     		mov	r2, r3
 3186 004e 0123     		movs	r3, #1
 3187 0050 9340     		lsls	r3, r3, r2
 3188 0052 DA43     		mvns	r2, r3
 3189 0054 0E4B     		ldr	r3, .L221+4
 3190 0056 1B68     		ldr	r3, [r3]
 3191 0058 1340     		ands	r3, r3, r2
 3192 005a 0D4A     		ldr	r2, .L221+4
 3193 005c 1360     		str	r3, [r2]
 3194              	.L218:
2417:../FreeRTOS/tasks.c **** 		}
2418:../FreeRTOS/tasks.c **** 		else
2419:../FreeRTOS/tasks.c **** 		{
2420:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2421:../FreeRTOS/tasks.c **** 		}
2422:../FreeRTOS/tasks.c **** 
2423:../FreeRTOS/tasks.c **** 		/* If vTaskSuspend() is available then the suspended task list is also
2424:../FreeRTOS/tasks.c **** 		available and a task that is blocking indefinitely can enter the
2425:../FreeRTOS/tasks.c **** 		suspended state (it is not really suspended as it will re-enter the
2426:../FreeRTOS/tasks.c **** 		Ready state when the event it is waiting indefinitely for occurs).
2427:../FreeRTOS/tasks.c **** 		Blocking indefinitely is useful when using tickless idle mode as when
2428:../FreeRTOS/tasks.c **** 		all tasks are blocked indefinitely all timers can be turned off. */
2429:../FreeRTOS/tasks.c **** 		#if( INCLUDE_vTaskSuspend == 1 )
2430:../FreeRTOS/tasks.c **** 		{
2431:../FreeRTOS/tasks.c **** 			if( xWaitIndefinitely == pdTRUE )
 3195              		.loc 1 2431 0
 3196 005e 7B68     		ldr	r3, [r7, #4]
 3197 0060 012B     		cmp	r3, #1
 3198 0062 07D1     		bne	.L219
2432:../FreeRTOS/tasks.c **** 			{
2433:../FreeRTOS/tasks.c **** 				/* Add the task to the suspended task list instead of a delayed
2434:../FreeRTOS/tasks.c **** 				task list to ensure the task is not woken by a timing event.  It
2435:../FreeRTOS/tasks.c **** 				will block indefinitely. */
2436:../FreeRTOS/tasks.c **** 				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3199              		.loc 1 2436 0
 3200 0064 094B     		ldr	r3, .L221
 3201 0066 1B68     		ldr	r3, [r3]
 3202 0068 0433     		adds	r3, r3, #4
 3203 006a 0A48     		ldr	r0, .L221+8
 3204 006c 1946     		mov	r1, r3
 3205 006e FFF7FEFF 		bl	vListInsertEnd
 3206 0072 07E0     		b	.L215
 3207              	.L219:
2437:../FreeRTOS/tasks.c **** 			}
2438:../FreeRTOS/tasks.c **** 			else
2439:../FreeRTOS/tasks.c **** 			{
2440:../FreeRTOS/tasks.c **** 				/* Calculate the time at which the task should be woken if the
2441:../FreeRTOS/tasks.c **** 				event does not occur.  This may overflow but this doesn't
2442:../FreeRTOS/tasks.c **** 				matter. */
2443:../FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToWait;
 3208              		.loc 1 2443 0
 3209 0074 084B     		ldr	r3, .L221+12
 3210 0076 1A68     		ldr	r2, [r3]
 3211 0078 BB68     		ldr	r3, [r7, #8]
 3212 007a 1344     		add	r3, r3, r2
 3213 007c 7B61     		str	r3, [r7, #20]
2444:../FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
2445:../FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 3214              		.loc 1 2445 0
 3215 007e 7869     		ldr	r0, [r7, #20]
 3216 0080 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3217              	.L215:
2446:../FreeRTOS/tasks.c **** 			}
2447:../FreeRTOS/tasks.c **** 		}
2448:../FreeRTOS/tasks.c **** 		#else
2449:../FreeRTOS/tasks.c **** 		{
2450:../FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2451:../FreeRTOS/tasks.c **** 			does not occur.  This may overflow but this doesn't matter. */
2452:../FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2453:../FreeRTOS/tasks.c **** 			traceTASK_DELAY_UNTIL();
2454:../FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2455:../FreeRTOS/tasks.c **** 
2456:../FreeRTOS/tasks.c **** 			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
2457:../FreeRTOS/tasks.c **** 			defined. */
2458:../FreeRTOS/tasks.c **** 			( void ) xWaitIndefinitely;
2459:../FreeRTOS/tasks.c **** 		}
2460:../FreeRTOS/tasks.c **** 		#endif
2461:../FreeRTOS/tasks.c **** 	}
 3218              		.loc 1 2461 0
 3219 0084 1837     		adds	r7, r7, #24
 3220              		.cfi_def_cfa_offset 8
 3221 0086 BD46     		mov	sp, r7
 3222              		.cfi_def_cfa_register 13
 3223              		@ sp needed
 3224 0088 80BD     		pop	{r7, pc}
 3225              	.L222:
 3226 008a 00BF     		.align	2
 3227              	.L221:
 3228 008c 00000000 		.word	pxCurrentTCB
 3229 0090 00000000 		.word	uxTopReadyPriority
 3230 0094 00000000 		.word	xSuspendedTaskList
 3231 0098 00000000 		.word	xTickCount
 3232              		.cfi_endproc
 3233              	.LFE27:
 3235              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 3236              		.align	2
 3237              		.global	xTaskRemoveFromEventList
 3238              		.thumb
 3239              		.thumb_func
 3241              	xTaskRemoveFromEventList:
 3242              	.LFB28:
2462:../FreeRTOS/tasks.c **** 
2463:../FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
2464:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2465:../FreeRTOS/tasks.c **** 
2466:../FreeRTOS/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2467:../FreeRTOS/tasks.c **** {
 3243              		.loc 1 2467 0
 3244              		.cfi_startproc
 3245              		@ args = 0, pretend = 0, frame = 24
 3246              		@ frame_needed = 1, uses_anonymous_args = 0
 3247 0000 80B5     		push	{r7, lr}
 3248              		.cfi_def_cfa_offset 8
 3249              		.cfi_offset 7, -8
 3250              		.cfi_offset 14, -4
 3251 0002 86B0     		sub	sp, sp, #24
 3252              		.cfi_def_cfa_offset 32
 3253 0004 00AF     		add	r7, sp, #0
 3254              		.cfi_def_cfa_register 7
 3255 0006 7860     		str	r0, [r7, #4]
2468:../FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
2469:../FreeRTOS/tasks.c **** BaseType_t xReturn;
2470:../FreeRTOS/tasks.c **** 
2471:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2472:../FreeRTOS/tasks.c **** 	called from a critical section within an ISR. */
2473:../FreeRTOS/tasks.c **** 
2474:../FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2475:../FreeRTOS/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2476:../FreeRTOS/tasks.c **** 	the delayed list, and add it to the ready list.
2477:../FreeRTOS/tasks.c **** 
2478:../FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
2479:../FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2480:../FreeRTOS/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2481:../FreeRTOS/tasks.c **** 
2482:../FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
2483:../FreeRTOS/tasks.c **** 	pxEventList is not empty. */
2484:../FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 3256              		.loc 1 2484 0
 3257 0008 7B68     		ldr	r3, [r7, #4]
 3258 000a DB68     		ldr	r3, [r3, #12]
 3259 000c DB68     		ldr	r3, [r3, #12]
 3260 000e 3B61     		str	r3, [r7, #16]
2485:../FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3261              		.loc 1 2485 0
 3262 0010 3B69     		ldr	r3, [r7, #16]
 3263 0012 002B     		cmp	r3, #0
 3264 0014 09D1     		bne	.L224
 3265              	.LBB165:
 3266              	.LBB166:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3267              		.loc 2 215 0 discriminator 1
 3268              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3269 0016 4FF00703 			mov r3, #7												
 3270 001a 83F31188 		msr basepri, r3											
 3271 001e BFF36F8F 		isb														
 3272 0022 BFF34F8F 		dsb														
 3273              	
 3274              	@ 0 "" 2
 3275              		.thumb
 3276 0026 FB60     		str	r3, [r7, #12]
 3277              	.L225:
 3278              	.LBE166:
 3279              	.LBE165:
 3280              		.loc 1 2485 0 discriminator 1
 3281 0028 FEE7     		b	.L225
 3282              	.L224:
2486:../FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 3283              		.loc 1 2486 0
 3284 002a 3B69     		ldr	r3, [r7, #16]
 3285 002c 1833     		adds	r3, r3, #24
 3286 002e 1846     		mov	r0, r3
 3287 0030 FFF7FEFF 		bl	uxListRemove
2487:../FreeRTOS/tasks.c **** 
2488:../FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3288              		.loc 1 2488 0
 3289 0034 1E4B     		ldr	r3, .L231
 3290 0036 1B68     		ldr	r3, [r3]
 3291 0038 002B     		cmp	r3, #0
 3292 003a 1ED1     		bne	.L226
2489:../FreeRTOS/tasks.c **** 	{
2490:../FreeRTOS/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 3293              		.loc 1 2490 0
 3294 003c 3B69     		ldr	r3, [r7, #16]
 3295 003e 0433     		adds	r3, r3, #4
 3296 0040 1846     		mov	r0, r3
 3297 0042 FFF7FEFF 		bl	uxListRemove
2491:../FreeRTOS/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 3298              		.loc 1 2491 0
 3299 0046 3B69     		ldr	r3, [r7, #16]
 3300 0048 DB6A     		ldr	r3, [r3, #44]
 3301 004a 1A46     		mov	r2, r3
 3302 004c 0123     		movs	r3, #1
 3303 004e 03FA02F2 		lsl	r2, r3, r2
 3304 0052 184B     		ldr	r3, .L231+4
 3305 0054 1B68     		ldr	r3, [r3]
 3306 0056 1343     		orrs	r3, r3, r2
 3307 0058 164A     		ldr	r2, .L231+4
 3308 005a 1360     		str	r3, [r2]
 3309 005c 3B69     		ldr	r3, [r7, #16]
 3310 005e DA6A     		ldr	r2, [r3, #44]
 3311 0060 1346     		mov	r3, r2
 3312 0062 9B00     		lsls	r3, r3, #2
 3313 0064 1344     		add	r3, r3, r2
 3314 0066 9B00     		lsls	r3, r3, #2
 3315 0068 134A     		ldr	r2, .L231+8
 3316 006a 1A44     		add	r2, r2, r3
 3317 006c 3B69     		ldr	r3, [r7, #16]
 3318 006e 0433     		adds	r3, r3, #4
 3319 0070 1046     		mov	r0, r2
 3320 0072 1946     		mov	r1, r3
 3321 0074 FFF7FEFF 		bl	vListInsertEnd
 3322 0078 05E0     		b	.L227
 3323              	.L226:
2492:../FreeRTOS/tasks.c **** 	}
2493:../FreeRTOS/tasks.c **** 	else
2494:../FreeRTOS/tasks.c **** 	{
2495:../FreeRTOS/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2496:../FreeRTOS/tasks.c **** 		pending until the scheduler is resumed. */
2497:../FreeRTOS/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 3324              		.loc 1 2497 0
 3325 007a 3B69     		ldr	r3, [r7, #16]
 3326 007c 1833     		adds	r3, r3, #24
 3327 007e 0F48     		ldr	r0, .L231+12
 3328 0080 1946     		mov	r1, r3
 3329 0082 FFF7FEFF 		bl	vListInsertEnd
 3330              	.L227:
2498:../FreeRTOS/tasks.c **** 	}
2499:../FreeRTOS/tasks.c **** 
2500:../FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3331              		.loc 1 2500 0
 3332 0086 3B69     		ldr	r3, [r7, #16]
 3333 0088 DA6A     		ldr	r2, [r3, #44]
 3334 008a 0D4B     		ldr	r3, .L231+16
 3335 008c 1B68     		ldr	r3, [r3]
 3336 008e DB6A     		ldr	r3, [r3, #44]
 3337 0090 9A42     		cmp	r2, r3
 3338 0092 05D9     		bls	.L228
2501:../FreeRTOS/tasks.c **** 	{
2502:../FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2503:../FreeRTOS/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2504:../FreeRTOS/tasks.c **** 		it should force a context switch now. */
2505:../FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 3339              		.loc 1 2505 0
 3340 0094 0123     		movs	r3, #1
 3341 0096 7B61     		str	r3, [r7, #20]
2506:../FreeRTOS/tasks.c **** 
2507:../FreeRTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2508:../FreeRTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2509:../FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
 3342              		.loc 1 2509 0
 3343 0098 0A4B     		ldr	r3, .L231+20
 3344 009a 0122     		movs	r2, #1
 3345 009c 1A60     		str	r2, [r3]
 3346 009e 01E0     		b	.L229
 3347              	.L228:
2510:../FreeRTOS/tasks.c **** 	}
2511:../FreeRTOS/tasks.c **** 	else
2512:../FreeRTOS/tasks.c **** 	{
2513:../FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 3348              		.loc 1 2513 0
 3349 00a0 0023     		movs	r3, #0
 3350 00a2 7B61     		str	r3, [r7, #20]
 3351              	.L229:
2514:../FreeRTOS/tasks.c **** 	}
2515:../FreeRTOS/tasks.c **** 
2516:../FreeRTOS/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
2517:../FreeRTOS/tasks.c **** 	{
2518:../FreeRTOS/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2519:../FreeRTOS/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2520:../FreeRTOS/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2521:../FreeRTOS/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
2522:../FreeRTOS/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2523:../FreeRTOS/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2524:../FreeRTOS/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2525:../FreeRTOS/tasks.c **** 		ensure it is updated at the earliest possible time. */
2526:../FreeRTOS/tasks.c **** 		prvResetNextTaskUnblockTime();
2527:../FreeRTOS/tasks.c **** 	}
2528:../FreeRTOS/tasks.c **** 	#endif
2529:../FreeRTOS/tasks.c **** 
2530:../FreeRTOS/tasks.c **** 	return xReturn;
 3352              		.loc 1 2530 0
 3353 00a4 7B69     		ldr	r3, [r7, #20]
2531:../FreeRTOS/tasks.c **** }
 3354              		.loc 1 2531 0
 3355 00a6 1846     		mov	r0, r3
 3356 00a8 1837     		adds	r7, r7, #24
 3357              		.cfi_def_cfa_offset 8
 3358 00aa BD46     		mov	sp, r7
 3359              		.cfi_def_cfa_register 13
 3360              		@ sp needed
 3361 00ac 80BD     		pop	{r7, pc}
 3362              	.L232:
 3363 00ae 00BF     		.align	2
 3364              	.L231:
 3365 00b0 00000000 		.word	uxSchedulerSuspended
 3366 00b4 00000000 		.word	uxTopReadyPriority
 3367 00b8 00000000 		.word	pxReadyTasksLists
 3368 00bc 00000000 		.word	xPendingReadyList
 3369 00c0 00000000 		.word	pxCurrentTCB
 3370 00c4 00000000 		.word	xYieldPending
 3371              		.cfi_endproc
 3372              	.LFE28:
 3374              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3375              		.align	2
 3376              		.global	xTaskRemoveFromUnorderedEventList
 3377              		.thumb
 3378              		.thumb_func
 3380              	xTaskRemoveFromUnorderedEventList:
 3381              	.LFB29:
2532:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2533:../FreeRTOS/tasks.c **** 
2534:../FreeRTOS/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2535:../FreeRTOS/tasks.c **** {
 3382              		.loc 1 2535 0
 3383              		.cfi_startproc
 3384              		@ args = 0, pretend = 0, frame = 24
 3385              		@ frame_needed = 1, uses_anonymous_args = 0
 3386 0000 80B5     		push	{r7, lr}
 3387              		.cfi_def_cfa_offset 8
 3388              		.cfi_offset 7, -8
 3389              		.cfi_offset 14, -4
 3390 0002 86B0     		sub	sp, sp, #24
 3391              		.cfi_def_cfa_offset 32
 3392 0004 00AF     		add	r7, sp, #0
 3393              		.cfi_def_cfa_register 7
 3394 0006 7860     		str	r0, [r7, #4]
 3395 0008 3960     		str	r1, [r7]
2536:../FreeRTOS/tasks.c **** TCB_t *pxUnblockedTCB;
2537:../FreeRTOS/tasks.c **** BaseType_t xReturn;
2538:../FreeRTOS/tasks.c **** 
2539:../FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2540:../FreeRTOS/tasks.c **** 	the event flags implementation. */
2541:../FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
 3396              		.loc 1 2541 0
 3397 000a 2C4B     		ldr	r3, .L241
 3398 000c 1B68     		ldr	r3, [r3]
 3399 000e 002B     		cmp	r3, #0
 3400 0010 09D1     		bne	.L234
 3401              	.LBB167:
 3402              	.LBB168:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3403              		.loc 2 215 0 discriminator 1
 3404              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3405 0012 4FF00703 			mov r3, #7												
 3406 0016 83F31188 		msr basepri, r3											
 3407 001a BFF36F8F 		isb														
 3408 001e BFF34F8F 		dsb														
 3409              	
 3410              	@ 0 "" 2
 3411              		.thumb
 3412 0022 FB60     		str	r3, [r7, #12]
 3413              	.L235:
 3414              	.LBE168:
 3415              	.LBE167:
 3416              		.loc 1 2541 0 discriminator 1
 3417 0024 FEE7     		b	.L235
 3418              	.L234:
2542:../FreeRTOS/tasks.c **** 
2543:../FreeRTOS/tasks.c **** 	/* Store the new item value in the event list. */
2544:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3419              		.loc 1 2544 0
 3420 0026 3B68     		ldr	r3, [r7]
 3421 0028 43F00042 		orr	r2, r3, #-2147483648
 3422 002c 7B68     		ldr	r3, [r7, #4]
 3423 002e 1A60     		str	r2, [r3]
2545:../FreeRTOS/tasks.c **** 
2546:../FreeRTOS/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2547:../FreeRTOS/tasks.c **** 	event flags. */
2548:../FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 3424              		.loc 1 2548 0
 3425 0030 7B68     		ldr	r3, [r7, #4]
 3426 0032 DB68     		ldr	r3, [r3, #12]
 3427 0034 3B61     		str	r3, [r7, #16]
2549:../FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 3428              		.loc 1 2549 0
 3429 0036 3B69     		ldr	r3, [r7, #16]
 3430 0038 002B     		cmp	r3, #0
 3431 003a 09D1     		bne	.L236
 3432              	.LBB169:
 3433              	.LBB170:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3434              		.loc 2 215 0 discriminator 1
 3435              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3436 003c 4FF00703 			mov r3, #7												
 3437 0040 83F31188 		msr basepri, r3											
 3438 0044 BFF36F8F 		isb														
 3439 0048 BFF34F8F 		dsb														
 3440              	
 3441              	@ 0 "" 2
 3442              		.thumb
 3443 004c BB60     		str	r3, [r7, #8]
 3444              	.L237:
 3445              	.LBE170:
 3446              	.LBE169:
 3447              		.loc 1 2549 0 discriminator 2
 3448 004e FEE7     		b	.L237
 3449              	.L236:
2550:../FreeRTOS/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3450              		.loc 1 2550 0
 3451 0050 7868     		ldr	r0, [r7, #4]
 3452 0052 FFF7FEFF 		bl	uxListRemove
2551:../FreeRTOS/tasks.c **** 
2552:../FreeRTOS/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2553:../FreeRTOS/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2554:../FreeRTOS/tasks.c **** 	lists. */
2555:../FreeRTOS/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 3453              		.loc 1 2555 0
 3454 0056 3B69     		ldr	r3, [r7, #16]
 3455 0058 0433     		adds	r3, r3, #4
 3456 005a 1846     		mov	r0, r3
 3457 005c FFF7FEFF 		bl	uxListRemove
2556:../FreeRTOS/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3458              		.loc 1 2556 0
 3459 0060 3B69     		ldr	r3, [r7, #16]
 3460 0062 DB6A     		ldr	r3, [r3, #44]
 3461 0064 1A46     		mov	r2, r3
 3462 0066 0123     		movs	r3, #1
 3463 0068 03FA02F2 		lsl	r2, r3, r2
 3464 006c 144B     		ldr	r3, .L241+4
 3465 006e 1B68     		ldr	r3, [r3]
 3466 0070 1343     		orrs	r3, r3, r2
 3467 0072 134A     		ldr	r2, .L241+4
 3468 0074 1360     		str	r3, [r2]
 3469 0076 3B69     		ldr	r3, [r7, #16]
 3470 0078 DA6A     		ldr	r2, [r3, #44]
 3471 007a 1346     		mov	r3, r2
 3472 007c 9B00     		lsls	r3, r3, #2
 3473 007e 1344     		add	r3, r3, r2
 3474 0080 9B00     		lsls	r3, r3, #2
 3475 0082 104A     		ldr	r2, .L241+8
 3476 0084 1A44     		add	r2, r2, r3
 3477 0086 3B69     		ldr	r3, [r7, #16]
 3478 0088 0433     		adds	r3, r3, #4
 3479 008a 1046     		mov	r0, r2
 3480 008c 1946     		mov	r1, r3
 3481 008e FFF7FEFF 		bl	vListInsertEnd
2557:../FreeRTOS/tasks.c **** 
2558:../FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3482              		.loc 1 2558 0
 3483 0092 3B69     		ldr	r3, [r7, #16]
 3484 0094 DA6A     		ldr	r2, [r3, #44]
 3485 0096 0C4B     		ldr	r3, .L241+12
 3486 0098 1B68     		ldr	r3, [r3]
 3487 009a DB6A     		ldr	r3, [r3, #44]
 3488 009c 9A42     		cmp	r2, r3
 3489 009e 05D9     		bls	.L238
2559:../FreeRTOS/tasks.c **** 	{
2560:../FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has
2561:../FreeRTOS/tasks.c **** 		a higher priority than the calling task.  This allows
2562:../FreeRTOS/tasks.c **** 		the calling task to know if it should force a context
2563:../FreeRTOS/tasks.c **** 		switch now. */
2564:../FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 3490              		.loc 1 2564 0
 3491 00a0 0123     		movs	r3, #1
 3492 00a2 7B61     		str	r3, [r7, #20]
2565:../FreeRTOS/tasks.c **** 
2566:../FreeRTOS/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2567:../FreeRTOS/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2568:../FreeRTOS/tasks.c **** 		xYieldPending = pdTRUE;
 3493              		.loc 1 2568 0
 3494 00a4 094B     		ldr	r3, .L241+16
 3495 00a6 0122     		movs	r2, #1
 3496 00a8 1A60     		str	r2, [r3]
 3497 00aa 01E0     		b	.L239
 3498              	.L238:
2569:../FreeRTOS/tasks.c **** 	}
2570:../FreeRTOS/tasks.c **** 	else
2571:../FreeRTOS/tasks.c **** 	{
2572:../FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 3499              		.loc 1 2572 0
 3500 00ac 0023     		movs	r3, #0
 3501 00ae 7B61     		str	r3, [r7, #20]
 3502              	.L239:
2573:../FreeRTOS/tasks.c **** 	}
2574:../FreeRTOS/tasks.c **** 
2575:../FreeRTOS/tasks.c **** 	return xReturn;
 3503              		.loc 1 2575 0
 3504 00b0 7B69     		ldr	r3, [r7, #20]
2576:../FreeRTOS/tasks.c **** }
 3505              		.loc 1 2576 0
 3506 00b2 1846     		mov	r0, r3
 3507 00b4 1837     		adds	r7, r7, #24
 3508              		.cfi_def_cfa_offset 8
 3509 00b6 BD46     		mov	sp, r7
 3510              		.cfi_def_cfa_register 13
 3511              		@ sp needed
 3512 00b8 80BD     		pop	{r7, pc}
 3513              	.L242:
 3514 00ba 00BF     		.align	2
 3515              	.L241:
 3516 00bc 00000000 		.word	uxSchedulerSuspended
 3517 00c0 00000000 		.word	uxTopReadyPriority
 3518 00c4 00000000 		.word	pxReadyTasksLists
 3519 00c8 00000000 		.word	pxCurrentTCB
 3520 00cc 00000000 		.word	xYieldPending
 3521              		.cfi_endproc
 3522              	.LFE29:
 3524              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3525              		.align	2
 3526              		.global	vTaskSetTimeOutState
 3527              		.thumb
 3528              		.thumb_func
 3530              	vTaskSetTimeOutState:
 3531              	.LFB30:
2577:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2578:../FreeRTOS/tasks.c **** 
2579:../FreeRTOS/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2580:../FreeRTOS/tasks.c **** {
 3532              		.loc 1 2580 0
 3533              		.cfi_startproc
 3534              		@ args = 0, pretend = 0, frame = 16
 3535              		@ frame_needed = 1, uses_anonymous_args = 0
 3536              		@ link register save eliminated.
 3537 0000 80B4     		push	{r7}
 3538              		.cfi_def_cfa_offset 4
 3539              		.cfi_offset 7, -4
 3540 0002 85B0     		sub	sp, sp, #20
 3541              		.cfi_def_cfa_offset 24
 3542 0004 00AF     		add	r7, sp, #0
 3543              		.cfi_def_cfa_register 7
 3544 0006 7860     		str	r0, [r7, #4]
2581:../FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
 3545              		.loc 1 2581 0
 3546 0008 7B68     		ldr	r3, [r7, #4]
 3547 000a 002B     		cmp	r3, #0
 3548 000c 09D1     		bne	.L244
 3549              	.LBB171:
 3550              	.LBB172:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3551              		.loc 2 215 0 discriminator 1
 3552              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3553 000e 4FF00703 			mov r3, #7												
 3554 0012 83F31188 		msr basepri, r3											
 3555 0016 BFF36F8F 		isb														
 3556 001a BFF34F8F 		dsb														
 3557              	
 3558              	@ 0 "" 2
 3559              		.thumb
 3560 001e FB60     		str	r3, [r7, #12]
 3561              	.L245:
 3562              	.LBE172:
 3563              	.LBE171:
 3564              		.loc 1 2581 0 discriminator 1
 3565 0020 FEE7     		b	.L245
 3566              	.L244:
2582:../FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3567              		.loc 1 2582 0
 3568 0022 064B     		ldr	r3, .L246
 3569 0024 1A68     		ldr	r2, [r3]
 3570 0026 7B68     		ldr	r3, [r7, #4]
 3571 0028 1A60     		str	r2, [r3]
2583:../FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3572              		.loc 1 2583 0
 3573 002a 054B     		ldr	r3, .L246+4
 3574 002c 1A68     		ldr	r2, [r3]
 3575 002e 7B68     		ldr	r3, [r7, #4]
 3576 0030 5A60     		str	r2, [r3, #4]
2584:../FreeRTOS/tasks.c **** }
 3577              		.loc 1 2584 0
 3578 0032 1437     		adds	r7, r7, #20
 3579              		.cfi_def_cfa_offset 4
 3580 0034 BD46     		mov	sp, r7
 3581              		.cfi_def_cfa_register 13
 3582              		@ sp needed
 3583 0036 5DF8047B 		ldr	r7, [sp], #4
 3584              		.cfi_restore 7
 3585              		.cfi_def_cfa_offset 0
 3586 003a 7047     		bx	lr
 3587              	.L247:
 3588              		.align	2
 3589              	.L246:
 3590 003c 00000000 		.word	xNumOfOverflows
 3591 0040 00000000 		.word	xTickCount
 3592              		.cfi_endproc
 3593              	.LFE30:
 3595              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3596              		.align	2
 3597              		.global	xTaskCheckForTimeOut
 3598              		.thumb
 3599              		.thumb_func
 3601              	xTaskCheckForTimeOut:
 3602              	.LFB31:
2585:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2586:../FreeRTOS/tasks.c **** 
2587:../FreeRTOS/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2588:../FreeRTOS/tasks.c **** {
 3603              		.loc 1 2588 0
 3604              		.cfi_startproc
 3605              		@ args = 0, pretend = 0, frame = 24
 3606              		@ frame_needed = 1, uses_anonymous_args = 0
 3607 0000 80B5     		push	{r7, lr}
 3608              		.cfi_def_cfa_offset 8
 3609              		.cfi_offset 7, -8
 3610              		.cfi_offset 14, -4
 3611 0002 86B0     		sub	sp, sp, #24
 3612              		.cfi_def_cfa_offset 32
 3613 0004 00AF     		add	r7, sp, #0
 3614              		.cfi_def_cfa_register 7
 3615 0006 7860     		str	r0, [r7, #4]
 3616 0008 3960     		str	r1, [r7]
2589:../FreeRTOS/tasks.c **** BaseType_t xReturn;
2590:../FreeRTOS/tasks.c **** 
2591:../FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
 3617              		.loc 1 2591 0
 3618 000a 7B68     		ldr	r3, [r7, #4]
 3619 000c 002B     		cmp	r3, #0
 3620 000e 09D1     		bne	.L249
 3621              	.LBB173:
 3622              	.LBB174:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3623              		.loc 2 215 0 discriminator 1
 3624              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3625 0010 4FF00703 			mov r3, #7												
 3626 0014 83F31188 		msr basepri, r3											
 3627 0018 BFF36F8F 		isb														
 3628 001c BFF34F8F 		dsb														
 3629              	
 3630              	@ 0 "" 2
 3631              		.thumb
 3632 0020 FB60     		str	r3, [r7, #12]
 3633              	.L250:
 3634              	.LBE174:
 3635              	.LBE173:
 3636              		.loc 1 2591 0 discriminator 1
 3637 0022 FEE7     		b	.L250
 3638              	.L249:
2592:../FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
 3639              		.loc 1 2592 0
 3640 0024 3B68     		ldr	r3, [r7]
 3641 0026 002B     		cmp	r3, #0
 3642 0028 09D1     		bne	.L251
 3643              	.LBB175:
 3644              	.LBB176:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 3645              		.loc 2 215 0 discriminator 1
 3646              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 3647 002a 4FF00703 			mov r3, #7												
 3648 002e 83F31188 		msr basepri, r3											
 3649 0032 BFF36F8F 		isb														
 3650 0036 BFF34F8F 		dsb														
 3651              	
 3652              	@ 0 "" 2
 3653              		.thumb
 3654 003a BB60     		str	r3, [r7, #8]
 3655              	.L252:
 3656              	.LBE176:
 3657              	.LBE175:
 3658              		.loc 1 2592 0 discriminator 2
 3659 003c FEE7     		b	.L252
 3660              	.L251:
2593:../FreeRTOS/tasks.c **** 
2594:../FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 3661              		.loc 1 2594 0
 3662 003e FFF7FEFF 		bl	vPortEnterCritical
 3663              	.LBB177:
2595:../FreeRTOS/tasks.c **** 	{
2596:../FreeRTOS/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2597:../FreeRTOS/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3664              		.loc 1 2597 0
 3665 0042 1C4B     		ldr	r3, .L258
 3666 0044 1B68     		ldr	r3, [r3]
 3667 0046 3B61     		str	r3, [r7, #16]
2598:../FreeRTOS/tasks.c **** 
2599:../FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2600:../FreeRTOS/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2601:../FreeRTOS/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2602:../FreeRTOS/tasks.c **** 			therefore never time out. */
2603:../FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3668              		.loc 1 2603 0
 3669 0048 3B68     		ldr	r3, [r7]
 3670 004a 1B68     		ldr	r3, [r3]
 3671 004c B3F1FF3F 		cmp	r3, #-1
 3672 0050 02D1     		bne	.L253
2604:../FreeRTOS/tasks.c **** 			{
2605:../FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 3673              		.loc 1 2605 0
 3674 0052 0023     		movs	r3, #0
 3675 0054 7B61     		str	r3, [r7, #20]
 3676 0056 26E0     		b	.L254
 3677              	.L253:
2606:../FreeRTOS/tasks.c **** 			}
2607:../FreeRTOS/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2608:../FreeRTOS/tasks.c **** 		#endif
2609:../FreeRTOS/tasks.c **** 
2610:../FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3678              		.loc 1 2610 0
 3679 0058 7B68     		ldr	r3, [r7, #4]
 3680 005a 1A68     		ldr	r2, [r3]
 3681 005c 164B     		ldr	r3, .L258+4
 3682 005e 1B68     		ldr	r3, [r3]
 3683 0060 9A42     		cmp	r2, r3
 3684 0062 07D0     		beq	.L255
 3685              		.loc 1 2610 0 is_stmt 0 discriminator 1
 3686 0064 7B68     		ldr	r3, [r7, #4]
 3687 0066 5A68     		ldr	r2, [r3, #4]
 3688 0068 3B69     		ldr	r3, [r7, #16]
 3689 006a 9A42     		cmp	r2, r3
 3690 006c 02D8     		bhi	.L255
2611:../FreeRTOS/tasks.c **** 		{
2612:../FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2613:../FreeRTOS/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2614:../FreeRTOS/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2615:../FreeRTOS/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2616:../FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 3691              		.loc 1 2616 0 is_stmt 1
 3692 006e 0123     		movs	r3, #1
 3693 0070 7B61     		str	r3, [r7, #20]
 3694 0072 18E0     		b	.L254
 3695              	.L255:
2617:../FreeRTOS/tasks.c **** 		}
2618:../FreeRTOS/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 3696              		.loc 1 2618 0
 3697 0074 7B68     		ldr	r3, [r7, #4]
 3698 0076 5B68     		ldr	r3, [r3, #4]
 3699 0078 3A69     		ldr	r2, [r7, #16]
 3700 007a D21A     		subs	r2, r2, r3
 3701 007c 3B68     		ldr	r3, [r7]
 3702 007e 1B68     		ldr	r3, [r3]
 3703 0080 9A42     		cmp	r2, r3
 3704 0082 0ED2     		bcs	.L256
2619:../FreeRTOS/tasks.c **** 		{
2620:../FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2621:../FreeRTOS/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 3705              		.loc 1 2621 0
 3706 0084 3B68     		ldr	r3, [r7]
 3707 0086 1A68     		ldr	r2, [r3]
 3708 0088 7B68     		ldr	r3, [r7, #4]
 3709 008a 5968     		ldr	r1, [r3, #4]
 3710 008c 3B69     		ldr	r3, [r7, #16]
 3711 008e CB1A     		subs	r3, r1, r3
 3712 0090 1A44     		add	r2, r2, r3
 3713 0092 3B68     		ldr	r3, [r7]
 3714 0094 1A60     		str	r2, [r3]
2622:../FreeRTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3715              		.loc 1 2622 0
 3716 0096 7868     		ldr	r0, [r7, #4]
 3717 0098 FFF7FEFF 		bl	vTaskSetTimeOutState
2623:../FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 3718              		.loc 1 2623 0
 3719 009c 0023     		movs	r3, #0
 3720 009e 7B61     		str	r3, [r7, #20]
 3721 00a0 01E0     		b	.L254
 3722              	.L256:
2624:../FreeRTOS/tasks.c **** 		}
2625:../FreeRTOS/tasks.c **** 		else
2626:../FreeRTOS/tasks.c **** 		{
2627:../FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 3723              		.loc 1 2627 0
 3724 00a2 0123     		movs	r3, #1
 3725 00a4 7B61     		str	r3, [r7, #20]
 3726              	.L254:
 3727              	.LBE177:
2628:../FreeRTOS/tasks.c **** 		}
2629:../FreeRTOS/tasks.c **** 	}
2630:../FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 3728              		.loc 1 2630 0
 3729 00a6 FFF7FEFF 		bl	vPortExitCritical
2631:../FreeRTOS/tasks.c **** 
2632:../FreeRTOS/tasks.c **** 	return xReturn;
 3730              		.loc 1 2632 0
 3731 00aa 7B69     		ldr	r3, [r7, #20]
2633:../FreeRTOS/tasks.c **** }
 3732              		.loc 1 2633 0
 3733 00ac 1846     		mov	r0, r3
 3734 00ae 1837     		adds	r7, r7, #24
 3735              		.cfi_def_cfa_offset 8
 3736 00b0 BD46     		mov	sp, r7
 3737              		.cfi_def_cfa_register 13
 3738              		@ sp needed
 3739 00b2 80BD     		pop	{r7, pc}
 3740              	.L259:
 3741              		.align	2
 3742              	.L258:
 3743 00b4 00000000 		.word	xTickCount
 3744 00b8 00000000 		.word	xNumOfOverflows
 3745              		.cfi_endproc
 3746              	.LFE31:
 3748              		.section	.text.vTaskMissedYield,"ax",%progbits
 3749              		.align	2
 3750              		.global	vTaskMissedYield
 3751              		.thumb
 3752              		.thumb_func
 3754              	vTaskMissedYield:
 3755              	.LFB32:
2634:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2635:../FreeRTOS/tasks.c **** 
2636:../FreeRTOS/tasks.c **** void vTaskMissedYield( void )
2637:../FreeRTOS/tasks.c **** {
 3756              		.loc 1 2637 0
 3757              		.cfi_startproc
 3758              		@ args = 0, pretend = 0, frame = 0
 3759              		@ frame_needed = 1, uses_anonymous_args = 0
 3760              		@ link register save eliminated.
 3761 0000 80B4     		push	{r7}
 3762              		.cfi_def_cfa_offset 4
 3763              		.cfi_offset 7, -4
 3764 0002 00AF     		add	r7, sp, #0
 3765              		.cfi_def_cfa_register 7
2638:../FreeRTOS/tasks.c **** 	xYieldPending = pdTRUE;
 3766              		.loc 1 2638 0
 3767 0004 034B     		ldr	r3, .L261
 3768 0006 0122     		movs	r2, #1
 3769 0008 1A60     		str	r2, [r3]
2639:../FreeRTOS/tasks.c **** }
 3770              		.loc 1 2639 0
 3771 000a BD46     		mov	sp, r7
 3772              		.cfi_def_cfa_register 13
 3773              		@ sp needed
 3774 000c 5DF8047B 		ldr	r7, [sp], #4
 3775              		.cfi_restore 7
 3776              		.cfi_def_cfa_offset 0
 3777 0010 7047     		bx	lr
 3778              	.L262:
 3779 0012 00BF     		.align	2
 3780              	.L261:
 3781 0014 00000000 		.word	xYieldPending
 3782              		.cfi_endproc
 3783              	.LFE32:
 3785              		.section	.text.prvIdleTask,"ax",%progbits
 3786              		.align	2
 3787              		.thumb
 3788              		.thumb_func
 3790              	prvIdleTask:
 3791              	.LFB33:
2640:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2641:../FreeRTOS/tasks.c **** 
2642:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2643:../FreeRTOS/tasks.c **** 
2644:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2645:../FreeRTOS/tasks.c **** 	{
2646:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
2647:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2648:../FreeRTOS/tasks.c **** 
2649:../FreeRTOS/tasks.c **** 		if( xTask != NULL )
2650:../FreeRTOS/tasks.c **** 		{
2651:../FreeRTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2652:../FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2653:../FreeRTOS/tasks.c **** 		}
2654:../FreeRTOS/tasks.c **** 		else
2655:../FreeRTOS/tasks.c **** 		{
2656:../FreeRTOS/tasks.c **** 			uxReturn = 0U;
2657:../FreeRTOS/tasks.c **** 		}
2658:../FreeRTOS/tasks.c **** 
2659:../FreeRTOS/tasks.c **** 		return uxReturn;
2660:../FreeRTOS/tasks.c **** 	}
2661:../FreeRTOS/tasks.c **** 
2662:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2663:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2664:../FreeRTOS/tasks.c **** 
2665:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2666:../FreeRTOS/tasks.c **** 
2667:../FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2668:../FreeRTOS/tasks.c **** 	{
2669:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2670:../FreeRTOS/tasks.c **** 
2671:../FreeRTOS/tasks.c **** 		if( xTask != NULL )
2672:../FreeRTOS/tasks.c **** 		{
2673:../FreeRTOS/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2674:../FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2675:../FreeRTOS/tasks.c **** 		}
2676:../FreeRTOS/tasks.c **** 	}
2677:../FreeRTOS/tasks.c **** 
2678:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2679:../FreeRTOS/tasks.c **** 
2680:../FreeRTOS/tasks.c **** /*
2681:../FreeRTOS/tasks.c ****  * -----------------------------------------------------------
2682:../FreeRTOS/tasks.c ****  * The Idle task.
2683:../FreeRTOS/tasks.c ****  * ----------------------------------------------------------
2684:../FreeRTOS/tasks.c ****  *
2685:../FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2686:../FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2687:../FreeRTOS/tasks.c ****  *
2688:../FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
2689:../FreeRTOS/tasks.c ****  *
2690:../FreeRTOS/tasks.c ****  */
2691:../FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2692:../FreeRTOS/tasks.c **** {
 3792              		.loc 1 2692 0
 3793              		.cfi_startproc
 3794              		@ args = 0, pretend = 0, frame = 8
 3795              		@ frame_needed = 1, uses_anonymous_args = 0
 3796 0000 80B5     		push	{r7, lr}
 3797              		.cfi_def_cfa_offset 8
 3798              		.cfi_offset 7, -8
 3799              		.cfi_offset 14, -4
 3800 0002 82B0     		sub	sp, sp, #8
 3801              		.cfi_def_cfa_offset 16
 3802 0004 00AF     		add	r7, sp, #0
 3803              		.cfi_def_cfa_register 7
 3804 0006 7860     		str	r0, [r7, #4]
 3805              	.L264:
2693:../FreeRTOS/tasks.c **** 	/* Stop warnings. */
2694:../FreeRTOS/tasks.c **** 	( void ) pvParameters;
2695:../FreeRTOS/tasks.c **** 
2696:../FreeRTOS/tasks.c **** 	for( ;; )
2697:../FreeRTOS/tasks.c **** 	{
2698:../FreeRTOS/tasks.c **** 		/* See if any tasks have been deleted. */
2699:../FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 3806              		.loc 1 2699 0 discriminator 1
 3807 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
2700:../FreeRTOS/tasks.c **** 
2701:../FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2702:../FreeRTOS/tasks.c **** 		{
2703:../FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2704:../FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
2705:../FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
2706:../FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
2707:../FreeRTOS/tasks.c **** 			taskYIELD();
 3808              		.loc 1 2707 0 discriminator 1
 3809 000c 044B     		ldr	r3, .L265
 3810 000e 4FF08052 		mov	r2, #268435456
 3811 0012 1A60     		str	r2, [r3]
 3812              	@ 2707 "../FreeRTOS/tasks.c" 1
 3813 0014 BFF34F8F 		dsb
 3814              	@ 0 "" 2
 3815              	@ 2707 "../FreeRTOS/tasks.c" 1
 3816 0018 BFF36F8F 		isb
 3817              	@ 0 "" 2
2708:../FreeRTOS/tasks.c **** 		}
2709:../FreeRTOS/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2710:../FreeRTOS/tasks.c **** 
2711:../FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2712:../FreeRTOS/tasks.c **** 		{
2713:../FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
2714:../FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2715:../FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
2716:../FreeRTOS/tasks.c **** 			timeslice.
2717:../FreeRTOS/tasks.c **** 
2718:../FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
2719:../FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2720:../FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
2721:../FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
2722:../FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
2723:../FreeRTOS/tasks.c **** 			{
2724:../FreeRTOS/tasks.c **** 				taskYIELD();
2725:../FreeRTOS/tasks.c **** 			}
2726:../FreeRTOS/tasks.c **** 			else
2727:../FreeRTOS/tasks.c **** 			{
2728:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2729:../FreeRTOS/tasks.c **** 			}
2730:../FreeRTOS/tasks.c **** 		}
2731:../FreeRTOS/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2732:../FreeRTOS/tasks.c **** 
2733:../FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2734:../FreeRTOS/tasks.c **** 		{
2735:../FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
2736:../FreeRTOS/tasks.c **** 
2737:../FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2738:../FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
2739:../FreeRTOS/tasks.c **** 			without the overhead of a separate task.
2740:../FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2741:../FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2742:../FreeRTOS/tasks.c **** 			vApplicationIdleHook();
2743:../FreeRTOS/tasks.c **** 		}
2744:../FreeRTOS/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2745:../FreeRTOS/tasks.c **** 
2746:../FreeRTOS/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2747:../FreeRTOS/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2748:../FreeRTOS/tasks.c **** 		user defined low power mode	implementations require
2749:../FreeRTOS/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2750:../FreeRTOS/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2751:../FreeRTOS/tasks.c **** 		{
2752:../FreeRTOS/tasks.c **** 		TickType_t xExpectedIdleTime;
2753:../FreeRTOS/tasks.c **** 
2754:../FreeRTOS/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2755:../FreeRTOS/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2756:../FreeRTOS/tasks.c **** 			test of the expected idle time is performed without the
2757:../FreeRTOS/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2758:../FreeRTOS/tasks.c **** 			valid. */
2759:../FreeRTOS/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2760:../FreeRTOS/tasks.c **** 
2761:../FreeRTOS/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2762:../FreeRTOS/tasks.c **** 			{
2763:../FreeRTOS/tasks.c **** 				vTaskSuspendAll();
2764:../FreeRTOS/tasks.c **** 				{
2765:../FreeRTOS/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2766:../FreeRTOS/tasks.c **** 					time can be sampled again, and this time its value can
2767:../FreeRTOS/tasks.c **** 					be used. */
2768:../FreeRTOS/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2769:../FreeRTOS/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2770:../FreeRTOS/tasks.c **** 
2771:../FreeRTOS/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2772:../FreeRTOS/tasks.c **** 					{
2773:../FreeRTOS/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2774:../FreeRTOS/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2775:../FreeRTOS/tasks.c **** 						traceLOW_POWER_IDLE_END();
2776:../FreeRTOS/tasks.c **** 					}
2777:../FreeRTOS/tasks.c **** 					else
2778:../FreeRTOS/tasks.c **** 					{
2779:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2780:../FreeRTOS/tasks.c **** 					}
2781:../FreeRTOS/tasks.c **** 				}
2782:../FreeRTOS/tasks.c **** 				( void ) xTaskResumeAll();
2783:../FreeRTOS/tasks.c **** 			}
2784:../FreeRTOS/tasks.c **** 			else
2785:../FreeRTOS/tasks.c **** 			{
2786:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2787:../FreeRTOS/tasks.c **** 			}
2788:../FreeRTOS/tasks.c **** 		}
2789:../FreeRTOS/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2790:../FreeRTOS/tasks.c **** 	}
 3818              		.loc 1 2790 0 discriminator 1
 3819              		.thumb
 3820 001c F4E7     		b	.L264
 3821              	.L266:
 3822 001e 00BF     		.align	2
 3823              	.L265:
 3824 0020 04ED00E0 		.word	-536810236
 3825              		.cfi_endproc
 3826              	.LFE33:
 3828              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 3829              		.align	2
 3830              		.thumb
 3831              		.thumb_func
 3833              	prvInitialiseTCBVariables:
 3834              	.LFB34:
2791:../FreeRTOS/tasks.c **** }
2792:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2793:../FreeRTOS/tasks.c **** 
2794:../FreeRTOS/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
2795:../FreeRTOS/tasks.c **** 
2796:../FreeRTOS/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2797:../FreeRTOS/tasks.c **** 	{
2798:../FreeRTOS/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
2799:../FreeRTOS/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
2800:../FreeRTOS/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2801:../FreeRTOS/tasks.c **** 
2802:../FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2803:../FreeRTOS/tasks.c **** 		{
2804:../FreeRTOS/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2805:../FreeRTOS/tasks.c **** 			eReturn = eAbortSleep;
2806:../FreeRTOS/tasks.c **** 		}
2807:../FreeRTOS/tasks.c **** 		else if( xYieldPending != pdFALSE )
2808:../FreeRTOS/tasks.c **** 		{
2809:../FreeRTOS/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2810:../FreeRTOS/tasks.c **** 			eReturn = eAbortSleep;
2811:../FreeRTOS/tasks.c **** 		}
2812:../FreeRTOS/tasks.c **** 		else
2813:../FreeRTOS/tasks.c **** 		{
2814:../FreeRTOS/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
2815:../FreeRTOS/tasks.c **** 			have an infinite block time rather than actually being suspended)
2816:../FreeRTOS/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
2817:../FreeRTOS/tasks.c **** 			interrupts. */
2818:../FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
2819:../FreeRTOS/tasks.c **** 			{
2820:../FreeRTOS/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
2821:../FreeRTOS/tasks.c **** 			}
2822:../FreeRTOS/tasks.c **** 			else
2823:../FreeRTOS/tasks.c **** 			{
2824:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2825:../FreeRTOS/tasks.c **** 			}
2826:../FreeRTOS/tasks.c **** 		}
2827:../FreeRTOS/tasks.c **** 
2828:../FreeRTOS/tasks.c **** 		return eReturn;
2829:../FreeRTOS/tasks.c **** 	}
2830:../FreeRTOS/tasks.c **** 
2831:../FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2832:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2833:../FreeRTOS/tasks.c **** 
2834:../FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2835:../FreeRTOS/tasks.c **** {
 3835              		.loc 1 2835 0
 3836              		.cfi_startproc
 3837              		@ args = 4, pretend = 0, frame = 24
 3838              		@ frame_needed = 1, uses_anonymous_args = 0
 3839 0000 80B5     		push	{r7, lr}
 3840              		.cfi_def_cfa_offset 8
 3841              		.cfi_offset 7, -8
 3842              		.cfi_offset 14, -4
 3843 0002 86B0     		sub	sp, sp, #24
 3844              		.cfi_def_cfa_offset 32
 3845 0004 00AF     		add	r7, sp, #0
 3846              		.cfi_def_cfa_register 7
 3847 0006 F860     		str	r0, [r7, #12]
 3848 0008 B960     		str	r1, [r7, #8]
 3849 000a 7A60     		str	r2, [r7, #4]
 3850 000c 3B60     		str	r3, [r7]
2836:../FreeRTOS/tasks.c **** UBaseType_t x;
2837:../FreeRTOS/tasks.c **** 
2838:../FreeRTOS/tasks.c **** 	/* Store the task name in the TCB. */
2839:../FreeRTOS/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 3851              		.loc 1 2839 0
 3852 000e 0023     		movs	r3, #0
 3853 0010 7B61     		str	r3, [r7, #20]
 3854 0012 13E0     		b	.L268
 3855              	.L271:
2840:../FreeRTOS/tasks.c **** 	{
2841:../FreeRTOS/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 3856              		.loc 1 2841 0
 3857 0014 BA68     		ldr	r2, [r7, #8]
 3858 0016 7B69     		ldr	r3, [r7, #20]
 3859 0018 1344     		add	r3, r3, r2
 3860 001a 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 3861 001c FA68     		ldr	r2, [r7, #12]
 3862 001e 7B69     		ldr	r3, [r7, #20]
 3863 0020 1344     		add	r3, r3, r2
 3864 0022 3033     		adds	r3, r3, #48
 3865 0024 0A46     		mov	r2, r1
 3866 0026 1A71     		strb	r2, [r3, #4]
2842:../FreeRTOS/tasks.c **** 
2843:../FreeRTOS/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2844:../FreeRTOS/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2845:../FreeRTOS/tasks.c **** 		string is not accessible (extremely unlikely). */
2846:../FreeRTOS/tasks.c **** 		if( pcName[ x ] == 0x00 )
 3867              		.loc 1 2846 0
 3868 0028 BA68     		ldr	r2, [r7, #8]
 3869 002a 7B69     		ldr	r3, [r7, #20]
 3870 002c 1344     		add	r3, r3, r2
 3871 002e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3872 0030 002B     		cmp	r3, #0
 3873 0032 00D1     		bne	.L269
2847:../FreeRTOS/tasks.c **** 		{
2848:../FreeRTOS/tasks.c **** 			break;
 3874              		.loc 1 2848 0
 3875 0034 05E0     		b	.L270
 3876              	.L269:
2839:../FreeRTOS/tasks.c **** 	{
 3877              		.loc 1 2839 0 discriminator 2
 3878 0036 7B69     		ldr	r3, [r7, #20]
 3879 0038 0133     		adds	r3, r3, #1
 3880 003a 7B61     		str	r3, [r7, #20]
 3881              	.L268:
2839:../FreeRTOS/tasks.c **** 	{
 3882              		.loc 1 2839 0 is_stmt 0 discriminator 1
 3883 003c 7B69     		ldr	r3, [r7, #20]
 3884 003e 232B     		cmp	r3, #35
 3885 0040 E8D9     		bls	.L271
 3886              	.L270:
2849:../FreeRTOS/tasks.c **** 		}
2850:../FreeRTOS/tasks.c **** 		else
2851:../FreeRTOS/tasks.c **** 		{
2852:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2853:../FreeRTOS/tasks.c **** 		}
2854:../FreeRTOS/tasks.c **** 	}
2855:../FreeRTOS/tasks.c **** 
2856:../FreeRTOS/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2857:../FreeRTOS/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2858:../FreeRTOS/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 3887              		.loc 1 2858 0 is_stmt 1
 3888 0042 FB68     		ldr	r3, [r7, #12]
 3889 0044 0022     		movs	r2, #0
 3890 0046 83F85720 		strb	r2, [r3, #87]
2859:../FreeRTOS/tasks.c **** 
2860:../FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2861:../FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
2862:../FreeRTOS/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 3891              		.loc 1 2862 0
 3892 004a 7B68     		ldr	r3, [r7, #4]
 3893 004c 072B     		cmp	r3, #7
 3894 004e 01D9     		bls	.L272
2863:../FreeRTOS/tasks.c **** 	{
2864:../FreeRTOS/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 3895              		.loc 1 2864 0
 3896 0050 0723     		movs	r3, #7
 3897 0052 7B60     		str	r3, [r7, #4]
 3898              	.L272:
2865:../FreeRTOS/tasks.c **** 	}
2866:../FreeRTOS/tasks.c **** 	else
2867:../FreeRTOS/tasks.c **** 	{
2868:../FreeRTOS/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2869:../FreeRTOS/tasks.c **** 	}
2870:../FreeRTOS/tasks.c **** 
2871:../FreeRTOS/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3899              		.loc 1 2871 0
 3900 0054 FB68     		ldr	r3, [r7, #12]
 3901 0056 7A68     		ldr	r2, [r7, #4]
 3902 0058 DA62     		str	r2, [r3, #44]
2872:../FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2873:../FreeRTOS/tasks.c **** 	{
2874:../FreeRTOS/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3903              		.loc 1 2874 0
 3904 005a FB68     		ldr	r3, [r7, #12]
 3905 005c 7A68     		ldr	r2, [r7, #4]
 3906 005e 9A65     		str	r2, [r3, #88]
2875:../FreeRTOS/tasks.c **** 		pxTCB->uxMutexesHeld = 0;
 3907              		.loc 1 2875 0
 3908 0060 FB68     		ldr	r3, [r7, #12]
 3909 0062 0022     		movs	r2, #0
 3910 0064 DA65     		str	r2, [r3, #92]
2876:../FreeRTOS/tasks.c **** 	}
2877:../FreeRTOS/tasks.c **** 	#endif /* configUSE_MUTEXES */
2878:../FreeRTOS/tasks.c **** 
2879:../FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3911              		.loc 1 2879 0
 3912 0066 FB68     		ldr	r3, [r7, #12]
 3913 0068 0433     		adds	r3, r3, #4
 3914 006a 1846     		mov	r0, r3
 3915 006c FFF7FEFF 		bl	vListInitialiseItem
2880:../FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3916              		.loc 1 2880 0
 3917 0070 FB68     		ldr	r3, [r7, #12]
 3918 0072 1833     		adds	r3, r3, #24
 3919 0074 1846     		mov	r0, r3
 3920 0076 FFF7FEFF 		bl	vListInitialiseItem
2881:../FreeRTOS/tasks.c **** 
2882:../FreeRTOS/tasks.c **** 	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2883:../FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2884:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3921              		.loc 1 2884 0
 3922 007a FB68     		ldr	r3, [r7, #12]
 3923 007c FA68     		ldr	r2, [r7, #12]
 3924 007e 1A61     		str	r2, [r3, #16]
2885:../FreeRTOS/tasks.c **** 
2886:../FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
2887:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
 3925              		.loc 1 2887 0
 3926 0080 7B68     		ldr	r3, [r7, #4]
 3927 0082 C3F10802 		rsb	r2, r3, #8
 3928 0086 FB68     		ldr	r3, [r7, #12]
 3929 0088 9A61     		str	r2, [r3, #24]
2888:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3930              		.loc 1 2888 0
 3931 008a FB68     		ldr	r3, [r7, #12]
 3932 008c FA68     		ldr	r2, [r7, #12]
 3933 008e 5A62     		str	r2, [r3, #36]
2889:../FreeRTOS/tasks.c **** 
2890:../FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2891:../FreeRTOS/tasks.c **** 	{
2892:../FreeRTOS/tasks.c **** 		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2893:../FreeRTOS/tasks.c **** 	}
2894:../FreeRTOS/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2895:../FreeRTOS/tasks.c **** 
2896:../FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2897:../FreeRTOS/tasks.c **** 	{
2898:../FreeRTOS/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2899:../FreeRTOS/tasks.c **** 	}
2900:../FreeRTOS/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2901:../FreeRTOS/tasks.c **** 
2902:../FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2903:../FreeRTOS/tasks.c **** 	{
2904:../FreeRTOS/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2905:../FreeRTOS/tasks.c **** 	}
2906:../FreeRTOS/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2907:../FreeRTOS/tasks.c **** 
2908:../FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2909:../FreeRTOS/tasks.c **** 	{
2910:../FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2911:../FreeRTOS/tasks.c **** 	}
2912:../FreeRTOS/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2913:../FreeRTOS/tasks.c **** 	{
2914:../FreeRTOS/tasks.c **** 		( void ) xRegions;
2915:../FreeRTOS/tasks.c **** 		( void ) usStackDepth;
2916:../FreeRTOS/tasks.c **** 	}
2917:../FreeRTOS/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2918:../FreeRTOS/tasks.c **** 
2919:../FreeRTOS/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2920:../FreeRTOS/tasks.c **** 	{
2921:../FreeRTOS/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
2922:../FreeRTOS/tasks.c **** 		{
2923:../FreeRTOS/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
2924:../FreeRTOS/tasks.c **** 		}
2925:../FreeRTOS/tasks.c **** 	}
2926:../FreeRTOS/tasks.c **** 	#endif
2927:../FreeRTOS/tasks.c **** 
2928:../FreeRTOS/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
2929:../FreeRTOS/tasks.c **** 	{
2930:../FreeRTOS/tasks.c **** 		pxTCB->ulNotifiedValue = 0;
 3934              		.loc 1 2930 0
 3935 0090 FB68     		ldr	r3, [r7, #12]
 3936 0092 0022     		movs	r2, #0
 3937 0094 1A66     		str	r2, [r3, #96]
2931:../FreeRTOS/tasks.c **** 		pxTCB->eNotifyState = eNotWaitingNotification;
 3938              		.loc 1 2931 0
 3939 0096 FB68     		ldr	r3, [r7, #12]
 3940 0098 0022     		movs	r2, #0
 3941 009a 83F86420 		strb	r2, [r3, #100]
2932:../FreeRTOS/tasks.c **** 	}
2933:../FreeRTOS/tasks.c **** 	#endif
2934:../FreeRTOS/tasks.c **** 
2935:../FreeRTOS/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2936:../FreeRTOS/tasks.c **** 	{
2937:../FreeRTOS/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2938:../FreeRTOS/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2939:../FreeRTOS/tasks.c **** 	}
2940:../FreeRTOS/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2941:../FreeRTOS/tasks.c **** }
 3942              		.loc 1 2941 0
 3943 009e 1837     		adds	r7, r7, #24
 3944              		.cfi_def_cfa_offset 8
 3945 00a0 BD46     		mov	sp, r7
 3946              		.cfi_def_cfa_register 13
 3947              		@ sp needed
 3948 00a2 80BD     		pop	{r7, pc}
 3949              		.cfi_endproc
 3950              	.LFE34:
 3952              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3953              		.align	2
 3954              		.thumb
 3955              		.thumb_func
 3957              	prvInitialiseTaskLists:
 3958              	.LFB35:
2942:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2943:../FreeRTOS/tasks.c **** 
2944:../FreeRTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2945:../FreeRTOS/tasks.c **** 
2946:../FreeRTOS/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
2947:../FreeRTOS/tasks.c **** 	{
2948:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2949:../FreeRTOS/tasks.c **** 
2950:../FreeRTOS/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2951:../FreeRTOS/tasks.c **** 		{
2952:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2953:../FreeRTOS/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2954:../FreeRTOS/tasks.c **** 		}
2955:../FreeRTOS/tasks.c **** 	}
2956:../FreeRTOS/tasks.c **** 
2957:../FreeRTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2958:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2959:../FreeRTOS/tasks.c **** 
2960:../FreeRTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2961:../FreeRTOS/tasks.c **** 
2962:../FreeRTOS/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2963:../FreeRTOS/tasks.c **** 	{
2964:../FreeRTOS/tasks.c **** 	void *pvReturn = NULL;
2965:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2966:../FreeRTOS/tasks.c **** 
2967:../FreeRTOS/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2968:../FreeRTOS/tasks.c **** 		{
2969:../FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2970:../FreeRTOS/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
2971:../FreeRTOS/tasks.c **** 		}
2972:../FreeRTOS/tasks.c **** 		else
2973:../FreeRTOS/tasks.c **** 		{
2974:../FreeRTOS/tasks.c **** 			pvReturn = NULL;
2975:../FreeRTOS/tasks.c **** 		}
2976:../FreeRTOS/tasks.c **** 
2977:../FreeRTOS/tasks.c **** 		return pvReturn;
2978:../FreeRTOS/tasks.c **** 	}
2979:../FreeRTOS/tasks.c **** 
2980:../FreeRTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2981:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2982:../FreeRTOS/tasks.c **** 
2983:../FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2984:../FreeRTOS/tasks.c **** 
2985:../FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2986:../FreeRTOS/tasks.c **** 	{
2987:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
2988:../FreeRTOS/tasks.c **** 
2989:../FreeRTOS/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
2990:../FreeRTOS/tasks.c **** 		the calling task. */
2991:../FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2992:../FreeRTOS/tasks.c **** 
2993:../FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2994:../FreeRTOS/tasks.c **** 	}
2995:../FreeRTOS/tasks.c **** 
2996:../FreeRTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2997:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2998:../FreeRTOS/tasks.c **** 
2999:../FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
3000:../FreeRTOS/tasks.c **** {
 3959              		.loc 1 3000 0
 3960              		.cfi_startproc
 3961              		@ args = 0, pretend = 0, frame = 8
 3962              		@ frame_needed = 1, uses_anonymous_args = 0
 3963 0000 80B5     		push	{r7, lr}
 3964              		.cfi_def_cfa_offset 8
 3965              		.cfi_offset 7, -8
 3966              		.cfi_offset 14, -4
 3967 0002 82B0     		sub	sp, sp, #8
 3968              		.cfi_def_cfa_offset 16
 3969 0004 00AF     		add	r7, sp, #0
 3970              		.cfi_def_cfa_register 7
3001:../FreeRTOS/tasks.c **** UBaseType_t uxPriority;
3002:../FreeRTOS/tasks.c **** 
3003:../FreeRTOS/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3971              		.loc 1 3003 0
 3972 0006 0023     		movs	r3, #0
 3973 0008 7B60     		str	r3, [r7, #4]
 3974 000a 0CE0     		b	.L274
 3975              	.L275:
3004:../FreeRTOS/tasks.c **** 	{
3005:../FreeRTOS/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3976              		.loc 1 3005 0 discriminator 3
 3977 000c 7A68     		ldr	r2, [r7, #4]
 3978 000e 1346     		mov	r3, r2
 3979 0010 9B00     		lsls	r3, r3, #2
 3980 0012 1344     		add	r3, r3, r2
 3981 0014 9B00     		lsls	r3, r3, #2
 3982 0016 114A     		ldr	r2, .L276
 3983 0018 1344     		add	r3, r3, r2
 3984 001a 1846     		mov	r0, r3
 3985 001c FFF7FEFF 		bl	vListInitialise
3003:../FreeRTOS/tasks.c **** 	{
 3986              		.loc 1 3003 0 discriminator 3
 3987 0020 7B68     		ldr	r3, [r7, #4]
 3988 0022 0133     		adds	r3, r3, #1
 3989 0024 7B60     		str	r3, [r7, #4]
 3990              	.L274:
3003:../FreeRTOS/tasks.c **** 	{
 3991              		.loc 1 3003 0 is_stmt 0 discriminator 1
 3992 0026 7B68     		ldr	r3, [r7, #4]
 3993 0028 072B     		cmp	r3, #7
 3994 002a EFD9     		bls	.L275
3006:../FreeRTOS/tasks.c **** 	}
3007:../FreeRTOS/tasks.c **** 
3008:../FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3995              		.loc 1 3008 0 is_stmt 1
 3996 002c 0C48     		ldr	r0, .L276+4
 3997 002e FFF7FEFF 		bl	vListInitialise
3009:../FreeRTOS/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3998              		.loc 1 3009 0
 3999 0032 0C48     		ldr	r0, .L276+8
 4000 0034 FFF7FEFF 		bl	vListInitialise
3010:../FreeRTOS/tasks.c **** 	vListInitialise( &xPendingReadyList );
 4001              		.loc 1 3010 0
 4002 0038 0B48     		ldr	r0, .L276+12
 4003 003a FFF7FEFF 		bl	vListInitialise
3011:../FreeRTOS/tasks.c **** 
3012:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3013:../FreeRTOS/tasks.c **** 	{
3014:../FreeRTOS/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 4004              		.loc 1 3014 0
 4005 003e 0B48     		ldr	r0, .L276+16
 4006 0040 FFF7FEFF 		bl	vListInitialise
3015:../FreeRTOS/tasks.c **** 	}
3016:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3017:../FreeRTOS/tasks.c **** 
3018:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3019:../FreeRTOS/tasks.c **** 	{
3020:../FreeRTOS/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 4007              		.loc 1 3020 0
 4008 0044 0A48     		ldr	r0, .L276+20
 4009 0046 FFF7FEFF 		bl	vListInitialise
3021:../FreeRTOS/tasks.c **** 	}
3022:../FreeRTOS/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3023:../FreeRTOS/tasks.c **** 
3024:../FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3025:../FreeRTOS/tasks.c **** 	using list2. */
3026:../FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 4010              		.loc 1 3026 0
 4011 004a 0A4B     		ldr	r3, .L276+24
 4012 004c 044A     		ldr	r2, .L276+4
 4013 004e 1A60     		str	r2, [r3]
3027:../FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 4014              		.loc 1 3027 0
 4015 0050 094B     		ldr	r3, .L276+28
 4016 0052 044A     		ldr	r2, .L276+8
 4017 0054 1A60     		str	r2, [r3]
3028:../FreeRTOS/tasks.c **** }
 4018              		.loc 1 3028 0
 4019 0056 0837     		adds	r7, r7, #8
 4020              		.cfi_def_cfa_offset 8
 4021 0058 BD46     		mov	sp, r7
 4022              		.cfi_def_cfa_register 13
 4023              		@ sp needed
 4024 005a 80BD     		pop	{r7, pc}
 4025              	.L277:
 4026              		.align	2
 4027              	.L276:
 4028 005c 00000000 		.word	pxReadyTasksLists
 4029 0060 00000000 		.word	xDelayedTaskList1
 4030 0064 00000000 		.word	xDelayedTaskList2
 4031 0068 00000000 		.word	xPendingReadyList
 4032 006c 00000000 		.word	xTasksWaitingTermination
 4033 0070 00000000 		.word	xSuspendedTaskList
 4034 0074 00000000 		.word	pxDelayedTaskList
 4035 0078 00000000 		.word	pxOverflowDelayedTaskList
 4036              		.cfi_endproc
 4037              	.LFE35:
 4039              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 4040              		.align	2
 4041              		.thumb
 4042              		.thumb_func
 4044              	prvCheckTasksWaitingTermination:
 4045              	.LFB36:
3029:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3030:../FreeRTOS/tasks.c **** 
3031:../FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3032:../FreeRTOS/tasks.c **** {
 4046              		.loc 1 3032 0
 4047              		.cfi_startproc
 4048              		@ args = 0, pretend = 0, frame = 8
 4049              		@ frame_needed = 1, uses_anonymous_args = 0
 4050 0000 80B5     		push	{r7, lr}
 4051              		.cfi_def_cfa_offset 8
 4052              		.cfi_offset 7, -8
 4053              		.cfi_offset 14, -4
 4054 0002 82B0     		sub	sp, sp, #8
 4055              		.cfi_def_cfa_offset 16
 4056 0004 00AF     		add	r7, sp, #0
 4057              		.cfi_def_cfa_register 7
 4058              	.LBB178:
3033:../FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3034:../FreeRTOS/tasks.c **** 	{
3035:../FreeRTOS/tasks.c **** 		BaseType_t xListIsEmpty;
3036:../FreeRTOS/tasks.c **** 
3037:../FreeRTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3038:../FreeRTOS/tasks.c **** 		too often in the idle task. */
3039:../FreeRTOS/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 4059              		.loc 1 3039 0
 4060 0006 28E0     		b	.L279
 4061              	.L280:
3040:../FreeRTOS/tasks.c **** 		{
3041:../FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 4062              		.loc 1 3041 0
 4063 0008 FFF7FEFF 		bl	vTaskSuspendAll
3042:../FreeRTOS/tasks.c **** 			{
3043:../FreeRTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 4064              		.loc 1 3043 0
 4065 000c 164B     		ldr	r3, .L281
 4066 000e 1B68     		ldr	r3, [r3]
 4067 0010 002B     		cmp	r3, #0
 4068 0012 0CBF     		ite	eq
 4069 0014 0123     		moveq	r3, #1
 4070 0016 0023     		movne	r3, #0
 4071 0018 DBB2     		uxtb	r3, r3
 4072 001a 7B60     		str	r3, [r7, #4]
3044:../FreeRTOS/tasks.c **** 			}
3045:../FreeRTOS/tasks.c **** 			( void ) xTaskResumeAll();
 4073              		.loc 1 3045 0
 4074 001c FFF7FEFF 		bl	xTaskResumeAll
3046:../FreeRTOS/tasks.c **** 
3047:../FreeRTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 4075              		.loc 1 3047 0
 4076 0020 7B68     		ldr	r3, [r7, #4]
 4077 0022 002B     		cmp	r3, #0
 4078 0024 19D1     		bne	.L279
 4079              	.LBB179:
3048:../FreeRTOS/tasks.c **** 			{
3049:../FreeRTOS/tasks.c **** 				TCB_t *pxTCB;
3050:../FreeRTOS/tasks.c **** 
3051:../FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 4080              		.loc 1 3051 0
 4081 0026 FFF7FEFF 		bl	vPortEnterCritical
3052:../FreeRTOS/tasks.c **** 				{
3053:../FreeRTOS/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 4082              		.loc 1 3053 0
 4083 002a 0F4B     		ldr	r3, .L281
 4084 002c DB68     		ldr	r3, [r3, #12]
 4085 002e DB68     		ldr	r3, [r3, #12]
 4086 0030 3B60     		str	r3, [r7]
3054:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 4087              		.loc 1 3054 0
 4088 0032 3B68     		ldr	r3, [r7]
 4089 0034 0433     		adds	r3, r3, #4
 4090 0036 1846     		mov	r0, r3
 4091 0038 FFF7FEFF 		bl	uxListRemove
3055:../FreeRTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
 4092              		.loc 1 3055 0
 4093 003c 0B4B     		ldr	r3, .L281+4
 4094 003e 1B68     		ldr	r3, [r3]
 4095 0040 013B     		subs	r3, r3, #1
 4096 0042 0A4A     		ldr	r2, .L281+4
 4097 0044 1360     		str	r3, [r2]
3056:../FreeRTOS/tasks.c **** 					--uxTasksDeleted;
 4098              		.loc 1 3056 0
 4099 0046 0A4B     		ldr	r3, .L281+8
 4100 0048 1B68     		ldr	r3, [r3]
 4101 004a 013B     		subs	r3, r3, #1
 4102 004c 084A     		ldr	r2, .L281+8
 4103 004e 1360     		str	r3, [r2]
3057:../FreeRTOS/tasks.c **** 				}
3058:../FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 4104              		.loc 1 3058 0
 4105 0050 FFF7FEFF 		bl	vPortExitCritical
3059:../FreeRTOS/tasks.c **** 
3060:../FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 4106              		.loc 1 3060 0
 4107 0054 3868     		ldr	r0, [r7]
 4108 0056 FFF7FEFF 		bl	prvDeleteTCB
 4109              	.L279:
 4110              	.LBE179:
3039:../FreeRTOS/tasks.c **** 		{
 4111              		.loc 1 3039 0
 4112 005a 054B     		ldr	r3, .L281+8
 4113 005c 1B68     		ldr	r3, [r3]
 4114 005e 002B     		cmp	r3, #0
 4115 0060 D2D1     		bne	.L280
 4116              	.LBE178:
3061:../FreeRTOS/tasks.c **** 			}
3062:../FreeRTOS/tasks.c **** 			else
3063:../FreeRTOS/tasks.c **** 			{
3064:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3065:../FreeRTOS/tasks.c **** 			}
3066:../FreeRTOS/tasks.c **** 		}
3067:../FreeRTOS/tasks.c **** 	}
3068:../FreeRTOS/tasks.c **** 	#endif /* vTaskDelete */
3069:../FreeRTOS/tasks.c **** }
 4117              		.loc 1 3069 0
 4118 0062 0837     		adds	r7, r7, #8
 4119              		.cfi_def_cfa_offset 8
 4120 0064 BD46     		mov	sp, r7
 4121              		.cfi_def_cfa_register 13
 4122              		@ sp needed
 4123 0066 80BD     		pop	{r7, pc}
 4124              	.L282:
 4125              		.align	2
 4126              	.L281:
 4127 0068 00000000 		.word	xTasksWaitingTermination
 4128 006c 00000000 		.word	uxCurrentNumberOfTasks
 4129 0070 00000000 		.word	uxTasksDeleted
 4130              		.cfi_endproc
 4131              	.LFE36:
 4133              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 4134              		.align	2
 4135              		.thumb
 4136              		.thumb_func
 4138              	prvAddCurrentTaskToDelayedList:
 4139              	.LFB37:
3070:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3071:../FreeRTOS/tasks.c **** 
3072:../FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
3073:../FreeRTOS/tasks.c **** {
 4140              		.loc 1 3073 0
 4141              		.cfi_startproc
 4142              		@ args = 0, pretend = 0, frame = 8
 4143              		@ frame_needed = 1, uses_anonymous_args = 0
 4144 0000 80B5     		push	{r7, lr}
 4145              		.cfi_def_cfa_offset 8
 4146              		.cfi_offset 7, -8
 4147              		.cfi_offset 14, -4
 4148 0002 82B0     		sub	sp, sp, #8
 4149              		.cfi_def_cfa_offset 16
 4150 0004 00AF     		add	r7, sp, #0
 4151              		.cfi_def_cfa_register 7
 4152 0006 7860     		str	r0, [r7, #4]
3074:../FreeRTOS/tasks.c **** 	/* The list item will be inserted in wake time order. */
3075:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 4153              		.loc 1 3075 0
 4154 0008 134B     		ldr	r3, .L286
 4155 000a 1B68     		ldr	r3, [r3]
 4156 000c 7A68     		ldr	r2, [r7, #4]
 4157 000e 5A60     		str	r2, [r3, #4]
3076:../FreeRTOS/tasks.c **** 
3077:../FreeRTOS/tasks.c **** 	if( xTimeToWake < xTickCount )
 4158              		.loc 1 3077 0
 4159 0010 124B     		ldr	r3, .L286+4
 4160 0012 1B68     		ldr	r3, [r3]
 4161 0014 7A68     		ldr	r2, [r7, #4]
 4162 0016 9A42     		cmp	r2, r3
 4163 0018 09D2     		bcs	.L284
3078:../FreeRTOS/tasks.c **** 	{
3079:../FreeRTOS/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
3080:../FreeRTOS/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 4164              		.loc 1 3080 0
 4165 001a 114B     		ldr	r3, .L286+8
 4166 001c 1A68     		ldr	r2, [r3]
 4167 001e 0E4B     		ldr	r3, .L286
 4168 0020 1B68     		ldr	r3, [r3]
 4169 0022 0433     		adds	r3, r3, #4
 4170 0024 1046     		mov	r0, r2
 4171 0026 1946     		mov	r1, r3
 4172 0028 FFF7FEFF 		bl	vListInsert
 4173 002c 10E0     		b	.L283
 4174              	.L284:
3081:../FreeRTOS/tasks.c **** 	}
3082:../FreeRTOS/tasks.c **** 	else
3083:../FreeRTOS/tasks.c **** 	{
3084:../FreeRTOS/tasks.c **** 		/* The wake time has not overflowed, so the current block list is used. */
3085:../FreeRTOS/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 4175              		.loc 1 3085 0
 4176 002e 0D4B     		ldr	r3, .L286+12
 4177 0030 1A68     		ldr	r2, [r3]
 4178 0032 094B     		ldr	r3, .L286
 4179 0034 1B68     		ldr	r3, [r3]
 4180 0036 0433     		adds	r3, r3, #4
 4181 0038 1046     		mov	r0, r2
 4182 003a 1946     		mov	r1, r3
 4183 003c FFF7FEFF 		bl	vListInsert
3086:../FreeRTOS/tasks.c **** 
3087:../FreeRTOS/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
3088:../FreeRTOS/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
3089:../FreeRTOS/tasks.c **** 		too. */
3090:../FreeRTOS/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 4184              		.loc 1 3090 0
 4185 0040 094B     		ldr	r3, .L286+16
 4186 0042 1B68     		ldr	r3, [r3]
 4187 0044 7A68     		ldr	r2, [r7, #4]
 4188 0046 9A42     		cmp	r2, r3
 4189 0048 02D2     		bcs	.L283
3091:../FreeRTOS/tasks.c **** 		{
3092:../FreeRTOS/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 4190              		.loc 1 3092 0
 4191 004a 074A     		ldr	r2, .L286+16
 4192 004c 7B68     		ldr	r3, [r7, #4]
 4193 004e 1360     		str	r3, [r2]
 4194              	.L283:
3093:../FreeRTOS/tasks.c **** 		}
3094:../FreeRTOS/tasks.c **** 		else
3095:../FreeRTOS/tasks.c **** 		{
3096:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3097:../FreeRTOS/tasks.c **** 		}
3098:../FreeRTOS/tasks.c **** 	}
3099:../FreeRTOS/tasks.c **** }
 4195              		.loc 1 3099 0
 4196 0050 0837     		adds	r7, r7, #8
 4197              		.cfi_def_cfa_offset 8
 4198 0052 BD46     		mov	sp, r7
 4199              		.cfi_def_cfa_register 13
 4200              		@ sp needed
 4201 0054 80BD     		pop	{r7, pc}
 4202              	.L287:
 4203 0056 00BF     		.align	2
 4204              	.L286:
 4205 0058 00000000 		.word	pxCurrentTCB
 4206 005c 00000000 		.word	xTickCount
 4207 0060 00000000 		.word	pxOverflowDelayedTaskList
 4208 0064 00000000 		.word	pxDelayedTaskList
 4209 0068 00000000 		.word	xNextTaskUnblockTime
 4210              		.cfi_endproc
 4211              	.LFE37:
 4213              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 4214              		.align	2
 4215              		.thumb
 4216              		.thumb_func
 4218              	prvAllocateTCBAndStack:
 4219              	.LFB38:
3100:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3101:../FreeRTOS/tasks.c **** 
3102:../FreeRTOS/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
3103:../FreeRTOS/tasks.c **** {
 4220              		.loc 1 3103 0
 4221              		.cfi_startproc
 4222              		@ args = 0, pretend = 0, frame = 16
 4223              		@ frame_needed = 1, uses_anonymous_args = 0
 4224 0000 80B5     		push	{r7, lr}
 4225              		.cfi_def_cfa_offset 8
 4226              		.cfi_offset 7, -8
 4227              		.cfi_offset 14, -4
 4228 0002 84B0     		sub	sp, sp, #16
 4229              		.cfi_def_cfa_offset 24
 4230 0004 00AF     		add	r7, sp, #0
 4231              		.cfi_def_cfa_register 7
 4232 0006 0346     		mov	r3, r0
 4233 0008 3960     		str	r1, [r7]
 4234 000a FB80     		strh	r3, [r7, #6]	@ movhi
 4235              	.LBB180:
3104:../FreeRTOS/tasks.c **** TCB_t *pxNewTCB;
3105:../FreeRTOS/tasks.c **** 
3106:../FreeRTOS/tasks.c **** 	/* If the stack grows down then allocate the stack then the TCB so the stack
3107:../FreeRTOS/tasks.c **** 	does not grow into the TCB.  Likewise if the stack grows up then allocate
3108:../FreeRTOS/tasks.c **** 	the TCB then the stack. */
3109:../FreeRTOS/tasks.c **** 	#if( portSTACK_GROWTH > 0 )
3110:../FreeRTOS/tasks.c **** 	{
3111:../FreeRTOS/tasks.c **** 		/* Allocate space for the TCB.  Where the memory comes from depends on
3112:../FreeRTOS/tasks.c **** 		the implementation of the port malloc function. */
3113:../FreeRTOS/tasks.c **** 		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3114:../FreeRTOS/tasks.c **** 
3115:../FreeRTOS/tasks.c **** 		if( pxNewTCB != NULL )
3116:../FreeRTOS/tasks.c **** 		{
3117:../FreeRTOS/tasks.c **** 			/* Allocate space for the stack used by the task being created.
3118:../FreeRTOS/tasks.c **** 			The base of the stack memory stored in the TCB so the task can
3119:../FreeRTOS/tasks.c **** 			be deleted later if required. */
3120:../FreeRTOS/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeo
3121:../FreeRTOS/tasks.c **** 
3122:../FreeRTOS/tasks.c **** 			if( pxNewTCB->pxStack == NULL )
3123:../FreeRTOS/tasks.c **** 			{
3124:../FreeRTOS/tasks.c **** 				/* Could not allocate the stack.  Delete the allocated TCB. */
3125:../FreeRTOS/tasks.c **** 				vPortFree( pxNewTCB );
3126:../FreeRTOS/tasks.c **** 				pxNewTCB = NULL;
3127:../FreeRTOS/tasks.c **** 			}
3128:../FreeRTOS/tasks.c **** 		}
3129:../FreeRTOS/tasks.c **** 	}
3130:../FreeRTOS/tasks.c **** 	#else /* portSTACK_GROWTH */
3131:../FreeRTOS/tasks.c **** 	{
3132:../FreeRTOS/tasks.c **** 	StackType_t *pxStack;
3133:../FreeRTOS/tasks.c **** 
3134:../FreeRTOS/tasks.c **** 		/* Allocate space for the stack used by the task being created. */
3135:../FreeRTOS/tasks.c **** 		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackTyp
 4236              		.loc 1 3135 0
 4237 000c 3B68     		ldr	r3, [r7]
 4238 000e 002B     		cmp	r3, #0
 4239 0010 06D1     		bne	.L289
 4240              		.loc 1 3135 0 is_stmt 0 discriminator 1
 4241 0012 FB88     		ldrh	r3, [r7, #6]
 4242 0014 9B00     		lsls	r3, r3, #2
 4243 0016 1846     		mov	r0, r3
 4244 0018 FFF7FEFF 		bl	pvPortMalloc
 4245 001c 0346     		mov	r3, r0
 4246 001e 00E0     		b	.L290
 4247              	.L289:
 4248              		.loc 1 3135 0 discriminator 2
 4249 0020 3B68     		ldr	r3, [r7]
 4250              	.L290:
 4251              		.loc 1 3135 0 discriminator 4
 4252 0022 BB60     		str	r3, [r7, #8]
3136:../FreeRTOS/tasks.c **** 
3137:../FreeRTOS/tasks.c **** 		if( pxStack != NULL )
 4253              		.loc 1 3137 0 is_stmt 1 discriminator 4
 4254 0024 BB68     		ldr	r3, [r7, #8]
 4255 0026 002B     		cmp	r3, #0
 4256 0028 0ED0     		beq	.L291
3138:../FreeRTOS/tasks.c **** 		{
3139:../FreeRTOS/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
3140:../FreeRTOS/tasks.c **** 			on the implementation of the port malloc function. */
3141:../FreeRTOS/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 4257              		.loc 1 3141 0
 4258 002a 6820     		movs	r0, #104
 4259 002c FFF7FEFF 		bl	pvPortMalloc
 4260 0030 F860     		str	r0, [r7, #12]
3142:../FreeRTOS/tasks.c **** 
3143:../FreeRTOS/tasks.c **** 			if( pxNewTCB != NULL )
 4261              		.loc 1 3143 0
 4262 0032 FB68     		ldr	r3, [r7, #12]
 4263 0034 002B     		cmp	r3, #0
 4264 0036 03D0     		beq	.L292
3144:../FreeRTOS/tasks.c **** 			{
3145:../FreeRTOS/tasks.c **** 				/* Store the stack location in the TCB. */
3146:../FreeRTOS/tasks.c **** 				pxNewTCB->pxStack = pxStack;
 4265              		.loc 1 3146 0
 4266 0038 FB68     		ldr	r3, [r7, #12]
 4267 003a BA68     		ldr	r2, [r7, #8]
 4268 003c 1A63     		str	r2, [r3, #48]
 4269 003e 05E0     		b	.L294
 4270              	.L292:
3147:../FreeRTOS/tasks.c **** 			}
3148:../FreeRTOS/tasks.c **** 			else
3149:../FreeRTOS/tasks.c **** 			{
3150:../FreeRTOS/tasks.c **** 				/* The stack cannot be used as the TCB was not created.  Free it
3151:../FreeRTOS/tasks.c **** 				again. */
3152:../FreeRTOS/tasks.c **** 				vPortFree( pxStack );
 4271              		.loc 1 3152 0
 4272 0040 B868     		ldr	r0, [r7, #8]
 4273 0042 FFF7FEFF 		bl	vPortFree
 4274 0046 01E0     		b	.L294
 4275              	.L291:
3153:../FreeRTOS/tasks.c **** 			}
3154:../FreeRTOS/tasks.c **** 		}
3155:../FreeRTOS/tasks.c **** 		else
3156:../FreeRTOS/tasks.c **** 		{
3157:../FreeRTOS/tasks.c **** 			pxNewTCB = NULL;
 4276              		.loc 1 3157 0
 4277 0048 0023     		movs	r3, #0
 4278 004a FB60     		str	r3, [r7, #12]
 4279              	.L294:
 4280              	.LBE180:
3158:../FreeRTOS/tasks.c **** 		}
3159:../FreeRTOS/tasks.c **** 	}
3160:../FreeRTOS/tasks.c **** 	#endif /* portSTACK_GROWTH */
3161:../FreeRTOS/tasks.c **** 
3162:../FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 4281              		.loc 1 3162 0
 4282 004c FB68     		ldr	r3, [r7, #12]
 4283 004e 002B     		cmp	r3, #0
 4284 0050 08D0     		beq	.L295
3163:../FreeRTOS/tasks.c **** 	{
3164:../FreeRTOS/tasks.c **** 		/* Avoid dependency on memset() if it is not required. */
3165:../FreeRTOS/tasks.c **** 		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxT
3166:../FreeRTOS/tasks.c **** 		{
3167:../FreeRTOS/tasks.c **** 			/* Just to help debugging. */
3168:../FreeRTOS/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
 4285              		.loc 1 3168 0
 4286 0052 FB68     		ldr	r3, [r7, #12]
 4287 0054 1A6B     		ldr	r2, [r3, #48]
 4288 0056 FB88     		ldrh	r3, [r7, #6]
 4289 0058 9B00     		lsls	r3, r3, #2
 4290 005a 1046     		mov	r0, r2
 4291 005c A521     		movs	r1, #165
 4292 005e 1A46     		mov	r2, r3
 4293 0060 FFF7FEFF 		bl	memset
 4294              	.L295:
3169:../FreeRTOS/tasks.c **** 		}
3170:../FreeRTOS/tasks.c **** 		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( IN
3171:../FreeRTOS/tasks.c **** 	}
3172:../FreeRTOS/tasks.c **** 
3173:../FreeRTOS/tasks.c **** 	return pxNewTCB;
 4295              		.loc 1 3173 0
 4296 0064 FB68     		ldr	r3, [r7, #12]
3174:../FreeRTOS/tasks.c **** }
 4297              		.loc 1 3174 0
 4298 0066 1846     		mov	r0, r3
 4299 0068 1037     		adds	r7, r7, #16
 4300              		.cfi_def_cfa_offset 8
 4301 006a BD46     		mov	sp, r7
 4302              		.cfi_def_cfa_register 13
 4303              		@ sp needed
 4304 006c 80BD     		pop	{r7, pc}
 4305              		.cfi_endproc
 4306              	.LFE38:
 4308 006e 00BF     		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 4309              		.align	2
 4310              		.thumb
 4311              		.thumb_func
 4313              	prvTaskCheckFreeStackSpace:
 4314              	.LFB39:
3175:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3176:../FreeRTOS/tasks.c **** 
3177:../FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3178:../FreeRTOS/tasks.c **** 
3179:../FreeRTOS/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
3180:../FreeRTOS/tasks.c **** 	{
3181:../FreeRTOS/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3182:../FreeRTOS/tasks.c **** 	UBaseType_t uxTask = 0;
3183:../FreeRTOS/tasks.c **** 
3184:../FreeRTOS/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3185:../FreeRTOS/tasks.c **** 		{
3186:../FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3187:../FreeRTOS/tasks.c **** 
3188:../FreeRTOS/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3189:../FreeRTOS/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3190:../FreeRTOS/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3191:../FreeRTOS/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3192:../FreeRTOS/tasks.c **** 			do
3193:../FreeRTOS/tasks.c **** 			{
3194:../FreeRTOS/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3195:../FreeRTOS/tasks.c **** 
3196:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
3197:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
3198:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
3199:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
3200:../FreeRTOS/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
3201:../FreeRTOS/tasks.c **** 
3202:../FreeRTOS/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3203:../FreeRTOS/tasks.c **** 				{
3204:../FreeRTOS/tasks.c **** 					/* If the task is in the suspended list then there is a chance
3205:../FreeRTOS/tasks.c **** 					it is actually just blocked indefinitely - so really it should
3206:../FreeRTOS/tasks.c **** 					be reported as being in the Blocked state. */
3207:../FreeRTOS/tasks.c **** 					if( eState == eSuspended )
3208:../FreeRTOS/tasks.c **** 					{
3209:../FreeRTOS/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
3210:../FreeRTOS/tasks.c **** 						{
3211:../FreeRTOS/tasks.c **** 							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
3212:../FreeRTOS/tasks.c **** 						}
3213:../FreeRTOS/tasks.c **** 					}
3214:../FreeRTOS/tasks.c **** 				}
3215:../FreeRTOS/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3216:../FreeRTOS/tasks.c **** 
3217:../FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
3218:../FreeRTOS/tasks.c **** 				{
3219:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
3220:../FreeRTOS/tasks.c **** 				}
3221:../FreeRTOS/tasks.c **** 				#else
3222:../FreeRTOS/tasks.c **** 				{
3223:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
3224:../FreeRTOS/tasks.c **** 				}
3225:../FreeRTOS/tasks.c **** 				#endif
3226:../FreeRTOS/tasks.c **** 
3227:../FreeRTOS/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
3228:../FreeRTOS/tasks.c **** 				{
3229:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3230:../FreeRTOS/tasks.c **** 				}
3231:../FreeRTOS/tasks.c **** 				#else
3232:../FreeRTOS/tasks.c **** 				{
3233:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3234:../FreeRTOS/tasks.c **** 				}
3235:../FreeRTOS/tasks.c **** 				#endif
3236:../FreeRTOS/tasks.c **** 
3237:../FreeRTOS/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
3238:../FreeRTOS/tasks.c **** 				{
3239:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3240:../FreeRTOS/tasks.c **** 				}
3241:../FreeRTOS/tasks.c **** 				#else
3242:../FreeRTOS/tasks.c **** 				{
3243:../FreeRTOS/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3244:../FreeRTOS/tasks.c **** 				}
3245:../FreeRTOS/tasks.c **** 				#endif
3246:../FreeRTOS/tasks.c **** 
3247:../FreeRTOS/tasks.c **** 				uxTask++;
3248:../FreeRTOS/tasks.c **** 
3249:../FreeRTOS/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3250:../FreeRTOS/tasks.c **** 		}
3251:../FreeRTOS/tasks.c **** 		else
3252:../FreeRTOS/tasks.c **** 		{
3253:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3254:../FreeRTOS/tasks.c **** 		}
3255:../FreeRTOS/tasks.c **** 
3256:../FreeRTOS/tasks.c **** 		return uxTask;
3257:../FreeRTOS/tasks.c **** 	}
3258:../FreeRTOS/tasks.c **** 
3259:../FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3260:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3261:../FreeRTOS/tasks.c **** 
3262:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3263:../FreeRTOS/tasks.c **** 
3264:../FreeRTOS/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3265:../FreeRTOS/tasks.c **** 	{
 4315              		.loc 1 3265 0
 4316              		.cfi_startproc
 4317              		@ args = 0, pretend = 0, frame = 16
 4318              		@ frame_needed = 1, uses_anonymous_args = 0
 4319              		@ link register save eliminated.
 4320 0000 80B4     		push	{r7}
 4321              		.cfi_def_cfa_offset 4
 4322              		.cfi_offset 7, -4
 4323 0002 85B0     		sub	sp, sp, #20
 4324              		.cfi_def_cfa_offset 24
 4325 0004 00AF     		add	r7, sp, #0
 4326              		.cfi_def_cfa_register 7
 4327 0006 7860     		str	r0, [r7, #4]
3266:../FreeRTOS/tasks.c **** 	uint32_t ulCount = 0U;
 4328              		.loc 1 3266 0
 4329 0008 0023     		movs	r3, #0
 4330 000a FB60     		str	r3, [r7, #12]
3267:../FreeRTOS/tasks.c **** 
3268:../FreeRTOS/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 4331              		.loc 1 3268 0
 4332 000c 05E0     		b	.L298
 4333              	.L299:
3269:../FreeRTOS/tasks.c **** 		{
3270:../FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 4334              		.loc 1 3270 0
 4335 000e 7B68     		ldr	r3, [r7, #4]
 4336 0010 0133     		adds	r3, r3, #1
 4337 0012 7B60     		str	r3, [r7, #4]
3271:../FreeRTOS/tasks.c **** 			ulCount++;
 4338              		.loc 1 3271 0
 4339 0014 FB68     		ldr	r3, [r7, #12]
 4340 0016 0133     		adds	r3, r3, #1
 4341 0018 FB60     		str	r3, [r7, #12]
 4342              	.L298:
3268:../FreeRTOS/tasks.c **** 		{
 4343              		.loc 1 3268 0
 4344 001a 7B68     		ldr	r3, [r7, #4]
 4345 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 4346 001e A52B     		cmp	r3, #165
 4347 0020 F5D0     		beq	.L299
3272:../FreeRTOS/tasks.c **** 		}
3273:../FreeRTOS/tasks.c **** 
3274:../FreeRTOS/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
 4348              		.loc 1 3274 0
 4349 0022 FB68     		ldr	r3, [r7, #12]
 4350 0024 9B08     		lsrs	r3, r3, #2
 4351 0026 FB60     		str	r3, [r7, #12]
3275:../FreeRTOS/tasks.c **** 
3276:../FreeRTOS/tasks.c **** 		return ( uint16_t ) ulCount;
 4352              		.loc 1 3276 0
 4353 0028 FB68     		ldr	r3, [r7, #12]
 4354 002a 9BB2     		uxth	r3, r3
3277:../FreeRTOS/tasks.c **** 	}
 4355              		.loc 1 3277 0
 4356 002c 1846     		mov	r0, r3
 4357 002e 1437     		adds	r7, r7, #20
 4358              		.cfi_def_cfa_offset 4
 4359 0030 BD46     		mov	sp, r7
 4360              		.cfi_def_cfa_register 13
 4361              		@ sp needed
 4362 0032 5DF8047B 		ldr	r7, [sp], #4
 4363              		.cfi_restore 7
 4364              		.cfi_def_cfa_offset 0
 4365 0036 7047     		bx	lr
 4366              		.cfi_endproc
 4367              	.LFE39:
 4369              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 4370              		.align	2
 4371              		.global	uxTaskGetStackHighWaterMark
 4372              		.thumb
 4373              		.thumb_func
 4375              	uxTaskGetStackHighWaterMark:
 4376              	.LFB40:
3278:../FreeRTOS/tasks.c **** 
3279:../FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3280:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3281:../FreeRTOS/tasks.c **** 
3282:../FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3283:../FreeRTOS/tasks.c **** 
3284:../FreeRTOS/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3285:../FreeRTOS/tasks.c **** 	{
 4377              		.loc 1 3285 0
 4378              		.cfi_startproc
 4379              		@ args = 0, pretend = 0, frame = 24
 4380              		@ frame_needed = 1, uses_anonymous_args = 0
 4381 0000 80B5     		push	{r7, lr}
 4382              		.cfi_def_cfa_offset 8
 4383              		.cfi_offset 7, -8
 4384              		.cfi_offset 14, -4
 4385 0002 86B0     		sub	sp, sp, #24
 4386              		.cfi_def_cfa_offset 32
 4387 0004 00AF     		add	r7, sp, #0
 4388              		.cfi_def_cfa_register 7
 4389 0006 7860     		str	r0, [r7, #4]
3286:../FreeRTOS/tasks.c **** 	TCB_t *pxTCB;
3287:../FreeRTOS/tasks.c **** 	uint8_t *pucEndOfStack;
3288:../FreeRTOS/tasks.c **** 	UBaseType_t uxReturn;
3289:../FreeRTOS/tasks.c **** 
3290:../FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 4390              		.loc 1 3290 0
 4391 0008 7B68     		ldr	r3, [r7, #4]
 4392 000a 002B     		cmp	r3, #0
 4393 000c 02D1     		bne	.L302
 4394              		.loc 1 3290 0 is_stmt 0 discriminator 1
 4395 000e 094B     		ldr	r3, .L305
 4396 0010 1B68     		ldr	r3, [r3]
 4397 0012 00E0     		b	.L303
 4398              	.L302:
 4399              		.loc 1 3290 0 discriminator 2
 4400 0014 7B68     		ldr	r3, [r7, #4]
 4401              	.L303:
 4402              		.loc 1 3290 0 discriminator 4
 4403 0016 7B61     		str	r3, [r7, #20]
3291:../FreeRTOS/tasks.c **** 
3292:../FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
3293:../FreeRTOS/tasks.c **** 		{
3294:../FreeRTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 4404              		.loc 1 3294 0 is_stmt 1 discriminator 4
 4405 0018 7B69     		ldr	r3, [r7, #20]
 4406 001a 1B6B     		ldr	r3, [r3, #48]
 4407 001c 3B61     		str	r3, [r7, #16]
3295:../FreeRTOS/tasks.c **** 		}
3296:../FreeRTOS/tasks.c **** 		#else
3297:../FreeRTOS/tasks.c **** 		{
3298:../FreeRTOS/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3299:../FreeRTOS/tasks.c **** 		}
3300:../FreeRTOS/tasks.c **** 		#endif
3301:../FreeRTOS/tasks.c **** 
3302:../FreeRTOS/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 4408              		.loc 1 3302 0 discriminator 4
 4409 001e 3869     		ldr	r0, [r7, #16]
 4410 0020 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 4411 0024 0346     		mov	r3, r0
 4412 0026 FB60     		str	r3, [r7, #12]
3303:../FreeRTOS/tasks.c **** 
3304:../FreeRTOS/tasks.c **** 		return uxReturn;
 4413              		.loc 1 3304 0 discriminator 4
 4414 0028 FB68     		ldr	r3, [r7, #12]
3305:../FreeRTOS/tasks.c **** 	}
 4415              		.loc 1 3305 0 discriminator 4
 4416 002a 1846     		mov	r0, r3
 4417 002c 1837     		adds	r7, r7, #24
 4418              		.cfi_def_cfa_offset 8
 4419 002e BD46     		mov	sp, r7
 4420              		.cfi_def_cfa_register 13
 4421              		@ sp needed
 4422 0030 80BD     		pop	{r7, pc}
 4423              	.L306:
 4424 0032 00BF     		.align	2
 4425              	.L305:
 4426 0034 00000000 		.word	pxCurrentTCB
 4427              		.cfi_endproc
 4428              	.LFE40:
 4430              		.section	.text.prvDeleteTCB,"ax",%progbits
 4431              		.align	2
 4432              		.thumb
 4433              		.thumb_func
 4435              	prvDeleteTCB:
 4436              	.LFB41:
3306:../FreeRTOS/tasks.c **** 
3307:../FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3308:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3309:../FreeRTOS/tasks.c **** 
3310:../FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3311:../FreeRTOS/tasks.c **** 
3312:../FreeRTOS/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3313:../FreeRTOS/tasks.c **** 	{
 4437              		.loc 1 3313 0
 4438              		.cfi_startproc
 4439              		@ args = 0, pretend = 0, frame = 8
 4440              		@ frame_needed = 1, uses_anonymous_args = 0
 4441 0000 80B5     		push	{r7, lr}
 4442              		.cfi_def_cfa_offset 8
 4443              		.cfi_offset 7, -8
 4444              		.cfi_offset 14, -4
 4445 0002 82B0     		sub	sp, sp, #8
 4446              		.cfi_def_cfa_offset 16
 4447 0004 00AF     		add	r7, sp, #0
 4448              		.cfi_def_cfa_register 7
 4449 0006 7860     		str	r0, [r7, #4]
3314:../FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3315:../FreeRTOS/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3316:../FreeRTOS/tasks.c **** 		want to allocate and clean RAM statically. */
3317:../FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3318:../FreeRTOS/tasks.c **** 
3319:../FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3320:../FreeRTOS/tasks.c **** 		to the task to free any memory allocated at the application level. */
3321:../FreeRTOS/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3322:../FreeRTOS/tasks.c **** 		{
3323:../FreeRTOS/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3324:../FreeRTOS/tasks.c **** 		}
3325:../FreeRTOS/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3326:../FreeRTOS/tasks.c **** 
3327:../FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
3328:../FreeRTOS/tasks.c **** 		{
3329:../FreeRTOS/tasks.c **** 			/* Only free the stack if it was allocated dynamically in the first
3330:../FreeRTOS/tasks.c **** 			place. */
3331:../FreeRTOS/tasks.c **** 			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
3332:../FreeRTOS/tasks.c **** 			{
3333:../FreeRTOS/tasks.c **** 				vPortFreeAligned( pxTCB->pxStack );
3334:../FreeRTOS/tasks.c **** 			}
3335:../FreeRTOS/tasks.c **** 		}
3336:../FreeRTOS/tasks.c **** 		#else
3337:../FreeRTOS/tasks.c **** 		{
3338:../FreeRTOS/tasks.c **** 			vPortFreeAligned( pxTCB->pxStack );
 4450              		.loc 1 3338 0
 4451 0008 7B68     		ldr	r3, [r7, #4]
 4452 000a 1B6B     		ldr	r3, [r3, #48]
 4453 000c 1846     		mov	r0, r3
 4454 000e FFF7FEFF 		bl	vPortFree
3339:../FreeRTOS/tasks.c **** 		}
3340:../FreeRTOS/tasks.c **** 		#endif
3341:../FreeRTOS/tasks.c **** 
3342:../FreeRTOS/tasks.c **** 		vPortFree( pxTCB );
 4455              		.loc 1 3342 0
 4456 0012 7868     		ldr	r0, [r7, #4]
 4457 0014 FFF7FEFF 		bl	vPortFree
3343:../FreeRTOS/tasks.c **** 	}
 4458              		.loc 1 3343 0
 4459 0018 0837     		adds	r7, r7, #8
 4460              		.cfi_def_cfa_offset 8
 4461 001a BD46     		mov	sp, r7
 4462              		.cfi_def_cfa_register 13
 4463              		@ sp needed
 4464 001c 80BD     		pop	{r7, pc}
 4465              		.cfi_endproc
 4466              	.LFE41:
 4468 001e 00BF     		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 4469              		.align	2
 4470              		.thumb
 4471              		.thumb_func
 4473              	prvResetNextTaskUnblockTime:
 4474              	.LFB42:
3344:../FreeRTOS/tasks.c **** 
3345:../FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3346:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3347:../FreeRTOS/tasks.c **** 
3348:../FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3349:../FreeRTOS/tasks.c **** {
 4475              		.loc 1 3349 0
 4476              		.cfi_startproc
 4477              		@ args = 0, pretend = 0, frame = 8
 4478              		@ frame_needed = 1, uses_anonymous_args = 0
 4479              		@ link register save eliminated.
 4480 0000 80B4     		push	{r7}
 4481              		.cfi_def_cfa_offset 4
 4482              		.cfi_offset 7, -4
 4483 0002 83B0     		sub	sp, sp, #12
 4484              		.cfi_def_cfa_offset 16
 4485 0004 00AF     		add	r7, sp, #0
 4486              		.cfi_def_cfa_register 7
3350:../FreeRTOS/tasks.c **** TCB_t *pxTCB;
3351:../FreeRTOS/tasks.c **** 
3352:../FreeRTOS/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 4487              		.loc 1 3352 0
 4488 0006 0E4B     		ldr	r3, .L313
 4489 0008 1B68     		ldr	r3, [r3]
 4490 000a 1B68     		ldr	r3, [r3]
 4491 000c 002B     		cmp	r3, #0
 4492 000e 01D1     		bne	.L309
 4493              		.loc 1 3352 0 is_stmt 0 discriminator 1
 4494 0010 0123     		movs	r3, #1
 4495 0012 00E0     		b	.L310
 4496              	.L309:
 4497              		.loc 1 3352 0 discriminator 2
 4498 0014 0023     		movs	r3, #0
 4499              	.L310:
 4500              		.loc 1 3352 0 discriminator 4
 4501 0016 002B     		cmp	r3, #0
 4502 0018 04D0     		beq	.L311
3353:../FreeRTOS/tasks.c **** 	{
3354:../FreeRTOS/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3355:../FreeRTOS/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3356:../FreeRTOS/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3357:../FreeRTOS/tasks.c **** 		there is an item in the delayed list. */
3358:../FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 4503              		.loc 1 3358 0 is_stmt 1
 4504 001a 0A4B     		ldr	r3, .L313+4
 4505 001c 4FF0FF32 		mov	r2, #-1
 4506 0020 1A60     		str	r2, [r3]
 4507 0022 08E0     		b	.L308
 4508              	.L311:
3359:../FreeRTOS/tasks.c **** 	}
3360:../FreeRTOS/tasks.c **** 	else
3361:../FreeRTOS/tasks.c **** 	{
3362:../FreeRTOS/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3363:../FreeRTOS/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3364:../FreeRTOS/tasks.c **** 		which the task at the head of the delayed list should be removed
3365:../FreeRTOS/tasks.c **** 		from the Blocked state. */
3366:../FreeRTOS/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 4509              		.loc 1 3366 0
 4510 0024 064B     		ldr	r3, .L313
 4511 0026 1B68     		ldr	r3, [r3]
 4512 0028 DB68     		ldr	r3, [r3, #12]
 4513 002a DB68     		ldr	r3, [r3, #12]
 4514 002c 7B60     		str	r3, [r7, #4]
3367:../FreeRTOS/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 4515              		.loc 1 3367 0
 4516 002e 7B68     		ldr	r3, [r7, #4]
 4517 0030 5B68     		ldr	r3, [r3, #4]
 4518 0032 044A     		ldr	r2, .L313+4
 4519 0034 1360     		str	r3, [r2]
 4520              	.L308:
3368:../FreeRTOS/tasks.c **** 	}
3369:../FreeRTOS/tasks.c **** }
 4521              		.loc 1 3369 0
 4522 0036 0C37     		adds	r7, r7, #12
 4523              		.cfi_def_cfa_offset 4
 4524 0038 BD46     		mov	sp, r7
 4525              		.cfi_def_cfa_register 13
 4526              		@ sp needed
 4527 003a 5DF8047B 		ldr	r7, [sp], #4
 4528              		.cfi_restore 7
 4529              		.cfi_def_cfa_offset 0
 4530 003e 7047     		bx	lr
 4531              	.L314:
 4532              		.align	2
 4533              	.L313:
 4534 0040 00000000 		.word	pxDelayedTaskList
 4535 0044 00000000 		.word	xNextTaskUnblockTime
 4536              		.cfi_endproc
 4537              	.LFE42:
 4539              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4540              		.align	2
 4541              		.global	xTaskGetCurrentTaskHandle
 4542              		.thumb
 4543              		.thumb_func
 4545              	xTaskGetCurrentTaskHandle:
 4546              	.LFB43:
3370:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3371:../FreeRTOS/tasks.c **** 
3372:../FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3373:../FreeRTOS/tasks.c **** 
3374:../FreeRTOS/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3375:../FreeRTOS/tasks.c **** 	{
 4547              		.loc 1 3375 0
 4548              		.cfi_startproc
 4549              		@ args = 0, pretend = 0, frame = 8
 4550              		@ frame_needed = 1, uses_anonymous_args = 0
 4551              		@ link register save eliminated.
 4552 0000 80B4     		push	{r7}
 4553              		.cfi_def_cfa_offset 4
 4554              		.cfi_offset 7, -4
 4555 0002 83B0     		sub	sp, sp, #12
 4556              		.cfi_def_cfa_offset 16
 4557 0004 00AF     		add	r7, sp, #0
 4558              		.cfi_def_cfa_register 7
3376:../FreeRTOS/tasks.c **** 	TaskHandle_t xReturn;
3377:../FreeRTOS/tasks.c **** 
3378:../FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
3379:../FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3380:../FreeRTOS/tasks.c **** 		individual execution thread. */
3381:../FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 4559              		.loc 1 3381 0
 4560 0006 054B     		ldr	r3, .L317
 4561 0008 1B68     		ldr	r3, [r3]
 4562 000a 7B60     		str	r3, [r7, #4]
3382:../FreeRTOS/tasks.c **** 
3383:../FreeRTOS/tasks.c **** 		return xReturn;
 4563              		.loc 1 3383 0
 4564 000c 7B68     		ldr	r3, [r7, #4]
3384:../FreeRTOS/tasks.c **** 	}
 4565              		.loc 1 3384 0
 4566 000e 1846     		mov	r0, r3
 4567 0010 0C37     		adds	r7, r7, #12
 4568              		.cfi_def_cfa_offset 4
 4569 0012 BD46     		mov	sp, r7
 4570              		.cfi_def_cfa_register 13
 4571              		@ sp needed
 4572 0014 5DF8047B 		ldr	r7, [sp], #4
 4573              		.cfi_restore 7
 4574              		.cfi_def_cfa_offset 0
 4575 0018 7047     		bx	lr
 4576              	.L318:
 4577 001a 00BF     		.align	2
 4578              	.L317:
 4579 001c 00000000 		.word	pxCurrentTCB
 4580              		.cfi_endproc
 4581              	.LFE43:
 4583              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 4584              		.align	2
 4585              		.global	xTaskGetSchedulerState
 4586              		.thumb
 4587              		.thumb_func
 4589              	xTaskGetSchedulerState:
 4590              	.LFB44:
3385:../FreeRTOS/tasks.c **** 
3386:../FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3387:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3388:../FreeRTOS/tasks.c **** 
3389:../FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3390:../FreeRTOS/tasks.c **** 
3391:../FreeRTOS/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3392:../FreeRTOS/tasks.c **** 	{
 4591              		.loc 1 3392 0
 4592              		.cfi_startproc
 4593              		@ args = 0, pretend = 0, frame = 8
 4594              		@ frame_needed = 1, uses_anonymous_args = 0
 4595              		@ link register save eliminated.
 4596 0000 80B4     		push	{r7}
 4597              		.cfi_def_cfa_offset 4
 4598              		.cfi_offset 7, -4
 4599 0002 83B0     		sub	sp, sp, #12
 4600              		.cfi_def_cfa_offset 16
 4601 0004 00AF     		add	r7, sp, #0
 4602              		.cfi_def_cfa_register 7
3393:../FreeRTOS/tasks.c **** 	BaseType_t xReturn;
3394:../FreeRTOS/tasks.c **** 
3395:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 4603              		.loc 1 3395 0
 4604 0006 0B4B     		ldr	r3, .L324
 4605 0008 1B68     		ldr	r3, [r3]
 4606 000a 002B     		cmp	r3, #0
 4607 000c 02D1     		bne	.L320
3396:../FreeRTOS/tasks.c **** 		{
3397:../FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 4608              		.loc 1 3397 0
 4609 000e 0123     		movs	r3, #1
 4610 0010 7B60     		str	r3, [r7, #4]
 4611 0012 08E0     		b	.L321
 4612              	.L320:
3398:../FreeRTOS/tasks.c **** 		}
3399:../FreeRTOS/tasks.c **** 		else
3400:../FreeRTOS/tasks.c **** 		{
3401:../FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4613              		.loc 1 3401 0
 4614 0014 084B     		ldr	r3, .L324+4
 4615 0016 1B68     		ldr	r3, [r3]
 4616 0018 002B     		cmp	r3, #0
 4617 001a 02D1     		bne	.L322
3402:../FreeRTOS/tasks.c **** 			{
3403:../FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 4618              		.loc 1 3403 0
 4619 001c 0223     		movs	r3, #2
 4620 001e 7B60     		str	r3, [r7, #4]
 4621 0020 01E0     		b	.L321
 4622              	.L322:
3404:../FreeRTOS/tasks.c **** 			}
3405:../FreeRTOS/tasks.c **** 			else
3406:../FreeRTOS/tasks.c **** 			{
3407:../FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 4623              		.loc 1 3407 0
 4624 0022 0023     		movs	r3, #0
 4625 0024 7B60     		str	r3, [r7, #4]
 4626              	.L321:
3408:../FreeRTOS/tasks.c **** 			}
3409:../FreeRTOS/tasks.c **** 		}
3410:../FreeRTOS/tasks.c **** 
3411:../FreeRTOS/tasks.c **** 		return xReturn;
 4627              		.loc 1 3411 0
 4628 0026 7B68     		ldr	r3, [r7, #4]
3412:../FreeRTOS/tasks.c **** 	}
 4629              		.loc 1 3412 0
 4630 0028 1846     		mov	r0, r3
 4631 002a 0C37     		adds	r7, r7, #12
 4632              		.cfi_def_cfa_offset 4
 4633 002c BD46     		mov	sp, r7
 4634              		.cfi_def_cfa_register 13
 4635              		@ sp needed
 4636 002e 5DF8047B 		ldr	r7, [sp], #4
 4637              		.cfi_restore 7
 4638              		.cfi_def_cfa_offset 0
 4639 0032 7047     		bx	lr
 4640              	.L325:
 4641              		.align	2
 4642              	.L324:
 4643 0034 00000000 		.word	xSchedulerRunning
 4644 0038 00000000 		.word	uxSchedulerSuspended
 4645              		.cfi_endproc
 4646              	.LFE44:
 4648              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 4649              		.align	2
 4650              		.global	vTaskPriorityInherit
 4651              		.thumb
 4652              		.thumb_func
 4654              	vTaskPriorityInherit:
 4655              	.LFB45:
3413:../FreeRTOS/tasks.c **** 
3414:../FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3415:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3416:../FreeRTOS/tasks.c **** 
3417:../FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3418:../FreeRTOS/tasks.c **** 
3419:../FreeRTOS/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3420:../FreeRTOS/tasks.c **** 	{
 4656              		.loc 1 3420 0
 4657              		.cfi_startproc
 4658              		@ args = 0, pretend = 0, frame = 16
 4659              		@ frame_needed = 1, uses_anonymous_args = 0
 4660 0000 80B5     		push	{r7, lr}
 4661              		.cfi_def_cfa_offset 8
 4662              		.cfi_offset 7, -8
 4663              		.cfi_offset 14, -4
 4664 0002 84B0     		sub	sp, sp, #16
 4665              		.cfi_def_cfa_offset 24
 4666 0004 00AF     		add	r7, sp, #0
 4667              		.cfi_def_cfa_register 7
 4668 0006 7860     		str	r0, [r7, #4]
3421:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4669              		.loc 1 3421 0
 4670 0008 7B68     		ldr	r3, [r7, #4]
 4671 000a FB60     		str	r3, [r7, #12]
3422:../FreeRTOS/tasks.c **** 
3423:../FreeRTOS/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3424:../FreeRTOS/tasks.c **** 		locked then the mutex holder might now be NULL. */
3425:../FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 4672              		.loc 1 3425 0
 4673 000c 7B68     		ldr	r3, [r7, #4]
 4674 000e 002B     		cmp	r3, #0
 4675 0010 64D0     		beq	.L326
3426:../FreeRTOS/tasks.c **** 		{
3427:../FreeRTOS/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3428:../FreeRTOS/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3429:../FreeRTOS/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3430:../FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 4676              		.loc 1 3430 0
 4677 0012 FB68     		ldr	r3, [r7, #12]
 4678 0014 DA6A     		ldr	r2, [r3, #44]
 4679 0016 334B     		ldr	r3, .L335
 4680 0018 1B68     		ldr	r3, [r3]
 4681 001a DB6A     		ldr	r3, [r3, #44]
 4682 001c 9A42     		cmp	r2, r3
 4683 001e 5DD2     		bcs	.L326
3431:../FreeRTOS/tasks.c **** 			{
3432:../FreeRTOS/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3433:../FreeRTOS/tasks.c **** 				priority.  Only reset the event list item value if the value is
3434:../FreeRTOS/tasks.c **** 				not	being used for anything else. */
3435:../FreeRTOS/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 4684              		.loc 1 3435 0
 4685 0020 FB68     		ldr	r3, [r7, #12]
 4686 0022 9B69     		ldr	r3, [r3, #24]
 4687 0024 002B     		cmp	r3, #0
 4688 0026 06DB     		blt	.L328
3436:../FreeRTOS/tasks.c **** 				{
3437:../FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4689              		.loc 1 3437 0
 4690 0028 2E4B     		ldr	r3, .L335
 4691 002a 1B68     		ldr	r3, [r3]
 4692 002c DB6A     		ldr	r3, [r3, #44]
 4693 002e C3F10802 		rsb	r2, r3, #8
 4694 0032 FB68     		ldr	r3, [r7, #12]
 4695 0034 9A61     		str	r2, [r3, #24]
 4696              	.L328:
3438:../FreeRTOS/tasks.c **** 				}
3439:../FreeRTOS/tasks.c **** 				else
3440:../FreeRTOS/tasks.c **** 				{
3441:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3442:../FreeRTOS/tasks.c **** 				}
3443:../FreeRTOS/tasks.c **** 
3444:../FreeRTOS/tasks.c **** 				/* If the task being modified is in the ready state it will need
3445:../FreeRTOS/tasks.c **** 				to be moved into a new list. */
3446:../FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 4697              		.loc 1 3446 0
 4698 0036 FB68     		ldr	r3, [r7, #12]
 4699 0038 5969     		ldr	r1, [r3, #20]
 4700 003a FB68     		ldr	r3, [r7, #12]
 4701 003c DA6A     		ldr	r2, [r3, #44]
 4702 003e 1346     		mov	r3, r2
 4703 0040 9B00     		lsls	r3, r3, #2
 4704 0042 1344     		add	r3, r3, r2
 4705 0044 9B00     		lsls	r3, r3, #2
 4706 0046 284A     		ldr	r2, .L335+4
 4707 0048 1344     		add	r3, r3, r2
 4708 004a 9942     		cmp	r1, r3
 4709 004c 01D1     		bne	.L329
 4710              		.loc 1 3446 0 is_stmt 0 discriminator 1
 4711 004e 0123     		movs	r3, #1
 4712 0050 00E0     		b	.L330
 4713              	.L329:
 4714              		.loc 1 3446 0 discriminator 2
 4715 0052 0023     		movs	r3, #0
 4716              	.L330:
 4717              		.loc 1 3446 0 discriminator 4
 4718 0054 002B     		cmp	r3, #0
 4719 0056 3CD0     		beq	.L331
3447:../FreeRTOS/tasks.c **** 				{
3448:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 4720              		.loc 1 3448 0 is_stmt 1
 4721 0058 FB68     		ldr	r3, [r7, #12]
 4722 005a 0433     		adds	r3, r3, #4
 4723 005c 1846     		mov	r0, r3
 4724 005e FFF7FEFF 		bl	uxListRemove
 4725 0062 0346     		mov	r3, r0
 4726 0064 002B     		cmp	r3, #0
 4727 0066 15D1     		bne	.L332
3449:../FreeRTOS/tasks.c **** 					{
3450:../FreeRTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4728              		.loc 1 3450 0
 4729 0068 FB68     		ldr	r3, [r7, #12]
 4730 006a DA6A     		ldr	r2, [r3, #44]
 4731 006c 1E49     		ldr	r1, .L335+4
 4732 006e 1346     		mov	r3, r2
 4733 0070 9B00     		lsls	r3, r3, #2
 4734 0072 1344     		add	r3, r3, r2
 4735 0074 9B00     		lsls	r3, r3, #2
 4736 0076 0B44     		add	r3, r3, r1
 4737 0078 1B68     		ldr	r3, [r3]
 4738 007a 002B     		cmp	r3, #0
 4739 007c 0AD1     		bne	.L332
 4740              		.loc 1 3450 0 is_stmt 0 discriminator 1
 4741 007e FB68     		ldr	r3, [r7, #12]
 4742 0080 DB6A     		ldr	r3, [r3, #44]
 4743 0082 1A46     		mov	r2, r3
 4744 0084 0123     		movs	r3, #1
 4745 0086 9340     		lsls	r3, r3, r2
 4746 0088 DA43     		mvns	r2, r3
 4747 008a 184B     		ldr	r3, .L335+8
 4748 008c 1B68     		ldr	r3, [r3]
 4749 008e 1340     		ands	r3, r3, r2
 4750 0090 164A     		ldr	r2, .L335+8
 4751 0092 1360     		str	r3, [r2]
 4752              	.L332:
3451:../FreeRTOS/tasks.c **** 					}
3452:../FreeRTOS/tasks.c **** 					else
3453:../FreeRTOS/tasks.c **** 					{
3454:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3455:../FreeRTOS/tasks.c **** 					}
3456:../FreeRTOS/tasks.c **** 
3457:../FreeRTOS/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3458:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4753              		.loc 1 3458 0 is_stmt 1
 4754 0094 134B     		ldr	r3, .L335
 4755 0096 1B68     		ldr	r3, [r3]
 4756 0098 DA6A     		ldr	r2, [r3, #44]
 4757 009a FB68     		ldr	r3, [r7, #12]
 4758 009c DA62     		str	r2, [r3, #44]
3459:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4759              		.loc 1 3459 0
 4760 009e FB68     		ldr	r3, [r7, #12]
 4761 00a0 DB6A     		ldr	r3, [r3, #44]
 4762 00a2 1A46     		mov	r2, r3
 4763 00a4 0123     		movs	r3, #1
 4764 00a6 03FA02F2 		lsl	r2, r3, r2
 4765 00aa 104B     		ldr	r3, .L335+8
 4766 00ac 1B68     		ldr	r3, [r3]
 4767 00ae 1343     		orrs	r3, r3, r2
 4768 00b0 0E4A     		ldr	r2, .L335+8
 4769 00b2 1360     		str	r3, [r2]
 4770 00b4 FB68     		ldr	r3, [r7, #12]
 4771 00b6 DA6A     		ldr	r2, [r3, #44]
 4772 00b8 1346     		mov	r3, r2
 4773 00ba 9B00     		lsls	r3, r3, #2
 4774 00bc 1344     		add	r3, r3, r2
 4775 00be 9B00     		lsls	r3, r3, #2
 4776 00c0 094A     		ldr	r2, .L335+4
 4777 00c2 1A44     		add	r2, r2, r3
 4778 00c4 FB68     		ldr	r3, [r7, #12]
 4779 00c6 0433     		adds	r3, r3, #4
 4780 00c8 1046     		mov	r0, r2
 4781 00ca 1946     		mov	r1, r3
 4782 00cc FFF7FEFF 		bl	vListInsertEnd
 4783 00d0 04E0     		b	.L326
 4784              	.L331:
3460:../FreeRTOS/tasks.c **** 				}
3461:../FreeRTOS/tasks.c **** 				else
3462:../FreeRTOS/tasks.c **** 				{
3463:../FreeRTOS/tasks.c **** 					/* Just inherit the priority. */
3464:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4785              		.loc 1 3464 0
 4786 00d2 044B     		ldr	r3, .L335
 4787 00d4 1B68     		ldr	r3, [r3]
 4788 00d6 DA6A     		ldr	r2, [r3, #44]
 4789 00d8 FB68     		ldr	r3, [r7, #12]
 4790 00da DA62     		str	r2, [r3, #44]
 4791              	.L326:
3465:../FreeRTOS/tasks.c **** 				}
3466:../FreeRTOS/tasks.c **** 
3467:../FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3468:../FreeRTOS/tasks.c **** 			}
3469:../FreeRTOS/tasks.c **** 			else
3470:../FreeRTOS/tasks.c **** 			{
3471:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3472:../FreeRTOS/tasks.c **** 			}
3473:../FreeRTOS/tasks.c **** 		}
3474:../FreeRTOS/tasks.c **** 		else
3475:../FreeRTOS/tasks.c **** 		{
3476:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3477:../FreeRTOS/tasks.c **** 		}
3478:../FreeRTOS/tasks.c **** 	}
 4792              		.loc 1 3478 0
 4793 00dc 1037     		adds	r7, r7, #16
 4794              		.cfi_def_cfa_offset 8
 4795 00de BD46     		mov	sp, r7
 4796              		.cfi_def_cfa_register 13
 4797              		@ sp needed
 4798 00e0 80BD     		pop	{r7, pc}
 4799              	.L336:
 4800 00e2 00BF     		.align	2
 4801              	.L335:
 4802 00e4 00000000 		.word	pxCurrentTCB
 4803 00e8 00000000 		.word	pxReadyTasksLists
 4804 00ec 00000000 		.word	uxTopReadyPriority
 4805              		.cfi_endproc
 4806              	.LFE45:
 4808              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 4809              		.align	2
 4810              		.global	xTaskPriorityDisinherit
 4811              		.thumb
 4812              		.thumb_func
 4814              	xTaskPriorityDisinherit:
 4815              	.LFB46:
3479:../FreeRTOS/tasks.c **** 
3480:../FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3481:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3482:../FreeRTOS/tasks.c **** 
3483:../FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3484:../FreeRTOS/tasks.c **** 
3485:../FreeRTOS/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3486:../FreeRTOS/tasks.c **** 	{
 4816              		.loc 1 3486 0
 4817              		.cfi_startproc
 4818              		@ args = 0, pretend = 0, frame = 24
 4819              		@ frame_needed = 1, uses_anonymous_args = 0
 4820 0000 80B5     		push	{r7, lr}
 4821              		.cfi_def_cfa_offset 8
 4822              		.cfi_offset 7, -8
 4823              		.cfi_offset 14, -4
 4824 0002 86B0     		sub	sp, sp, #24
 4825              		.cfi_def_cfa_offset 32
 4826 0004 00AF     		add	r7, sp, #0
 4827              		.cfi_def_cfa_register 7
 4828 0006 7860     		str	r0, [r7, #4]
3487:../FreeRTOS/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 4829              		.loc 1 3487 0
 4830 0008 7B68     		ldr	r3, [r7, #4]
 4831 000a 3B61     		str	r3, [r7, #16]
3488:../FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 4832              		.loc 1 3488 0
 4833 000c 0023     		movs	r3, #0
 4834 000e 7B61     		str	r3, [r7, #20]
3489:../FreeRTOS/tasks.c **** 
3490:../FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 4835              		.loc 1 3490 0
 4836 0010 7B68     		ldr	r3, [r7, #4]
 4837 0012 002B     		cmp	r3, #0
 4838 0014 6ED0     		beq	.L338
3491:../FreeRTOS/tasks.c **** 		{
3492:../FreeRTOS/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3493:../FreeRTOS/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3494:../FreeRTOS/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3495:../FreeRTOS/tasks.c **** 			be the running state task. */
3496:../FreeRTOS/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
 4839              		.loc 1 3496 0
 4840 0016 3A4B     		ldr	r3, .L346
 4841 0018 1B68     		ldr	r3, [r3]
 4842 001a 3A69     		ldr	r2, [r7, #16]
 4843 001c 9A42     		cmp	r2, r3
 4844 001e 09D0     		beq	.L339
 4845              	.LBB181:
 4846              	.LBB182:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 4847              		.loc 2 215 0 discriminator 1
 4848              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 4849 0020 4FF00703 			mov r3, #7												
 4850 0024 83F31188 		msr basepri, r3											
 4851 0028 BFF36F8F 		isb														
 4852 002c BFF34F8F 		dsb														
 4853              	
 4854              	@ 0 "" 2
 4855              		.thumb
 4856 0030 FB60     		str	r3, [r7, #12]
 4857              	.L340:
 4858              	.LBE182:
 4859              	.LBE181:
 4860              		.loc 1 3496 0 discriminator 1
 4861 0032 FEE7     		b	.L340
 4862              	.L339:
3497:../FreeRTOS/tasks.c **** 
3498:../FreeRTOS/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
 4863              		.loc 1 3498 0
 4864 0034 3B69     		ldr	r3, [r7, #16]
 4865 0036 DB6D     		ldr	r3, [r3, #92]
 4866 0038 002B     		cmp	r3, #0
 4867 003a 09D1     		bne	.L341
 4868              	.LBB183:
 4869              	.LBB184:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 4870              		.loc 2 215 0 discriminator 1
 4871              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 4872 003c 4FF00703 			mov r3, #7												
 4873 0040 83F31188 		msr basepri, r3											
 4874 0044 BFF36F8F 		isb														
 4875 0048 BFF34F8F 		dsb														
 4876              	
 4877              	@ 0 "" 2
 4878              		.thumb
 4879 004c BB60     		str	r3, [r7, #8]
 4880              	.L342:
 4881              	.LBE184:
 4882              	.LBE183:
 4883              		.loc 1 3498 0 discriminator 2
 4884 004e FEE7     		b	.L342
 4885              	.L341:
3499:../FreeRTOS/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 4886              		.loc 1 3499 0
 4887 0050 3B69     		ldr	r3, [r7, #16]
 4888 0052 DB6D     		ldr	r3, [r3, #92]
 4889 0054 5A1E     		subs	r2, r3, #1
 4890 0056 3B69     		ldr	r3, [r7, #16]
 4891 0058 DA65     		str	r2, [r3, #92]
3500:../FreeRTOS/tasks.c **** 
3501:../FreeRTOS/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3502:../FreeRTOS/tasks.c **** 			task? */
3503:../FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4892              		.loc 1 3503 0
 4893 005a 3B69     		ldr	r3, [r7, #16]
 4894 005c DA6A     		ldr	r2, [r3, #44]
 4895 005e 3B69     		ldr	r3, [r7, #16]
 4896 0060 9B6D     		ldr	r3, [r3, #88]
 4897 0062 9A42     		cmp	r2, r3
 4898 0064 46D0     		beq	.L338
3504:../FreeRTOS/tasks.c **** 			{
3505:../FreeRTOS/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3506:../FreeRTOS/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4899              		.loc 1 3506 0
 4900 0066 3B69     		ldr	r3, [r7, #16]
 4901 0068 DB6D     		ldr	r3, [r3, #92]
 4902 006a 002B     		cmp	r3, #0
 4903 006c 42D1     		bne	.L338
3507:../FreeRTOS/tasks.c **** 				{
3508:../FreeRTOS/tasks.c **** 					/* A task can only have an inherited priority if it holds
3509:../FreeRTOS/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3510:../FreeRTOS/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3511:../FreeRTOS/tasks.c **** 					holding	task then it must be the running state task.  Remove
3512:../FreeRTOS/tasks.c **** 					the	holding task from the ready	list. */
3513:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 4904              		.loc 1 3513 0
 4905 006e 3B69     		ldr	r3, [r7, #16]
 4906 0070 0433     		adds	r3, r3, #4
 4907 0072 1846     		mov	r0, r3
 4908 0074 FFF7FEFF 		bl	uxListRemove
 4909 0078 0346     		mov	r3, r0
 4910 007a 002B     		cmp	r3, #0
 4911 007c 15D1     		bne	.L343
3514:../FreeRTOS/tasks.c **** 					{
3515:../FreeRTOS/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4912              		.loc 1 3515 0
 4913 007e 3B69     		ldr	r3, [r7, #16]
 4914 0080 DA6A     		ldr	r2, [r3, #44]
 4915 0082 2049     		ldr	r1, .L346+4
 4916 0084 1346     		mov	r3, r2
 4917 0086 9B00     		lsls	r3, r3, #2
 4918 0088 1344     		add	r3, r3, r2
 4919 008a 9B00     		lsls	r3, r3, #2
 4920 008c 0B44     		add	r3, r3, r1
 4921 008e 1B68     		ldr	r3, [r3]
 4922 0090 002B     		cmp	r3, #0
 4923 0092 0AD1     		bne	.L343
 4924              		.loc 1 3515 0 is_stmt 0 discriminator 1
 4925 0094 3B69     		ldr	r3, [r7, #16]
 4926 0096 DB6A     		ldr	r3, [r3, #44]
 4927 0098 1A46     		mov	r2, r3
 4928 009a 0123     		movs	r3, #1
 4929 009c 9340     		lsls	r3, r3, r2
 4930 009e DA43     		mvns	r2, r3
 4931 00a0 194B     		ldr	r3, .L346+8
 4932 00a2 1B68     		ldr	r3, [r3]
 4933 00a4 1340     		ands	r3, r3, r2
 4934 00a6 184A     		ldr	r2, .L346+8
 4935 00a8 1360     		str	r3, [r2]
 4936              	.L343:
3516:../FreeRTOS/tasks.c **** 					}
3517:../FreeRTOS/tasks.c **** 					else
3518:../FreeRTOS/tasks.c **** 					{
3519:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3520:../FreeRTOS/tasks.c **** 					}
3521:../FreeRTOS/tasks.c **** 
3522:../FreeRTOS/tasks.c **** 					/* Disinherit the priority before adding the task into the
3523:../FreeRTOS/tasks.c **** 					new	ready list. */
3524:../FreeRTOS/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3525:../FreeRTOS/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
 4937              		.loc 1 3525 0 is_stmt 1
 4938 00aa 3B69     		ldr	r3, [r7, #16]
 4939 00ac 9A6D     		ldr	r2, [r3, #88]
 4940 00ae 3B69     		ldr	r3, [r7, #16]
 4941 00b0 DA62     		str	r2, [r3, #44]
3526:../FreeRTOS/tasks.c **** 
3527:../FreeRTOS/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3528:../FreeRTOS/tasks.c **** 					any other purpose if this task is running, and it must be
3529:../FreeRTOS/tasks.c **** 					running to give back the mutex. */
3530:../FreeRTOS/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4942              		.loc 1 3530 0
 4943 00b2 3B69     		ldr	r3, [r7, #16]
 4944 00b4 DB6A     		ldr	r3, [r3, #44]
 4945 00b6 C3F10802 		rsb	r2, r3, #8
 4946 00ba 3B69     		ldr	r3, [r7, #16]
 4947 00bc 9A61     		str	r2, [r3, #24]
3531:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4948              		.loc 1 3531 0
 4949 00be 3B69     		ldr	r3, [r7, #16]
 4950 00c0 DB6A     		ldr	r3, [r3, #44]
 4951 00c2 1A46     		mov	r2, r3
 4952 00c4 0123     		movs	r3, #1
 4953 00c6 03FA02F2 		lsl	r2, r3, r2
 4954 00ca 0F4B     		ldr	r3, .L346+8
 4955 00cc 1B68     		ldr	r3, [r3]
 4956 00ce 1343     		orrs	r3, r3, r2
 4957 00d0 0D4A     		ldr	r2, .L346+8
 4958 00d2 1360     		str	r3, [r2]
 4959 00d4 3B69     		ldr	r3, [r7, #16]
 4960 00d6 DA6A     		ldr	r2, [r3, #44]
 4961 00d8 1346     		mov	r3, r2
 4962 00da 9B00     		lsls	r3, r3, #2
 4963 00dc 1344     		add	r3, r3, r2
 4964 00de 9B00     		lsls	r3, r3, #2
 4965 00e0 084A     		ldr	r2, .L346+4
 4966 00e2 1A44     		add	r2, r2, r3
 4967 00e4 3B69     		ldr	r3, [r7, #16]
 4968 00e6 0433     		adds	r3, r3, #4
 4969 00e8 1046     		mov	r0, r2
 4970 00ea 1946     		mov	r1, r3
 4971 00ec FFF7FEFF 		bl	vListInsertEnd
3532:../FreeRTOS/tasks.c **** 
3533:../FreeRTOS/tasks.c **** 					/* Return true to indicate that a context switch is required.
3534:../FreeRTOS/tasks.c **** 					This is only actually required in the corner case whereby
3535:../FreeRTOS/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3536:../FreeRTOS/tasks.c **** 					in an order different to that in which they were taken.
3537:../FreeRTOS/tasks.c **** 					If a context switch did not occur when the first mutex was
3538:../FreeRTOS/tasks.c **** 					returned, even if a task was waiting on it, then a context
3539:../FreeRTOS/tasks.c **** 					switch should occur when the last mutex is returned whether
3540:../FreeRTOS/tasks.c **** 					a task is waiting on it or not. */
3541:../FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 4972              		.loc 1 3541 0
 4973 00f0 0123     		movs	r3, #1
 4974 00f2 7B61     		str	r3, [r7, #20]
 4975              	.L338:
3542:../FreeRTOS/tasks.c **** 				}
3543:../FreeRTOS/tasks.c **** 				else
3544:../FreeRTOS/tasks.c **** 				{
3545:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3546:../FreeRTOS/tasks.c **** 				}
3547:../FreeRTOS/tasks.c **** 			}
3548:../FreeRTOS/tasks.c **** 			else
3549:../FreeRTOS/tasks.c **** 			{
3550:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3551:../FreeRTOS/tasks.c **** 			}
3552:../FreeRTOS/tasks.c **** 		}
3553:../FreeRTOS/tasks.c **** 		else
3554:../FreeRTOS/tasks.c **** 		{
3555:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3556:../FreeRTOS/tasks.c **** 		}
3557:../FreeRTOS/tasks.c **** 
3558:../FreeRTOS/tasks.c **** 		return xReturn;
 4976              		.loc 1 3558 0
 4977 00f4 7B69     		ldr	r3, [r7, #20]
3559:../FreeRTOS/tasks.c **** 	}
 4978              		.loc 1 3559 0
 4979 00f6 1846     		mov	r0, r3
 4980 00f8 1837     		adds	r7, r7, #24
 4981              		.cfi_def_cfa_offset 8
 4982 00fa BD46     		mov	sp, r7
 4983              		.cfi_def_cfa_register 13
 4984              		@ sp needed
 4985 00fc 80BD     		pop	{r7, pc}
 4986              	.L347:
 4987 00fe 00BF     		.align	2
 4988              	.L346:
 4989 0100 00000000 		.word	pxCurrentTCB
 4990 0104 00000000 		.word	pxReadyTasksLists
 4991 0108 00000000 		.word	uxTopReadyPriority
 4992              		.cfi_endproc
 4993              	.LFE46:
 4995              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4996              		.align	2
 4997              		.global	uxTaskResetEventItemValue
 4998              		.thumb
 4999              		.thumb_func
 5001              	uxTaskResetEventItemValue:
 5002              	.LFB47:
3560:../FreeRTOS/tasks.c **** 
3561:../FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3562:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3563:../FreeRTOS/tasks.c **** 
3564:../FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3565:../FreeRTOS/tasks.c **** 
3566:../FreeRTOS/tasks.c **** 	void vTaskEnterCritical( void )
3567:../FreeRTOS/tasks.c **** 	{
3568:../FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
3569:../FreeRTOS/tasks.c **** 
3570:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3571:../FreeRTOS/tasks.c **** 		{
3572:../FreeRTOS/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3573:../FreeRTOS/tasks.c **** 
3574:../FreeRTOS/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3575:../FreeRTOS/tasks.c **** 			function so	assert() if it is being called from an interrupt
3576:../FreeRTOS/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3577:../FreeRTOS/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3578:../FreeRTOS/tasks.c **** 			protect against recursive calls if the assert function also uses a
3579:../FreeRTOS/tasks.c **** 			critical section. */
3580:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3581:../FreeRTOS/tasks.c **** 			{
3582:../FreeRTOS/tasks.c **** 				portASSERT_IF_IN_ISR();
3583:../FreeRTOS/tasks.c **** 			}
3584:../FreeRTOS/tasks.c **** 
3585:../FreeRTOS/tasks.c **** 		}
3586:../FreeRTOS/tasks.c **** 		else
3587:../FreeRTOS/tasks.c **** 		{
3588:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3589:../FreeRTOS/tasks.c **** 		}
3590:../FreeRTOS/tasks.c **** 	}
3591:../FreeRTOS/tasks.c **** 
3592:../FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3593:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3594:../FreeRTOS/tasks.c **** 
3595:../FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3596:../FreeRTOS/tasks.c **** 
3597:../FreeRTOS/tasks.c **** 	void vTaskExitCritical( void )
3598:../FreeRTOS/tasks.c **** 	{
3599:../FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3600:../FreeRTOS/tasks.c **** 		{
3601:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3602:../FreeRTOS/tasks.c **** 			{
3603:../FreeRTOS/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3604:../FreeRTOS/tasks.c **** 
3605:../FreeRTOS/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3606:../FreeRTOS/tasks.c **** 				{
3607:../FreeRTOS/tasks.c **** 					portENABLE_INTERRUPTS();
3608:../FreeRTOS/tasks.c **** 				}
3609:../FreeRTOS/tasks.c **** 				else
3610:../FreeRTOS/tasks.c **** 				{
3611:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3612:../FreeRTOS/tasks.c **** 				}
3613:../FreeRTOS/tasks.c **** 			}
3614:../FreeRTOS/tasks.c **** 			else
3615:../FreeRTOS/tasks.c **** 			{
3616:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3617:../FreeRTOS/tasks.c **** 			}
3618:../FreeRTOS/tasks.c **** 		}
3619:../FreeRTOS/tasks.c **** 		else
3620:../FreeRTOS/tasks.c **** 		{
3621:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3622:../FreeRTOS/tasks.c **** 		}
3623:../FreeRTOS/tasks.c **** 	}
3624:../FreeRTOS/tasks.c **** 
3625:../FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3626:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3627:../FreeRTOS/tasks.c **** 
3628:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3629:../FreeRTOS/tasks.c **** 
3630:../FreeRTOS/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3631:../FreeRTOS/tasks.c **** 	{
3632:../FreeRTOS/tasks.c **** 	BaseType_t x;
3633:../FreeRTOS/tasks.c **** 
3634:../FreeRTOS/tasks.c **** 		/* Start by copying the entire string. */
3635:../FreeRTOS/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3636:../FreeRTOS/tasks.c **** 
3637:../FreeRTOS/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3638:../FreeRTOS/tasks.c **** 		printed out. */
3639:../FreeRTOS/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3640:../FreeRTOS/tasks.c **** 		{
3641:../FreeRTOS/tasks.c **** 			pcBuffer[ x ] = ' ';
3642:../FreeRTOS/tasks.c **** 		}
3643:../FreeRTOS/tasks.c **** 
3644:../FreeRTOS/tasks.c **** 		/* Terminate. */
3645:../FreeRTOS/tasks.c **** 		pcBuffer[ x ] = 0x00;
3646:../FreeRTOS/tasks.c **** 
3647:../FreeRTOS/tasks.c **** 		/* Return the new end of string. */
3648:../FreeRTOS/tasks.c **** 		return &( pcBuffer[ x ] );
3649:../FreeRTOS/tasks.c **** 	}
3650:../FreeRTOS/tasks.c **** 
3651:../FreeRTOS/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3652:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3653:../FreeRTOS/tasks.c **** 
3654:../FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3655:../FreeRTOS/tasks.c **** 
3656:../FreeRTOS/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3657:../FreeRTOS/tasks.c **** 	{
3658:../FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3659:../FreeRTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3660:../FreeRTOS/tasks.c **** 	char cStatus;
3661:../FreeRTOS/tasks.c **** 
3662:../FreeRTOS/tasks.c **** 		/*
3663:../FreeRTOS/tasks.c **** 		 * PLEASE NOTE:
3664:../FreeRTOS/tasks.c **** 		 *
3665:../FreeRTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3666:../FreeRTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3667:../FreeRTOS/tasks.c **** 		 * scheduler.
3668:../FreeRTOS/tasks.c **** 		 *
3669:../FreeRTOS/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3670:../FreeRTOS/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3671:../FreeRTOS/tasks.c **** 		 * displays task names, states and stack usage.
3672:../FreeRTOS/tasks.c **** 		 *
3673:../FreeRTOS/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3674:../FreeRTOS/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3675:../FreeRTOS/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3676:../FreeRTOS/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3677:../FreeRTOS/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3678:../FreeRTOS/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3679:../FreeRTOS/tasks.c **** 		 * snprintf() implementation!).
3680:../FreeRTOS/tasks.c **** 		 *
3681:../FreeRTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3682:../FreeRTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3683:../FreeRTOS/tasks.c **** 		 * through a call to vTaskList().
3684:../FreeRTOS/tasks.c **** 		 */
3685:../FreeRTOS/tasks.c **** 
3686:../FreeRTOS/tasks.c **** 
3687:../FreeRTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3688:../FreeRTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
3689:../FreeRTOS/tasks.c **** 
3690:../FreeRTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3691:../FreeRTOS/tasks.c **** 		function is executing. */
3692:../FreeRTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3693:../FreeRTOS/tasks.c **** 
3694:../FreeRTOS/tasks.c **** 		/* Allocate an array index for each task. */
3695:../FreeRTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3696:../FreeRTOS/tasks.c **** 
3697:../FreeRTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
3698:../FreeRTOS/tasks.c **** 		{
3699:../FreeRTOS/tasks.c **** 			/* Generate the (binary) data. */
3700:../FreeRTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3701:../FreeRTOS/tasks.c **** 
3702:../FreeRTOS/tasks.c **** 			/* Create a human readable table from the binary data. */
3703:../FreeRTOS/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3704:../FreeRTOS/tasks.c **** 			{
3705:../FreeRTOS/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3706:../FreeRTOS/tasks.c **** 				{
3707:../FreeRTOS/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
3708:../FreeRTOS/tasks.c **** 										break;
3709:../FreeRTOS/tasks.c **** 
3710:../FreeRTOS/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3711:../FreeRTOS/tasks.c **** 										break;
3712:../FreeRTOS/tasks.c **** 
3713:../FreeRTOS/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3714:../FreeRTOS/tasks.c **** 										break;
3715:../FreeRTOS/tasks.c **** 
3716:../FreeRTOS/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
3717:../FreeRTOS/tasks.c **** 										break;
3718:../FreeRTOS/tasks.c **** 
3719:../FreeRTOS/tasks.c **** 					default:			/* Should not get here, but it is included
3720:../FreeRTOS/tasks.c **** 										to prevent static checking errors. */
3721:../FreeRTOS/tasks.c **** 										cStatus = 0x00;
3722:../FreeRTOS/tasks.c **** 										break;
3723:../FreeRTOS/tasks.c **** 				}
3724:../FreeRTOS/tasks.c **** 
3725:../FreeRTOS/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
3726:../FreeRTOS/tasks.c **** 				can be printed in tabular form more easily. */
3727:../FreeRTOS/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3728:../FreeRTOS/tasks.c **** 
3729:../FreeRTOS/tasks.c **** 				/* Write the rest of the string. */
3730:../FreeRTOS/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
3731:../FreeRTOS/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3732:../FreeRTOS/tasks.c **** 			}
3733:../FreeRTOS/tasks.c **** 
3734:../FreeRTOS/tasks.c **** 			/* Free the array again. */
3735:../FreeRTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
3736:../FreeRTOS/tasks.c **** 		}
3737:../FreeRTOS/tasks.c **** 		else
3738:../FreeRTOS/tasks.c **** 		{
3739:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3740:../FreeRTOS/tasks.c **** 		}
3741:../FreeRTOS/tasks.c **** 	}
3742:../FreeRTOS/tasks.c **** 
3743:../FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3744:../FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
3745:../FreeRTOS/tasks.c **** 
3746:../FreeRTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3747:../FreeRTOS/tasks.c **** 
3748:../FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3749:../FreeRTOS/tasks.c **** 	{
3750:../FreeRTOS/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3751:../FreeRTOS/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3752:../FreeRTOS/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3753:../FreeRTOS/tasks.c **** 
3754:../FreeRTOS/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3755:../FreeRTOS/tasks.c **** 		{
3756:../FreeRTOS/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3757:../FreeRTOS/tasks.c **** 		}
3758:../FreeRTOS/tasks.c **** 		#endif
3759:../FreeRTOS/tasks.c **** 
3760:../FreeRTOS/tasks.c **** 		/*
3761:../FreeRTOS/tasks.c **** 		 * PLEASE NOTE:
3762:../FreeRTOS/tasks.c **** 		 *
3763:../FreeRTOS/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3764:../FreeRTOS/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3765:../FreeRTOS/tasks.c **** 		 * scheduler.
3766:../FreeRTOS/tasks.c **** 		 *
3767:../FreeRTOS/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3768:../FreeRTOS/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3769:../FreeRTOS/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3770:../FreeRTOS/tasks.c **** 		 * in both absolute and percentage terms.
3771:../FreeRTOS/tasks.c **** 		 *
3772:../FreeRTOS/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3773:../FreeRTOS/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3774:../FreeRTOS/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3775:../FreeRTOS/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3776:../FreeRTOS/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3777:../FreeRTOS/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3778:../FreeRTOS/tasks.c **** 		 * a full snprintf() implementation!).
3779:../FreeRTOS/tasks.c **** 		 *
3780:../FreeRTOS/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3781:../FreeRTOS/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3782:../FreeRTOS/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3783:../FreeRTOS/tasks.c **** 		 */
3784:../FreeRTOS/tasks.c **** 
3785:../FreeRTOS/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3786:../FreeRTOS/tasks.c **** 		*pcWriteBuffer = 0x00;
3787:../FreeRTOS/tasks.c **** 
3788:../FreeRTOS/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3789:../FreeRTOS/tasks.c **** 		function is executing. */
3790:../FreeRTOS/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3791:../FreeRTOS/tasks.c **** 
3792:../FreeRTOS/tasks.c **** 		/* Allocate an array index for each task. */
3793:../FreeRTOS/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3794:../FreeRTOS/tasks.c **** 
3795:../FreeRTOS/tasks.c **** 		if( pxTaskStatusArray != NULL )
3796:../FreeRTOS/tasks.c **** 		{
3797:../FreeRTOS/tasks.c **** 			/* Generate the (binary) data. */
3798:../FreeRTOS/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3799:../FreeRTOS/tasks.c **** 
3800:../FreeRTOS/tasks.c **** 			/* For percentage calculations. */
3801:../FreeRTOS/tasks.c **** 			ulTotalTime /= 100UL;
3802:../FreeRTOS/tasks.c **** 
3803:../FreeRTOS/tasks.c **** 			/* Avoid divide by zero errors. */
3804:../FreeRTOS/tasks.c **** 			if( ulTotalTime > 0 )
3805:../FreeRTOS/tasks.c **** 			{
3806:../FreeRTOS/tasks.c **** 				/* Create a human readable table from the binary data. */
3807:../FreeRTOS/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3808:../FreeRTOS/tasks.c **** 				{
3809:../FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
3810:../FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
3811:../FreeRTOS/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3812:../FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3813:../FreeRTOS/tasks.c **** 
3814:../FreeRTOS/tasks.c **** 					/* Write the task name to the string, padding with
3815:../FreeRTOS/tasks.c **** 					spaces so it can be printed in tabular form more
3816:../FreeRTOS/tasks.c **** 					easily. */
3817:../FreeRTOS/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3818:../FreeRTOS/tasks.c **** 
3819:../FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3820:../FreeRTOS/tasks.c **** 					{
3821:../FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3822:../FreeRTOS/tasks.c **** 						{
3823:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
3824:../FreeRTOS/tasks.c **** 						}
3825:../FreeRTOS/tasks.c **** 						#else
3826:../FreeRTOS/tasks.c **** 						{
3827:../FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3828:../FreeRTOS/tasks.c **** 							printf() library can be used. */
3829:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3830:../FreeRTOS/tasks.c **** 						}
3831:../FreeRTOS/tasks.c **** 						#endif
3832:../FreeRTOS/tasks.c **** 					}
3833:../FreeRTOS/tasks.c **** 					else
3834:../FreeRTOS/tasks.c **** 					{
3835:../FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
3836:../FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
3837:../FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3838:../FreeRTOS/tasks.c **** 						{
3839:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
3840:../FreeRTOS/tasks.c **** 						}
3841:../FreeRTOS/tasks.c **** 						#else
3842:../FreeRTOS/tasks.c **** 						{
3843:../FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3844:../FreeRTOS/tasks.c **** 							printf() library can be used. */
3845:../FreeRTOS/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3846:../FreeRTOS/tasks.c **** 						}
3847:../FreeRTOS/tasks.c **** 						#endif
3848:../FreeRTOS/tasks.c **** 					}
3849:../FreeRTOS/tasks.c **** 
3850:../FreeRTOS/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
3851:../FreeRTOS/tasks.c **** 				}
3852:../FreeRTOS/tasks.c **** 			}
3853:../FreeRTOS/tasks.c **** 			else
3854:../FreeRTOS/tasks.c **** 			{
3855:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3856:../FreeRTOS/tasks.c **** 			}
3857:../FreeRTOS/tasks.c **** 
3858:../FreeRTOS/tasks.c **** 			/* Free the array again. */
3859:../FreeRTOS/tasks.c **** 			vPortFree( pxTaskStatusArray );
3860:../FreeRTOS/tasks.c **** 		}
3861:../FreeRTOS/tasks.c **** 		else
3862:../FreeRTOS/tasks.c **** 		{
3863:../FreeRTOS/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3864:../FreeRTOS/tasks.c **** 		}
3865:../FreeRTOS/tasks.c **** 	}
3866:../FreeRTOS/tasks.c **** 
3867:../FreeRTOS/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
3868:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3869:../FreeRTOS/tasks.c **** 
3870:../FreeRTOS/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3871:../FreeRTOS/tasks.c **** {
 5003              		.loc 1 3871 0
 5004              		.cfi_startproc
 5005              		@ args = 0, pretend = 0, frame = 8
 5006              		@ frame_needed = 1, uses_anonymous_args = 0
 5007              		@ link register save eliminated.
 5008 0000 80B4     		push	{r7}
 5009              		.cfi_def_cfa_offset 4
 5010              		.cfi_offset 7, -4
 5011 0002 83B0     		sub	sp, sp, #12
 5012              		.cfi_def_cfa_offset 16
 5013 0004 00AF     		add	r7, sp, #0
 5014              		.cfi_def_cfa_register 7
3872:../FreeRTOS/tasks.c **** TickType_t uxReturn;
3873:../FreeRTOS/tasks.c **** 
3874:../FreeRTOS/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 5015              		.loc 1 3874 0
 5016 0006 094B     		ldr	r3, .L350
 5017 0008 1B68     		ldr	r3, [r3]
 5018 000a 9B69     		ldr	r3, [r3, #24]
 5019 000c 7B60     		str	r3, [r7, #4]
3875:../FreeRTOS/tasks.c **** 
3876:../FreeRTOS/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
3877:../FreeRTOS/tasks.c **** 	queues and semaphores. */
3878:../FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 5020              		.loc 1 3878 0
 5021 000e 074B     		ldr	r3, .L350
 5022 0010 1B68     		ldr	r3, [r3]
 5023 0012 064A     		ldr	r2, .L350
 5024 0014 1268     		ldr	r2, [r2]
 5025 0016 D26A     		ldr	r2, [r2, #44]
 5026 0018 C2F10802 		rsb	r2, r2, #8
 5027 001c 9A61     		str	r2, [r3, #24]
3879:../FreeRTOS/tasks.c **** 
3880:../FreeRTOS/tasks.c **** 	return uxReturn;
 5028              		.loc 1 3880 0
 5029 001e 7B68     		ldr	r3, [r7, #4]
3881:../FreeRTOS/tasks.c **** }
 5030              		.loc 1 3881 0
 5031 0020 1846     		mov	r0, r3
 5032 0022 0C37     		adds	r7, r7, #12
 5033              		.cfi_def_cfa_offset 4
 5034 0024 BD46     		mov	sp, r7
 5035              		.cfi_def_cfa_register 13
 5036              		@ sp needed
 5037 0026 5DF8047B 		ldr	r7, [sp], #4
 5038              		.cfi_restore 7
 5039              		.cfi_def_cfa_offset 0
 5040 002a 7047     		bx	lr
 5041              	.L351:
 5042              		.align	2
 5043              	.L350:
 5044 002c 00000000 		.word	pxCurrentTCB
 5045              		.cfi_endproc
 5046              	.LFE47:
 5048              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 5049              		.align	2
 5050              		.global	pvTaskIncrementMutexHeldCount
 5051              		.thumb
 5052              		.thumb_func
 5054              	pvTaskIncrementMutexHeldCount:
 5055              	.LFB48:
3882:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3883:../FreeRTOS/tasks.c **** 
3884:../FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3885:../FreeRTOS/tasks.c **** 
3886:../FreeRTOS/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
3887:../FreeRTOS/tasks.c **** 	{
 5056              		.loc 1 3887 0
 5057              		.cfi_startproc
 5058              		@ args = 0, pretend = 0, frame = 0
 5059              		@ frame_needed = 1, uses_anonymous_args = 0
 5060              		@ link register save eliminated.
 5061 0000 80B4     		push	{r7}
 5062              		.cfi_def_cfa_offset 4
 5063              		.cfi_offset 7, -4
 5064 0002 00AF     		add	r7, sp, #0
 5065              		.cfi_def_cfa_register 7
3888:../FreeRTOS/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
3889:../FreeRTOS/tasks.c **** 		then pxCurrentTCB will be NULL. */
3890:../FreeRTOS/tasks.c **** 		if( pxCurrentTCB != NULL )
 5066              		.loc 1 3890 0
 5067 0004 074B     		ldr	r3, .L355
 5068 0006 1B68     		ldr	r3, [r3]
 5069 0008 002B     		cmp	r3, #0
 5070 000a 04D0     		beq	.L353
3891:../FreeRTOS/tasks.c **** 		{
3892:../FreeRTOS/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 5071              		.loc 1 3892 0
 5072 000c 054B     		ldr	r3, .L355
 5073 000e 1B68     		ldr	r3, [r3]
 5074 0010 DA6D     		ldr	r2, [r3, #92]
 5075 0012 0132     		adds	r2, r2, #1
 5076 0014 DA65     		str	r2, [r3, #92]
 5077              	.L353:
3893:../FreeRTOS/tasks.c **** 		}
3894:../FreeRTOS/tasks.c **** 
3895:../FreeRTOS/tasks.c **** 		return pxCurrentTCB;
 5078              		.loc 1 3895 0
 5079 0016 034B     		ldr	r3, .L355
 5080 0018 1B68     		ldr	r3, [r3]
3896:../FreeRTOS/tasks.c **** 	}
 5081              		.loc 1 3896 0
 5082 001a 1846     		mov	r0, r3
 5083 001c BD46     		mov	sp, r7
 5084              		.cfi_def_cfa_register 13
 5085              		@ sp needed
 5086 001e 5DF8047B 		ldr	r7, [sp], #4
 5087              		.cfi_restore 7
 5088              		.cfi_def_cfa_offset 0
 5089 0022 7047     		bx	lr
 5090              	.L356:
 5091              		.align	2
 5092              	.L355:
 5093 0024 00000000 		.word	pxCurrentTCB
 5094              		.cfi_endproc
 5095              	.LFE48:
 5097              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 5098              		.align	2
 5099              		.global	ulTaskNotifyTake
 5100              		.thumb
 5101              		.thumb_func
 5103              	ulTaskNotifyTake:
 5104              	.LFB49:
3897:../FreeRTOS/tasks.c **** 
3898:../FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
3899:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3900:../FreeRTOS/tasks.c **** 
3901:../FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
3902:../FreeRTOS/tasks.c **** 
3903:../FreeRTOS/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
3904:../FreeRTOS/tasks.c **** 	{
 5105              		.loc 1 3904 0
 5106              		.cfi_startproc
 5107              		@ args = 0, pretend = 0, frame = 16
 5108              		@ frame_needed = 1, uses_anonymous_args = 0
 5109 0000 80B5     		push	{r7, lr}
 5110              		.cfi_def_cfa_offset 8
 5111              		.cfi_offset 7, -8
 5112              		.cfi_offset 14, -4
 5113 0002 84B0     		sub	sp, sp, #16
 5114              		.cfi_def_cfa_offset 24
 5115 0004 00AF     		add	r7, sp, #0
 5116              		.cfi_def_cfa_register 7
 5117 0006 7860     		str	r0, [r7, #4]
 5118 0008 3960     		str	r1, [r7]
3905:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
3906:../FreeRTOS/tasks.c **** 	uint32_t ulReturn;
3907:../FreeRTOS/tasks.c **** 
3908:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5119              		.loc 1 3908 0
 5120 000a FFF7FEFF 		bl	vPortEnterCritical
3909:../FreeRTOS/tasks.c **** 		{
3910:../FreeRTOS/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
3911:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 5121              		.loc 1 3911 0
 5122 000e 314B     		ldr	r3, .L366
 5123 0010 1B68     		ldr	r3, [r3]
 5124 0012 1B6E     		ldr	r3, [r3, #96]
 5125 0014 002B     		cmp	r3, #0
 5126 0016 38D1     		bne	.L358
3912:../FreeRTOS/tasks.c **** 			{
3913:../FreeRTOS/tasks.c **** 				/* Mark this task as waiting for a notification. */
3914:../FreeRTOS/tasks.c **** 				pxCurrentTCB->eNotifyState = eWaitingNotification;
 5127              		.loc 1 3914 0
 5128 0018 2E4B     		ldr	r3, .L366
 5129 001a 1B68     		ldr	r3, [r3]
 5130 001c 0122     		movs	r2, #1
 5131 001e 83F86420 		strb	r2, [r3, #100]
3915:../FreeRTOS/tasks.c **** 
3916:../FreeRTOS/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 5132              		.loc 1 3916 0
 5133 0022 3B68     		ldr	r3, [r7]
 5134 0024 002B     		cmp	r3, #0
 5135 0026 30D0     		beq	.L358
3917:../FreeRTOS/tasks.c **** 				{
3918:../FreeRTOS/tasks.c **** 					/* The task is going to block.  First it must be removed
3919:../FreeRTOS/tasks.c **** 					from the ready list. */
3920:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 5136              		.loc 1 3920 0
 5137 0028 2A4B     		ldr	r3, .L366
 5138 002a 1B68     		ldr	r3, [r3]
 5139 002c 0433     		adds	r3, r3, #4
 5140 002e 1846     		mov	r0, r3
 5141 0030 FFF7FEFF 		bl	uxListRemove
 5142 0034 0346     		mov	r3, r0
 5143 0036 002B     		cmp	r3, #0
 5144 0038 0BD1     		bne	.L359
3921:../FreeRTOS/tasks.c **** 					{
3922:../FreeRTOS/tasks.c **** 						/* The current task must be in a ready list, so there is
3923:../FreeRTOS/tasks.c **** 						no need to check, and the port reset macro can be called
3924:../FreeRTOS/tasks.c **** 						directly. */
3925:../FreeRTOS/tasks.c **** 						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 5145              		.loc 1 3925 0
 5146 003a 264B     		ldr	r3, .L366
 5147 003c 1B68     		ldr	r3, [r3]
 5148 003e DB6A     		ldr	r3, [r3, #44]
 5149 0040 1A46     		mov	r2, r3
 5150 0042 0123     		movs	r3, #1
 5151 0044 9340     		lsls	r3, r3, r2
 5152 0046 DA43     		mvns	r2, r3
 5153 0048 234B     		ldr	r3, .L366+4
 5154 004a 1B68     		ldr	r3, [r3]
 5155 004c 1340     		ands	r3, r3, r2
 5156 004e 224A     		ldr	r2, .L366+4
 5157 0050 1360     		str	r3, [r2]
 5158              	.L359:
3926:../FreeRTOS/tasks.c **** 					}
3927:../FreeRTOS/tasks.c **** 					else
3928:../FreeRTOS/tasks.c **** 					{
3929:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3930:../FreeRTOS/tasks.c **** 					}
3931:../FreeRTOS/tasks.c **** 
3932:../FreeRTOS/tasks.c **** 					#if ( INCLUDE_vTaskSuspend == 1 )
3933:../FreeRTOS/tasks.c **** 					{
3934:../FreeRTOS/tasks.c **** 						if( xTicksToWait == portMAX_DELAY )
 5159              		.loc 1 3934 0
 5160 0052 3B68     		ldr	r3, [r7]
 5161 0054 B3F1FF3F 		cmp	r3, #-1
 5162 0058 07D1     		bne	.L360
3935:../FreeRTOS/tasks.c **** 						{
3936:../FreeRTOS/tasks.c **** 							/* Add the task to the suspended task list instead
3937:../FreeRTOS/tasks.c **** 							of a delayed task list to ensure the task is not
3938:../FreeRTOS/tasks.c **** 							woken by a timing event.  It will block
3939:../FreeRTOS/tasks.c **** 							indefinitely. */
3940:../FreeRTOS/tasks.c **** 							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 5163              		.loc 1 3940 0
 5164 005a 1E4B     		ldr	r3, .L366
 5165 005c 1B68     		ldr	r3, [r3]
 5166 005e 0433     		adds	r3, r3, #4
 5167 0060 1E48     		ldr	r0, .L366+8
 5168 0062 1946     		mov	r1, r3
 5169 0064 FFF7FEFF 		bl	vListInsertEnd
 5170 0068 07E0     		b	.L361
 5171              	.L360:
3941:../FreeRTOS/tasks.c **** 						}
3942:../FreeRTOS/tasks.c **** 						else
3943:../FreeRTOS/tasks.c **** 						{
3944:../FreeRTOS/tasks.c **** 							/* Calculate the time at which the task should be
3945:../FreeRTOS/tasks.c **** 							woken if no notification events occur.  This may
3946:../FreeRTOS/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3947:../FreeRTOS/tasks.c **** 							handle it. */
3948:../FreeRTOS/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
 5172              		.loc 1 3948 0
 5173 006a 1D4B     		ldr	r3, .L366+12
 5174 006c 1A68     		ldr	r2, [r3]
 5175 006e 3B68     		ldr	r3, [r7]
 5176 0070 1344     		add	r3, r3, r2
 5177 0072 FB60     		str	r3, [r7, #12]
3949:../FreeRTOS/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
 5178              		.loc 1 3949 0
 5179 0074 F868     		ldr	r0, [r7, #12]
 5180 0076 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 5181              	.L361:
3950:../FreeRTOS/tasks.c **** 						}
3951:../FreeRTOS/tasks.c **** 					}
3952:../FreeRTOS/tasks.c **** 					#else /* INCLUDE_vTaskSuspend */
3953:../FreeRTOS/tasks.c **** 					{
3954:../FreeRTOS/tasks.c **** 							/* Calculate the time at which the task should be
3955:../FreeRTOS/tasks.c **** 							woken if the event does not occur.  This may
3956:../FreeRTOS/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3957:../FreeRTOS/tasks.c **** 							handle it. */
3958:../FreeRTOS/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
3959:../FreeRTOS/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
3960:../FreeRTOS/tasks.c **** 					}
3961:../FreeRTOS/tasks.c **** 					#endif /* INCLUDE_vTaskSuspend */
3962:../FreeRTOS/tasks.c **** 
3963:../FreeRTOS/tasks.c **** 					/* All ports are written to allow a yield in a critical
3964:../FreeRTOS/tasks.c **** 					section (some will yield immediately, others wait until the
3965:../FreeRTOS/tasks.c **** 					critical section exits) - but it is not something that
3966:../FreeRTOS/tasks.c **** 					application code should ever do. */
3967:../FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 5182              		.loc 1 3967 0
 5183 007a 1A4B     		ldr	r3, .L366+16
 5184 007c 4FF08052 		mov	r2, #268435456
 5185 0080 1A60     		str	r2, [r3]
 5186              	@ 3967 "../FreeRTOS/tasks.c" 1
 5187 0082 BFF34F8F 		dsb
 5188              	@ 0 "" 2
 5189              	@ 3967 "../FreeRTOS/tasks.c" 1
 5190 0086 BFF36F8F 		isb
 5191              	@ 0 "" 2
 5192              		.thumb
 5193              	.L358:
3968:../FreeRTOS/tasks.c **** 				}
3969:../FreeRTOS/tasks.c **** 				else
3970:../FreeRTOS/tasks.c **** 				{
3971:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3972:../FreeRTOS/tasks.c **** 				}
3973:../FreeRTOS/tasks.c **** 			}
3974:../FreeRTOS/tasks.c **** 			else
3975:../FreeRTOS/tasks.c **** 			{
3976:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3977:../FreeRTOS/tasks.c **** 			}
3978:../FreeRTOS/tasks.c **** 		}
3979:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5194              		.loc 1 3979 0
 5195 008a FFF7FEFF 		bl	vPortExitCritical
3980:../FreeRTOS/tasks.c **** 
3981:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5196              		.loc 1 3981 0
 5197 008e FFF7FEFF 		bl	vPortEnterCritical
3982:../FreeRTOS/tasks.c **** 		{
3983:../FreeRTOS/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 5198              		.loc 1 3983 0
 5199 0092 104B     		ldr	r3, .L366
 5200 0094 1B68     		ldr	r3, [r3]
 5201 0096 1B6E     		ldr	r3, [r3, #96]
 5202 0098 BB60     		str	r3, [r7, #8]
3984:../FreeRTOS/tasks.c **** 
3985:../FreeRTOS/tasks.c **** 			if( ulReturn != 0UL )
 5203              		.loc 1 3985 0
 5204 009a BB68     		ldr	r3, [r7, #8]
 5205 009c 002B     		cmp	r3, #0
 5206 009e 0CD0     		beq	.L362
3986:../FreeRTOS/tasks.c **** 			{
3987:../FreeRTOS/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 5207              		.loc 1 3987 0
 5208 00a0 7B68     		ldr	r3, [r7, #4]
 5209 00a2 002B     		cmp	r3, #0
 5210 00a4 04D0     		beq	.L363
3988:../FreeRTOS/tasks.c **** 				{
3989:../FreeRTOS/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 5211              		.loc 1 3989 0
 5212 00a6 0B4B     		ldr	r3, .L366
 5213 00a8 1B68     		ldr	r3, [r3]
 5214 00aa 0022     		movs	r2, #0
 5215 00ac 1A66     		str	r2, [r3, #96]
 5216 00ae 04E0     		b	.L362
 5217              	.L363:
3990:../FreeRTOS/tasks.c **** 				}
3991:../FreeRTOS/tasks.c **** 				else
3992:../FreeRTOS/tasks.c **** 				{
3993:../FreeRTOS/tasks.c **** 					( pxCurrentTCB->ulNotifiedValue )--;
 5218              		.loc 1 3993 0
 5219 00b0 084B     		ldr	r3, .L366
 5220 00b2 1B68     		ldr	r3, [r3]
 5221 00b4 1A6E     		ldr	r2, [r3, #96]
 5222 00b6 013A     		subs	r2, r2, #1
 5223 00b8 1A66     		str	r2, [r3, #96]
 5224              	.L362:
3994:../FreeRTOS/tasks.c **** 				}
3995:../FreeRTOS/tasks.c **** 			}
3996:../FreeRTOS/tasks.c **** 			else
3997:../FreeRTOS/tasks.c **** 			{
3998:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3999:../FreeRTOS/tasks.c **** 			}
4000:../FreeRTOS/tasks.c **** 
4001:../FreeRTOS/tasks.c **** 			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 5225              		.loc 1 4001 0
 5226 00ba 064B     		ldr	r3, .L366
 5227 00bc 1B68     		ldr	r3, [r3]
 5228 00be 0022     		movs	r2, #0
 5229 00c0 83F86420 		strb	r2, [r3, #100]
4002:../FreeRTOS/tasks.c **** 		}
4003:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5230              		.loc 1 4003 0
 5231 00c4 FFF7FEFF 		bl	vPortExitCritical
4004:../FreeRTOS/tasks.c **** 
4005:../FreeRTOS/tasks.c **** 		return ulReturn;
 5232              		.loc 1 4005 0
 5233 00c8 BB68     		ldr	r3, [r7, #8]
4006:../FreeRTOS/tasks.c **** 	}
 5234              		.loc 1 4006 0
 5235 00ca 1846     		mov	r0, r3
 5236 00cc 1037     		adds	r7, r7, #16
 5237              		.cfi_def_cfa_offset 8
 5238 00ce BD46     		mov	sp, r7
 5239              		.cfi_def_cfa_register 13
 5240              		@ sp needed
 5241 00d0 80BD     		pop	{r7, pc}
 5242              	.L367:
 5243 00d2 00BF     		.align	2
 5244              	.L366:
 5245 00d4 00000000 		.word	pxCurrentTCB
 5246 00d8 00000000 		.word	uxTopReadyPriority
 5247 00dc 00000000 		.word	xSuspendedTaskList
 5248 00e0 00000000 		.word	xTickCount
 5249 00e4 04ED00E0 		.word	-536810236
 5250              		.cfi_endproc
 5251              	.LFE49:
 5253              		.section	.text.xTaskNotifyWait,"ax",%progbits
 5254              		.align	2
 5255              		.global	xTaskNotifyWait
 5256              		.thumb
 5257              		.thumb_func
 5259              	xTaskNotifyWait:
 5260              	.LFB50:
4007:../FreeRTOS/tasks.c **** 
4008:../FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4009:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4010:../FreeRTOS/tasks.c **** 
4011:../FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4012:../FreeRTOS/tasks.c **** 
4013:../FreeRTOS/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4014:../FreeRTOS/tasks.c **** 	{
 5261              		.loc 1 4014 0
 5262              		.cfi_startproc
 5263              		@ args = 0, pretend = 0, frame = 24
 5264              		@ frame_needed = 1, uses_anonymous_args = 0
 5265 0000 80B5     		push	{r7, lr}
 5266              		.cfi_def_cfa_offset 8
 5267              		.cfi_offset 7, -8
 5268              		.cfi_offset 14, -4
 5269 0002 86B0     		sub	sp, sp, #24
 5270              		.cfi_def_cfa_offset 32
 5271 0004 00AF     		add	r7, sp, #0
 5272              		.cfi_def_cfa_register 7
 5273 0006 F860     		str	r0, [r7, #12]
 5274 0008 B960     		str	r1, [r7, #8]
 5275 000a 7A60     		str	r2, [r7, #4]
 5276 000c 3B60     		str	r3, [r7]
4015:../FreeRTOS/tasks.c **** 	TickType_t xTimeToWake;
4016:../FreeRTOS/tasks.c **** 	BaseType_t xReturn;
4017:../FreeRTOS/tasks.c **** 
4018:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5277              		.loc 1 4018 0
 5278 000e FFF7FEFF 		bl	vPortEnterCritical
4019:../FreeRTOS/tasks.c **** 		{
4020:../FreeRTOS/tasks.c **** 			/* Only block if a notification is not already pending. */
4021:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->eNotifyState != eNotified )
 5279              		.loc 1 4021 0
 5280 0012 394B     		ldr	r3, .L377
 5281 0014 1B68     		ldr	r3, [r3]
 5282 0016 93F86430 		ldrb	r3, [r3, #100]
 5283 001a DBB2     		uxtb	r3, r3
 5284 001c 022B     		cmp	r3, #2
 5285 001e 3FD0     		beq	.L369
4022:../FreeRTOS/tasks.c **** 			{
4023:../FreeRTOS/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4024:../FreeRTOS/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4025:../FreeRTOS/tasks.c **** 				clear the value to zero. */
4026:../FreeRTOS/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 5286              		.loc 1 4026 0
 5287 0020 354B     		ldr	r3, .L377
 5288 0022 1B68     		ldr	r3, [r3]
 5289 0024 196E     		ldr	r1, [r3, #96]
 5290 0026 FA68     		ldr	r2, [r7, #12]
 5291 0028 D243     		mvns	r2, r2
 5292 002a 0A40     		ands	r2, r2, r1
 5293 002c 1A66     		str	r2, [r3, #96]
4027:../FreeRTOS/tasks.c **** 
4028:../FreeRTOS/tasks.c **** 				/* Mark this task as waiting for a notification. */
4029:../FreeRTOS/tasks.c **** 				pxCurrentTCB->eNotifyState = eWaitingNotification;
 5294              		.loc 1 4029 0
 5295 002e 324B     		ldr	r3, .L377
 5296 0030 1B68     		ldr	r3, [r3]
 5297 0032 0122     		movs	r2, #1
 5298 0034 83F86420 		strb	r2, [r3, #100]
4030:../FreeRTOS/tasks.c **** 
4031:../FreeRTOS/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 5299              		.loc 1 4031 0
 5300 0038 3B68     		ldr	r3, [r7]
 5301 003a 002B     		cmp	r3, #0
 5302 003c 30D0     		beq	.L369
4032:../FreeRTOS/tasks.c **** 				{
4033:../FreeRTOS/tasks.c **** 					/* The task is going to block.  First it must be removed
4034:../FreeRTOS/tasks.c **** 					from the	ready list. */
4035:../FreeRTOS/tasks.c **** 					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 5303              		.loc 1 4035 0
 5304 003e 2E4B     		ldr	r3, .L377
 5305 0040 1B68     		ldr	r3, [r3]
 5306 0042 0433     		adds	r3, r3, #4
 5307 0044 1846     		mov	r0, r3
 5308 0046 FFF7FEFF 		bl	uxListRemove
 5309 004a 0346     		mov	r3, r0
 5310 004c 002B     		cmp	r3, #0
 5311 004e 0BD1     		bne	.L370
4036:../FreeRTOS/tasks.c **** 					{
4037:../FreeRTOS/tasks.c **** 						/* The current task must be in a ready list, so there is
4038:../FreeRTOS/tasks.c **** 						no need to check, and the port reset macro can be called
4039:../FreeRTOS/tasks.c **** 						directly. */
4040:../FreeRTOS/tasks.c **** 						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 5312              		.loc 1 4040 0
 5313 0050 294B     		ldr	r3, .L377
 5314 0052 1B68     		ldr	r3, [r3]
 5315 0054 DB6A     		ldr	r3, [r3, #44]
 5316 0056 1A46     		mov	r2, r3
 5317 0058 0123     		movs	r3, #1
 5318 005a 9340     		lsls	r3, r3, r2
 5319 005c DA43     		mvns	r2, r3
 5320 005e 274B     		ldr	r3, .L377+4
 5321 0060 1B68     		ldr	r3, [r3]
 5322 0062 1340     		ands	r3, r3, r2
 5323 0064 254A     		ldr	r2, .L377+4
 5324 0066 1360     		str	r3, [r2]
 5325              	.L370:
4041:../FreeRTOS/tasks.c **** 					}
4042:../FreeRTOS/tasks.c **** 					else
4043:../FreeRTOS/tasks.c **** 					{
4044:../FreeRTOS/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4045:../FreeRTOS/tasks.c **** 					}
4046:../FreeRTOS/tasks.c **** 
4047:../FreeRTOS/tasks.c **** 					#if ( INCLUDE_vTaskSuspend == 1 )
4048:../FreeRTOS/tasks.c **** 					{
4049:../FreeRTOS/tasks.c **** 						if( xTicksToWait == portMAX_DELAY )
 5326              		.loc 1 4049 0
 5327 0068 3B68     		ldr	r3, [r7]
 5328 006a B3F1FF3F 		cmp	r3, #-1
 5329 006e 07D1     		bne	.L371
4050:../FreeRTOS/tasks.c **** 						{
4051:../FreeRTOS/tasks.c **** 							/* Add the task to the suspended task list instead
4052:../FreeRTOS/tasks.c **** 							of a delayed task list to ensure the task is not
4053:../FreeRTOS/tasks.c **** 							woken by a timing event.  It will block
4054:../FreeRTOS/tasks.c **** 							indefinitely. */
4055:../FreeRTOS/tasks.c **** 							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 5330              		.loc 1 4055 0
 5331 0070 214B     		ldr	r3, .L377
 5332 0072 1B68     		ldr	r3, [r3]
 5333 0074 0433     		adds	r3, r3, #4
 5334 0076 2248     		ldr	r0, .L377+8
 5335 0078 1946     		mov	r1, r3
 5336 007a FFF7FEFF 		bl	vListInsertEnd
 5337 007e 07E0     		b	.L372
 5338              	.L371:
4056:../FreeRTOS/tasks.c **** 						}
4057:../FreeRTOS/tasks.c **** 						else
4058:../FreeRTOS/tasks.c **** 						{
4059:../FreeRTOS/tasks.c **** 							/* Calculate the time at which the task should be
4060:../FreeRTOS/tasks.c **** 							woken if no notification events occur.  This may
4061:../FreeRTOS/tasks.c **** 							overflow but this doesn't matter, the scheduler will
4062:../FreeRTOS/tasks.c **** 							handle it. */
4063:../FreeRTOS/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
 5339              		.loc 1 4063 0
 5340 0080 204B     		ldr	r3, .L377+12
 5341 0082 1A68     		ldr	r2, [r3]
 5342 0084 3B68     		ldr	r3, [r7]
 5343 0086 1344     		add	r3, r3, r2
 5344 0088 3B61     		str	r3, [r7, #16]
4064:../FreeRTOS/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
 5345              		.loc 1 4064 0
 5346 008a 3869     		ldr	r0, [r7, #16]
 5347 008c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 5348              	.L372:
4065:../FreeRTOS/tasks.c **** 						}
4066:../FreeRTOS/tasks.c **** 					}
4067:../FreeRTOS/tasks.c **** 					#else /* INCLUDE_vTaskSuspend */
4068:../FreeRTOS/tasks.c **** 					{
4069:../FreeRTOS/tasks.c **** 							/* Calculate the time at which the task should be
4070:../FreeRTOS/tasks.c **** 							woken if the event does not occur.  This may
4071:../FreeRTOS/tasks.c **** 							overflow but this doesn't matter, the scheduler will
4072:../FreeRTOS/tasks.c **** 							handle it. */
4073:../FreeRTOS/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
4074:../FreeRTOS/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
4075:../FreeRTOS/tasks.c **** 					}
4076:../FreeRTOS/tasks.c **** 					#endif /* INCLUDE_vTaskSuspend */
4077:../FreeRTOS/tasks.c **** 
4078:../FreeRTOS/tasks.c **** 					/* All ports are written to allow a yield in a critical
4079:../FreeRTOS/tasks.c **** 					section (some will yield immediately, others wait until the
4080:../FreeRTOS/tasks.c **** 					critical section exits) - but it is not something that
4081:../FreeRTOS/tasks.c **** 					application code should ever do. */
4082:../FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 5349              		.loc 1 4082 0
 5350 0090 1D4B     		ldr	r3, .L377+16
 5351 0092 4FF08052 		mov	r2, #268435456
 5352 0096 1A60     		str	r2, [r3]
 5353              	@ 4082 "../FreeRTOS/tasks.c" 1
 5354 0098 BFF34F8F 		dsb
 5355              	@ 0 "" 2
 5356              	@ 4082 "../FreeRTOS/tasks.c" 1
 5357 009c BFF36F8F 		isb
 5358              	@ 0 "" 2
 5359              		.thumb
 5360              	.L369:
4083:../FreeRTOS/tasks.c **** 				}
4084:../FreeRTOS/tasks.c **** 				else
4085:../FreeRTOS/tasks.c **** 				{
4086:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4087:../FreeRTOS/tasks.c **** 				}
4088:../FreeRTOS/tasks.c **** 			}
4089:../FreeRTOS/tasks.c **** 			else
4090:../FreeRTOS/tasks.c **** 			{
4091:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4092:../FreeRTOS/tasks.c **** 			}
4093:../FreeRTOS/tasks.c **** 		}
4094:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5361              		.loc 1 4094 0
 5362 00a0 FFF7FEFF 		bl	vPortExitCritical
4095:../FreeRTOS/tasks.c **** 
4096:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5363              		.loc 1 4096 0
 5364 00a4 FFF7FEFF 		bl	vPortEnterCritical
4097:../FreeRTOS/tasks.c **** 		{
4098:../FreeRTOS/tasks.c **** 			if( pulNotificationValue != NULL )
 5365              		.loc 1 4098 0
 5366 00a8 7B68     		ldr	r3, [r7, #4]
 5367 00aa 002B     		cmp	r3, #0
 5368 00ac 04D0     		beq	.L373
4099:../FreeRTOS/tasks.c **** 			{
4100:../FreeRTOS/tasks.c **** 				/* Output the current notification value, which may or may not
4101:../FreeRTOS/tasks.c **** 				have changed. */
4102:../FreeRTOS/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 5369              		.loc 1 4102 0
 5370 00ae 124B     		ldr	r3, .L377
 5371 00b0 1B68     		ldr	r3, [r3]
 5372 00b2 1A6E     		ldr	r2, [r3, #96]
 5373 00b4 7B68     		ldr	r3, [r7, #4]
 5374 00b6 1A60     		str	r2, [r3]
 5375              	.L373:
4103:../FreeRTOS/tasks.c **** 			}
4104:../FreeRTOS/tasks.c **** 
4105:../FreeRTOS/tasks.c **** 			/* If eNotifyValue is set then either the task never entered the
4106:../FreeRTOS/tasks.c **** 			blocked state (because a notification was already pending) or the
4107:../FreeRTOS/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4108:../FreeRTOS/tasks.c **** 			unblocked because of a timeout. */
4109:../FreeRTOS/tasks.c **** 			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
 5376              		.loc 1 4109 0
 5377 00b8 0F4B     		ldr	r3, .L377
 5378 00ba 1B68     		ldr	r3, [r3]
 5379 00bc 93F86430 		ldrb	r3, [r3, #100]
 5380 00c0 DBB2     		uxtb	r3, r3
 5381 00c2 012B     		cmp	r3, #1
 5382 00c4 02D1     		bne	.L374
4110:../FreeRTOS/tasks.c **** 			{
4111:../FreeRTOS/tasks.c **** 				/* A notification was not received. */
4112:../FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 5383              		.loc 1 4112 0
 5384 00c6 0023     		movs	r3, #0
 5385 00c8 7B61     		str	r3, [r7, #20]
 5386 00ca 08E0     		b	.L375
 5387              	.L374:
4113:../FreeRTOS/tasks.c **** 			}
4114:../FreeRTOS/tasks.c **** 			else
4115:../FreeRTOS/tasks.c **** 			{
4116:../FreeRTOS/tasks.c **** 				/* A notification was already pending or a notification was
4117:../FreeRTOS/tasks.c **** 				received while the task was waiting. */
4118:../FreeRTOS/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 5388              		.loc 1 4118 0
 5389 00cc 0A4B     		ldr	r3, .L377
 5390 00ce 1B68     		ldr	r3, [r3]
 5391 00d0 196E     		ldr	r1, [r3, #96]
 5392 00d2 BA68     		ldr	r2, [r7, #8]
 5393 00d4 D243     		mvns	r2, r2
 5394 00d6 0A40     		ands	r2, r2, r1
 5395 00d8 1A66     		str	r2, [r3, #96]
4119:../FreeRTOS/tasks.c **** 				xReturn = pdTRUE;
 5396              		.loc 1 4119 0
 5397 00da 0123     		movs	r3, #1
 5398 00dc 7B61     		str	r3, [r7, #20]
 5399              	.L375:
4120:../FreeRTOS/tasks.c **** 			}
4121:../FreeRTOS/tasks.c **** 
4122:../FreeRTOS/tasks.c **** 			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 5400              		.loc 1 4122 0
 5401 00de 064B     		ldr	r3, .L377
 5402 00e0 1B68     		ldr	r3, [r3]
 5403 00e2 0022     		movs	r2, #0
 5404 00e4 83F86420 		strb	r2, [r3, #100]
4123:../FreeRTOS/tasks.c **** 		}
4124:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5405              		.loc 1 4124 0
 5406 00e8 FFF7FEFF 		bl	vPortExitCritical
4125:../FreeRTOS/tasks.c **** 
4126:../FreeRTOS/tasks.c **** 		return xReturn;
 5407              		.loc 1 4126 0
 5408 00ec 7B69     		ldr	r3, [r7, #20]
4127:../FreeRTOS/tasks.c **** 	}
 5409              		.loc 1 4127 0
 5410 00ee 1846     		mov	r0, r3
 5411 00f0 1837     		adds	r7, r7, #24
 5412              		.cfi_def_cfa_offset 8
 5413 00f2 BD46     		mov	sp, r7
 5414              		.cfi_def_cfa_register 13
 5415              		@ sp needed
 5416 00f4 80BD     		pop	{r7, pc}
 5417              	.L378:
 5418 00f6 00BF     		.align	2
 5419              	.L377:
 5420 00f8 00000000 		.word	pxCurrentTCB
 5421 00fc 00000000 		.word	uxTopReadyPriority
 5422 0100 00000000 		.word	xSuspendedTaskList
 5423 0104 00000000 		.word	xTickCount
 5424 0108 04ED00E0 		.word	-536810236
 5425              		.cfi_endproc
 5426              	.LFE50:
 5428              		.section	.text.xTaskGenericNotify,"ax",%progbits
 5429              		.align	2
 5430              		.global	xTaskGenericNotify
 5431              		.thumb
 5432              		.thumb_func
 5434              	xTaskGenericNotify:
 5435              	.LFB51:
4128:../FreeRTOS/tasks.c **** 
4129:../FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4130:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4131:../FreeRTOS/tasks.c **** 
4132:../FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4133:../FreeRTOS/tasks.c **** 
4134:../FreeRTOS/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4135:../FreeRTOS/tasks.c **** 	{
 5436              		.loc 1 4135 0
 5437              		.cfi_startproc
 5438              		@ args = 0, pretend = 0, frame = 40
 5439              		@ frame_needed = 1, uses_anonymous_args = 0
 5440 0000 80B5     		push	{r7, lr}
 5441              		.cfi_def_cfa_offset 8
 5442              		.cfi_offset 7, -8
 5443              		.cfi_offset 14, -4
 5444 0002 8AB0     		sub	sp, sp, #40
 5445              		.cfi_def_cfa_offset 48
 5446 0004 00AF     		add	r7, sp, #0
 5447              		.cfi_def_cfa_register 7
 5448 0006 F860     		str	r0, [r7, #12]
 5449 0008 B960     		str	r1, [r7, #8]
 5450 000a 3B60     		str	r3, [r7]
 5451 000c 1346     		mov	r3, r2
 5452 000e FB71     		strb	r3, [r7, #7]
4136:../FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
4137:../FreeRTOS/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4138:../FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdPASS;
 5453              		.loc 1 4138 0
 5454 0010 0123     		movs	r3, #1
 5455 0012 7B62     		str	r3, [r7, #36]
4139:../FreeRTOS/tasks.c **** 
4140:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToNotify );
 5456              		.loc 1 4140 0
 5457 0014 FB68     		ldr	r3, [r7, #12]
 5458 0016 002B     		cmp	r3, #0
 5459 0018 09D1     		bne	.L380
 5460              	.LBB185:
 5461              	.LBB186:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5462              		.loc 2 215 0 discriminator 1
 5463              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5464 001a 4FF00703 			mov r3, #7												
 5465 001e 83F31188 		msr basepri, r3											
 5466 0022 BFF36F8F 		isb														
 5467 0026 BFF34F8F 		dsb														
 5468              	
 5469              	@ 0 "" 2
 5470              		.thumb
 5471 002a BB61     		str	r3, [r7, #24]
 5472              	.L381:
 5473              	.LBE186:
 5474              	.LBE185:
 5475              		.loc 1 4140 0 discriminator 1
 5476 002c FEE7     		b	.L381
 5477              	.L380:
4141:../FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5478              		.loc 1 4141 0
 5479 002e FB68     		ldr	r3, [r7, #12]
 5480 0030 3B62     		str	r3, [r7, #32]
4142:../FreeRTOS/tasks.c **** 
4143:../FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5481              		.loc 1 4143 0
 5482 0032 FFF7FEFF 		bl	vPortEnterCritical
4144:../FreeRTOS/tasks.c **** 		{
4145:../FreeRTOS/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 5483              		.loc 1 4145 0
 5484 0036 3B68     		ldr	r3, [r7]
 5485 0038 002B     		cmp	r3, #0
 5486 003a 03D0     		beq	.L382
4146:../FreeRTOS/tasks.c **** 			{
4147:../FreeRTOS/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 5487              		.loc 1 4147 0
 5488 003c 3B6A     		ldr	r3, [r7, #32]
 5489 003e 1A6E     		ldr	r2, [r3, #96]
 5490 0040 3B68     		ldr	r3, [r7]
 5491 0042 1A60     		str	r2, [r3]
 5492              	.L382:
4148:../FreeRTOS/tasks.c **** 			}
4149:../FreeRTOS/tasks.c **** 
4150:../FreeRTOS/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 5493              		.loc 1 4150 0
 5494 0044 3B6A     		ldr	r3, [r7, #32]
 5495 0046 93F86430 		ldrb	r3, [r3, #100]
 5496 004a FB77     		strb	r3, [r7, #31]
4151:../FreeRTOS/tasks.c **** 
4152:../FreeRTOS/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 5497              		.loc 1 4152 0
 5498 004c 3B6A     		ldr	r3, [r7, #32]
 5499 004e 0222     		movs	r2, #2
 5500 0050 83F86420 		strb	r2, [r3, #100]
4153:../FreeRTOS/tasks.c **** 
4154:../FreeRTOS/tasks.c **** 			switch( eAction )
 5501              		.loc 1 4154 0
 5502 0054 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5503 0056 042B     		cmp	r3, #4
 5504 0058 27D8     		bhi	.L383
 5505 005a 01A2     		adr	r2, .L385
 5506 005c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5507              		.p2align 2
 5508              	.L385:
 5509 0060 AB000000 		.word	.L383+1
 5510 0064 75000000 		.word	.L386+1
 5511 0068 83000000 		.word	.L387+1
 5512 006c 8F000000 		.word	.L388+1
 5513 0070 97000000 		.word	.L389+1
 5514              		.p2align 1
 5515              	.L386:
4155:../FreeRTOS/tasks.c **** 			{
4156:../FreeRTOS/tasks.c **** 				case eSetBits	:
4157:../FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 5516              		.loc 1 4157 0
 5517 0074 3B6A     		ldr	r3, [r7, #32]
 5518 0076 1A6E     		ldr	r2, [r3, #96]
 5519 0078 BB68     		ldr	r3, [r7, #8]
 5520 007a 1A43     		orrs	r2, r2, r3
 5521 007c 3B6A     		ldr	r3, [r7, #32]
 5522 007e 1A66     		str	r2, [r3, #96]
4158:../FreeRTOS/tasks.c **** 					break;
 5523              		.loc 1 4158 0
 5524 0080 13E0     		b	.L383
 5525              	.L387:
4159:../FreeRTOS/tasks.c **** 
4160:../FreeRTOS/tasks.c **** 				case eIncrement	:
4161:../FreeRTOS/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 5526              		.loc 1 4161 0
 5527 0082 3B6A     		ldr	r3, [r7, #32]
 5528 0084 1B6E     		ldr	r3, [r3, #96]
 5529 0086 5A1C     		adds	r2, r3, #1
 5530 0088 3B6A     		ldr	r3, [r7, #32]
 5531 008a 1A66     		str	r2, [r3, #96]
4162:../FreeRTOS/tasks.c **** 					break;
 5532              		.loc 1 4162 0
 5533 008c 0DE0     		b	.L383
 5534              	.L388:
4163:../FreeRTOS/tasks.c **** 
4164:../FreeRTOS/tasks.c **** 				case eSetValueWithOverwrite	:
4165:../FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 5535              		.loc 1 4165 0
 5536 008e 3B6A     		ldr	r3, [r7, #32]
 5537 0090 BA68     		ldr	r2, [r7, #8]
 5538 0092 1A66     		str	r2, [r3, #96]
4166:../FreeRTOS/tasks.c **** 					break;
 5539              		.loc 1 4166 0
 5540 0094 09E0     		b	.L383
 5541              	.L389:
4167:../FreeRTOS/tasks.c **** 
4168:../FreeRTOS/tasks.c **** 				case eSetValueWithoutOverwrite :
4169:../FreeRTOS/tasks.c **** 					if( eOriginalNotifyState != eNotified )
 5542              		.loc 1 4169 0
 5543 0096 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 5544 0098 022B     		cmp	r3, #2
 5545 009a 03D0     		beq	.L390
4170:../FreeRTOS/tasks.c **** 					{
4171:../FreeRTOS/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 5546              		.loc 1 4171 0
 5547 009c 3B6A     		ldr	r3, [r7, #32]
 5548 009e BA68     		ldr	r2, [r7, #8]
 5549 00a0 1A66     		str	r2, [r3, #96]
4172:../FreeRTOS/tasks.c **** 					}
4173:../FreeRTOS/tasks.c **** 					else
4174:../FreeRTOS/tasks.c **** 					{
4175:../FreeRTOS/tasks.c **** 						/* The value could not be written to the task. */
4176:../FreeRTOS/tasks.c **** 						xReturn = pdFAIL;
4177:../FreeRTOS/tasks.c **** 					}
4178:../FreeRTOS/tasks.c **** 					break;
 5550              		.loc 1 4178 0
 5551 00a2 01E0     		b	.L396
 5552              	.L390:
4176:../FreeRTOS/tasks.c **** 					}
 5553              		.loc 1 4176 0
 5554 00a4 0023     		movs	r3, #0
 5555 00a6 7B62     		str	r3, [r7, #36]
 5556              	.L396:
 5557              		.loc 1 4178 0
 5558 00a8 00BF     		nop
 5559              	.L383:
4179:../FreeRTOS/tasks.c **** 
4180:../FreeRTOS/tasks.c **** 				case eNoAction:
4181:../FreeRTOS/tasks.c **** 					/* The task is being notified without its notify value being
4182:../FreeRTOS/tasks.c **** 					updated. */
4183:../FreeRTOS/tasks.c **** 					break;
4184:../FreeRTOS/tasks.c **** 			}
4185:../FreeRTOS/tasks.c **** 
4186:../FreeRTOS/tasks.c **** 
4187:../FreeRTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4188:../FreeRTOS/tasks.c **** 			notification then unblock it now. */
4189:../FreeRTOS/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 5560              		.loc 1 4189 0
 5561 00aa FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 5562 00ac 012B     		cmp	r3, #1
 5563 00ae 2DD1     		bne	.L392
4190:../FreeRTOS/tasks.c **** 			{
4191:../FreeRTOS/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 5564              		.loc 1 4191 0
 5565 00b0 3B6A     		ldr	r3, [r7, #32]
 5566 00b2 0433     		adds	r3, r3, #4
 5567 00b4 1846     		mov	r0, r3
 5568 00b6 FFF7FEFF 		bl	uxListRemove
4192:../FreeRTOS/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 5569              		.loc 1 4192 0
 5570 00ba 3B6A     		ldr	r3, [r7, #32]
 5571 00bc DB6A     		ldr	r3, [r3, #44]
 5572 00be 1A46     		mov	r2, r3
 5573 00c0 0123     		movs	r3, #1
 5574 00c2 03FA02F2 		lsl	r2, r3, r2
 5575 00c6 154B     		ldr	r3, .L397
 5576 00c8 1B68     		ldr	r3, [r3]
 5577 00ca 1343     		orrs	r3, r3, r2
 5578 00cc 134A     		ldr	r2, .L397
 5579 00ce 1360     		str	r3, [r2]
 5580 00d0 3B6A     		ldr	r3, [r7, #32]
 5581 00d2 DA6A     		ldr	r2, [r3, #44]
 5582 00d4 1346     		mov	r3, r2
 5583 00d6 9B00     		lsls	r3, r3, #2
 5584 00d8 1344     		add	r3, r3, r2
 5585 00da 9B00     		lsls	r3, r3, #2
 5586 00dc 104A     		ldr	r2, .L397+4
 5587 00de 1A44     		add	r2, r2, r3
 5588 00e0 3B6A     		ldr	r3, [r7, #32]
 5589 00e2 0433     		adds	r3, r3, #4
 5590 00e4 1046     		mov	r0, r2
 5591 00e6 1946     		mov	r1, r3
 5592 00e8 FFF7FEFF 		bl	vListInsertEnd
4193:../FreeRTOS/tasks.c **** 
4194:../FreeRTOS/tasks.c **** 				/* The task should not have been on an event list. */
4195:../FreeRTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5593              		.loc 1 4195 0
 5594 00ec 3B6A     		ldr	r3, [r7, #32]
 5595 00ee 9B6A     		ldr	r3, [r3, #40]
 5596 00f0 002B     		cmp	r3, #0
 5597 00f2 09D0     		beq	.L393
 5598              	.LBB187:
 5599              	.LBB188:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5600              		.loc 2 215 0 discriminator 1
 5601              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5602 00f4 4FF00703 			mov r3, #7												
 5603 00f8 83F31188 		msr basepri, r3											
 5604 00fc BFF36F8F 		isb														
 5605 0100 BFF34F8F 		dsb														
 5606              	
 5607              	@ 0 "" 2
 5608              		.thumb
 5609 0104 7B61     		str	r3, [r7, #20]
 5610              	.L394:
 5611              	.LBE188:
 5612              	.LBE187:
 5613              		.loc 1 4195 0 discriminator 2
 5614 0106 FEE7     		b	.L394
 5615              	.L393:
4196:../FreeRTOS/tasks.c **** 
4197:../FreeRTOS/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4198:../FreeRTOS/tasks.c **** 				{
4199:../FreeRTOS/tasks.c **** 					/* If a task is blocked waiting for a notification then
4200:../FreeRTOS/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4201:../FreeRTOS/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4202:../FreeRTOS/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4203:../FreeRTOS/tasks.c **** 					because it will automatically get reset to a new value when
4204:../FreeRTOS/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4205:../FreeRTOS/tasks.c **** 					tickless idling is used it might be more important to enter
4206:../FreeRTOS/tasks.c **** 					sleep mode at the earliest possible time - so reset
4207:../FreeRTOS/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4208:../FreeRTOS/tasks.c **** 					earliest possible time. */
4209:../FreeRTOS/tasks.c **** 					prvResetNextTaskUnblockTime();
4210:../FreeRTOS/tasks.c **** 				}
4211:../FreeRTOS/tasks.c **** 				#endif
4212:../FreeRTOS/tasks.c **** 
4213:../FreeRTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5616              		.loc 1 4213 0
 5617 0108 064B     		ldr	r3, .L397+8
 5618 010a 1B68     		ldr	r3, [r3]
 5619              	.L392:
4214:../FreeRTOS/tasks.c **** 				{
4215:../FreeRTOS/tasks.c **** 					/* The notified task has a priority above the currently
4216:../FreeRTOS/tasks.c **** 					executing task so a yield is required. */
4217:../FreeRTOS/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4218:../FreeRTOS/tasks.c **** 				}
4219:../FreeRTOS/tasks.c **** 				else
4220:../FreeRTOS/tasks.c **** 				{
4221:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4222:../FreeRTOS/tasks.c **** 				}
4223:../FreeRTOS/tasks.c **** 			}
4224:../FreeRTOS/tasks.c **** 			else
4225:../FreeRTOS/tasks.c **** 			{
4226:../FreeRTOS/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4227:../FreeRTOS/tasks.c **** 			}
4228:../FreeRTOS/tasks.c **** 		}
4229:../FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5620              		.loc 1 4229 0
 5621 010c FFF7FEFF 		bl	vPortExitCritical
4230:../FreeRTOS/tasks.c **** 
4231:../FreeRTOS/tasks.c **** 		return xReturn;
 5622              		.loc 1 4231 0
 5623 0110 7B6A     		ldr	r3, [r7, #36]
4232:../FreeRTOS/tasks.c **** 	}
 5624              		.loc 1 4232 0
 5625 0112 1846     		mov	r0, r3
 5626 0114 2837     		adds	r7, r7, #40
 5627              		.cfi_def_cfa_offset 8
 5628 0116 BD46     		mov	sp, r7
 5629              		.cfi_def_cfa_register 13
 5630              		@ sp needed
 5631 0118 80BD     		pop	{r7, pc}
 5632              	.L398:
 5633 011a 00BF     		.align	2
 5634              	.L397:
 5635 011c 00000000 		.word	uxTopReadyPriority
 5636 0120 00000000 		.word	pxReadyTasksLists
 5637 0124 00000000 		.word	pxCurrentTCB
 5638              		.cfi_endproc
 5639              	.LFE51:
 5641              		.section	.text.xTaskNotifyFromISR,"ax",%progbits
 5642              		.align	2
 5643              		.global	xTaskNotifyFromISR
 5644              		.thumb
 5645              		.thumb_func
 5647              	xTaskNotifyFromISR:
 5648              	.LFB52:
4233:../FreeRTOS/tasks.c **** 
4234:../FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4235:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4236:../FreeRTOS/tasks.c **** 
4237:../FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4238:../FreeRTOS/tasks.c **** 
4239:../FreeRTOS/tasks.c **** 	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4240:../FreeRTOS/tasks.c **** 	{
 5649              		.loc 1 4240 0
 5650              		.cfi_startproc
 5651              		@ args = 0, pretend = 0, frame = 56
 5652              		@ frame_needed = 1, uses_anonymous_args = 0
 5653 0000 80B5     		push	{r7, lr}
 5654              		.cfi_def_cfa_offset 8
 5655              		.cfi_offset 7, -8
 5656              		.cfi_offset 14, -4
 5657 0002 8EB0     		sub	sp, sp, #56
 5658              		.cfi_def_cfa_offset 64
 5659 0004 00AF     		add	r7, sp, #0
 5660              		.cfi_def_cfa_register 7
 5661 0006 F860     		str	r0, [r7, #12]
 5662 0008 B960     		str	r1, [r7, #8]
 5663 000a 3B60     		str	r3, [r7]
 5664 000c 1346     		mov	r3, r2
 5665 000e FB71     		strb	r3, [r7, #7]
4241:../FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
4242:../FreeRTOS/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4243:../FreeRTOS/tasks.c **** 	BaseType_t xReturn = pdPASS;
 5666              		.loc 1 4243 0
 5667 0010 0123     		movs	r3, #1
 5668 0012 7B63     		str	r3, [r7, #52]
4244:../FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4245:../FreeRTOS/tasks.c **** 
4246:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToNotify );
 5669              		.loc 1 4246 0
 5670 0014 FB68     		ldr	r3, [r7, #12]
 5671 0016 002B     		cmp	r3, #0
 5672 0018 09D1     		bne	.L400
 5673              	.LBB189:
 5674              	.LBB190:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5675              		.loc 2 215 0 discriminator 1
 5676              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5677 001a 4FF00703 			mov r3, #7												
 5678 001e 83F31188 		msr basepri, r3											
 5679 0022 BFF36F8F 		isb														
 5680 0026 BFF34F8F 		dsb														
 5681              	
 5682              	@ 0 "" 2
 5683              		.thumb
 5684 002a 7B62     		str	r3, [r7, #36]
 5685              	.L401:
 5686              	.LBE190:
 5687              	.LBE189:
 5688              		.loc 1 4246 0 discriminator 1
 5689 002c FEE7     		b	.L401
 5690              	.L400:
4247:../FreeRTOS/tasks.c **** 
4248:../FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4249:../FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4250:../FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4251:../FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4252:../FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4253:../FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
4254:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4255:../FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4256:../FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
4257:../FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4258:../FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4259:../FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4260:../FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4261:../FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4262:../FreeRTOS/tasks.c **** 		provided on the following link:
4263:../FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4264:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 5691              		.loc 1 4264 0
 5692 002e FFF7FEFF 		bl	vPortValidateInterruptPriority
4265:../FreeRTOS/tasks.c **** 
4266:../FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5693              		.loc 1 4266 0
 5694 0032 FB68     		ldr	r3, [r7, #12]
 5695 0034 3B63     		str	r3, [r7, #48]
 5696              	.LBB191:
 5697              	.LBB192:
 231:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5698              		.loc 2 231 0
 5699              	@ 231 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5700 0036 EFF31182 			mrs r2, basepri											
 5701 003a 4FF00703 		mov r3, #7												
 5702 003e 83F31188 		msr basepri, r3											
 5703 0042 BFF36F8F 		isb														
 5704 0046 BFF34F8F 		dsb														
 5705              	
 5706              	@ 0 "" 2
 5707              		.thumb
 5708 004a 3A62     		str	r2, [r7, #32]
 5709 004c FB61     		str	r3, [r7, #28]
 243:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** }
 5710              		.loc 2 243 0
 5711 004e 3B6A     		ldr	r3, [r7, #32]
 5712              	.LBE192:
 5713              	.LBE191:
4267:../FreeRTOS/tasks.c **** 
4268:../FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5714              		.loc 1 4268 0
 5715 0050 FB62     		str	r3, [r7, #44]
4269:../FreeRTOS/tasks.c **** 		{
4270:../FreeRTOS/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 5716              		.loc 1 4270 0
 5717 0052 3B6B     		ldr	r3, [r7, #48]
 5718 0054 93F86430 		ldrb	r3, [r3, #100]
 5719 0058 87F82B30 		strb	r3, [r7, #43]
4271:../FreeRTOS/tasks.c **** 
4272:../FreeRTOS/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 5720              		.loc 1 4272 0
 5721 005c 3B6B     		ldr	r3, [r7, #48]
 5722 005e 0222     		movs	r2, #2
 5723 0060 83F86420 		strb	r2, [r3, #100]
4273:../FreeRTOS/tasks.c **** 
4274:../FreeRTOS/tasks.c **** 			switch( eAction )
 5724              		.loc 1 4274 0
 5725 0064 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5726 0066 042B     		cmp	r3, #4
 5727 0068 28D8     		bhi	.L403
 5728 006a 01A2     		adr	r2, .L405
 5729 006c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5730              		.p2align 2
 5731              	.L405:
 5732 0070 BD000000 		.word	.L403+1
 5733 0074 85000000 		.word	.L406+1
 5734 0078 93000000 		.word	.L407+1
 5735 007c 9F000000 		.word	.L408+1
 5736 0080 A7000000 		.word	.L409+1
 5737              		.p2align 1
 5738              	.L406:
4275:../FreeRTOS/tasks.c **** 			{
4276:../FreeRTOS/tasks.c **** 				case eSetBits	:
4277:../FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 5739              		.loc 1 4277 0
 5740 0084 3B6B     		ldr	r3, [r7, #48]
 5741 0086 1A6E     		ldr	r2, [r3, #96]
 5742 0088 BB68     		ldr	r3, [r7, #8]
 5743 008a 1A43     		orrs	r2, r2, r3
 5744 008c 3B6B     		ldr	r3, [r7, #48]
 5745 008e 1A66     		str	r2, [r3, #96]
4278:../FreeRTOS/tasks.c **** 					break;
 5746              		.loc 1 4278 0
 5747 0090 14E0     		b	.L403
 5748              	.L407:
4279:../FreeRTOS/tasks.c **** 
4280:../FreeRTOS/tasks.c **** 				case eIncrement	:
4281:../FreeRTOS/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 5749              		.loc 1 4281 0
 5750 0092 3B6B     		ldr	r3, [r7, #48]
 5751 0094 1B6E     		ldr	r3, [r3, #96]
 5752 0096 5A1C     		adds	r2, r3, #1
 5753 0098 3B6B     		ldr	r3, [r7, #48]
 5754 009a 1A66     		str	r2, [r3, #96]
4282:../FreeRTOS/tasks.c **** 					break;
 5755              		.loc 1 4282 0
 5756 009c 0EE0     		b	.L403
 5757              	.L408:
4283:../FreeRTOS/tasks.c **** 
4284:../FreeRTOS/tasks.c **** 				case eSetValueWithOverwrite	:
4285:../FreeRTOS/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 5758              		.loc 1 4285 0
 5759 009e 3B6B     		ldr	r3, [r7, #48]
 5760 00a0 BA68     		ldr	r2, [r7, #8]
 5761 00a2 1A66     		str	r2, [r3, #96]
4286:../FreeRTOS/tasks.c **** 					break;
 5762              		.loc 1 4286 0
 5763 00a4 0AE0     		b	.L403
 5764              	.L409:
4287:../FreeRTOS/tasks.c **** 
4288:../FreeRTOS/tasks.c **** 				case eSetValueWithoutOverwrite :
4289:../FreeRTOS/tasks.c **** 					if( eOriginalNotifyState != eNotified )
 5765              		.loc 1 4289 0
 5766 00a6 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 5767 00aa 022B     		cmp	r3, #2
 5768 00ac 03D0     		beq	.L410
4290:../FreeRTOS/tasks.c **** 					{
4291:../FreeRTOS/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 5769              		.loc 1 4291 0
 5770 00ae 3B6B     		ldr	r3, [r7, #48]
 5771 00b0 BA68     		ldr	r2, [r7, #8]
 5772 00b2 1A66     		str	r2, [r3, #96]
4292:../FreeRTOS/tasks.c **** 					}
4293:../FreeRTOS/tasks.c **** 					else
4294:../FreeRTOS/tasks.c **** 					{
4295:../FreeRTOS/tasks.c **** 						/* The value could not be written to the task. */
4296:../FreeRTOS/tasks.c **** 						xReturn = pdFAIL;
4297:../FreeRTOS/tasks.c **** 					}
4298:../FreeRTOS/tasks.c **** 					break;
 5773              		.loc 1 4298 0
 5774 00b4 01E0     		b	.L419
 5775              	.L410:
4296:../FreeRTOS/tasks.c **** 					}
 5776              		.loc 1 4296 0
 5777 00b6 0023     		movs	r3, #0
 5778 00b8 7B63     		str	r3, [r7, #52]
 5779              	.L419:
 5780              		.loc 1 4298 0
 5781 00ba 00BF     		nop
 5782              	.L403:
4299:../FreeRTOS/tasks.c **** 
4300:../FreeRTOS/tasks.c **** 				case eNoAction :
4301:../FreeRTOS/tasks.c **** 					/* The task is being notified without its notify value being
4302:../FreeRTOS/tasks.c **** 					updated. */
4303:../FreeRTOS/tasks.c **** 					break;
4304:../FreeRTOS/tasks.c **** 			}
4305:../FreeRTOS/tasks.c **** 
4306:../FreeRTOS/tasks.c **** 
4307:../FreeRTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4308:../FreeRTOS/tasks.c **** 			notification then unblock it now. */
4309:../FreeRTOS/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 5783              		.loc 1 4309 0
 5784 00bc 97F82B30 		ldrb	r3, [r7, #43]	@ zero_extendqisi2
 5785 00c0 012B     		cmp	r3, #1
 5786 00c2 43D1     		bne	.L412
4310:../FreeRTOS/tasks.c **** 			{
4311:../FreeRTOS/tasks.c **** 				/* The task should not have been on an event list. */
4312:../FreeRTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5787              		.loc 1 4312 0
 5788 00c4 3B6B     		ldr	r3, [r7, #48]
 5789 00c6 9B6A     		ldr	r3, [r3, #40]
 5790 00c8 002B     		cmp	r3, #0
 5791 00ca 09D0     		beq	.L413
 5792              	.LBB193:
 5793              	.LBB194:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5794              		.loc 2 215 0 discriminator 1
 5795              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5796 00cc 4FF00703 			mov r3, #7												
 5797 00d0 83F31188 		msr basepri, r3											
 5798 00d4 BFF36F8F 		isb														
 5799 00d8 BFF34F8F 		dsb														
 5800              	
 5801              	@ 0 "" 2
 5802              		.thumb
 5803 00dc BB61     		str	r3, [r7, #24]
 5804              	.L414:
 5805              	.LBE194:
 5806              	.LBE193:
 5807              		.loc 1 4312 0 discriminator 2
 5808 00de FEE7     		b	.L414
 5809              	.L413:
4313:../FreeRTOS/tasks.c **** 
4314:../FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 5810              		.loc 1 4314 0
 5811 00e0 1F4B     		ldr	r3, .L420
 5812 00e2 1B68     		ldr	r3, [r3]
 5813 00e4 002B     		cmp	r3, #0
 5814 00e6 1ED1     		bne	.L415
4315:../FreeRTOS/tasks.c **** 				{
4316:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 5815              		.loc 1 4316 0
 5816 00e8 3B6B     		ldr	r3, [r7, #48]
 5817 00ea 0433     		adds	r3, r3, #4
 5818 00ec 1846     		mov	r0, r3
 5819 00ee FFF7FEFF 		bl	uxListRemove
4317:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 5820              		.loc 1 4317 0
 5821 00f2 3B6B     		ldr	r3, [r7, #48]
 5822 00f4 DB6A     		ldr	r3, [r3, #44]
 5823 00f6 1A46     		mov	r2, r3
 5824 00f8 0123     		movs	r3, #1
 5825 00fa 03FA02F2 		lsl	r2, r3, r2
 5826 00fe 194B     		ldr	r3, .L420+4
 5827 0100 1B68     		ldr	r3, [r3]
 5828 0102 1343     		orrs	r3, r3, r2
 5829 0104 174A     		ldr	r2, .L420+4
 5830 0106 1360     		str	r3, [r2]
 5831 0108 3B6B     		ldr	r3, [r7, #48]
 5832 010a DA6A     		ldr	r2, [r3, #44]
 5833 010c 1346     		mov	r3, r2
 5834 010e 9B00     		lsls	r3, r3, #2
 5835 0110 1344     		add	r3, r3, r2
 5836 0112 9B00     		lsls	r3, r3, #2
 5837 0114 144A     		ldr	r2, .L420+8
 5838 0116 1A44     		add	r2, r2, r3
 5839 0118 3B6B     		ldr	r3, [r7, #48]
 5840 011a 0433     		adds	r3, r3, #4
 5841 011c 1046     		mov	r0, r2
 5842 011e 1946     		mov	r1, r3
 5843 0120 FFF7FEFF 		bl	vListInsertEnd
 5844 0124 05E0     		b	.L416
 5845              	.L415:
4318:../FreeRTOS/tasks.c **** 				}
4319:../FreeRTOS/tasks.c **** 				else
4320:../FreeRTOS/tasks.c **** 				{
4321:../FreeRTOS/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4322:../FreeRTOS/tasks.c **** 					this task pending until the scheduler is resumed. */
4323:../FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5846              		.loc 1 4323 0
 5847 0126 3B6B     		ldr	r3, [r7, #48]
 5848 0128 1833     		adds	r3, r3, #24
 5849 012a 1048     		ldr	r0, .L420+12
 5850 012c 1946     		mov	r1, r3
 5851 012e FFF7FEFF 		bl	vListInsertEnd
 5852              	.L416:
4324:../FreeRTOS/tasks.c **** 				}
4325:../FreeRTOS/tasks.c **** 
4326:../FreeRTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5853              		.loc 1 4326 0
 5854 0132 3B6B     		ldr	r3, [r7, #48]
 5855 0134 DA6A     		ldr	r2, [r3, #44]
 5856 0136 0E4B     		ldr	r3, .L420+16
 5857 0138 1B68     		ldr	r3, [r3]
 5858 013a DB6A     		ldr	r3, [r3, #44]
 5859 013c 9A42     		cmp	r2, r3
 5860 013e 05D9     		bls	.L412
4327:../FreeRTOS/tasks.c **** 				{
4328:../FreeRTOS/tasks.c **** 					/* The notified task has a priority above the currently
4329:../FreeRTOS/tasks.c **** 					executing task so a yield is required. */
4330:../FreeRTOS/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 5861              		.loc 1 4330 0
 5862 0140 3B68     		ldr	r3, [r7]
 5863 0142 002B     		cmp	r3, #0
 5864 0144 02D0     		beq	.L412
4331:../FreeRTOS/tasks.c **** 					{
4332:../FreeRTOS/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 5865              		.loc 1 4332 0
 5866 0146 3B68     		ldr	r3, [r7]
 5867 0148 0122     		movs	r2, #1
 5868 014a 1A60     		str	r2, [r3]
 5869              	.L412:
 5870 014c FB6A     		ldr	r3, [r7, #44]
 5871 014e 7B61     		str	r3, [r7, #20]
 5872              	.LBB195:
 5873              	.LBB196:
 5874              		.loc 2 249 0
 5875 0150 7B69     		ldr	r3, [r7, #20]
 5876              	@ 249 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5877 0152 83F31188 			msr basepri, r3	
 5878              	@ 0 "" 2
 5879              		.thumb
 5880              	.LBE196:
 5881              	.LBE195:
4333:../FreeRTOS/tasks.c **** 					}
4334:../FreeRTOS/tasks.c **** 				}
4335:../FreeRTOS/tasks.c **** 				else
4336:../FreeRTOS/tasks.c **** 				{
4337:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4338:../FreeRTOS/tasks.c **** 				}
4339:../FreeRTOS/tasks.c **** 			}
4340:../FreeRTOS/tasks.c **** 		}
4341:../FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4342:../FreeRTOS/tasks.c **** 
4343:../FreeRTOS/tasks.c **** 		return xReturn;
 5882              		.loc 1 4343 0
 5883 0156 7B6B     		ldr	r3, [r7, #52]
4344:../FreeRTOS/tasks.c **** 	}
 5884              		.loc 1 4344 0
 5885 0158 1846     		mov	r0, r3
 5886 015a 3837     		adds	r7, r7, #56
 5887              		.cfi_def_cfa_offset 8
 5888 015c BD46     		mov	sp, r7
 5889              		.cfi_def_cfa_register 13
 5890              		@ sp needed
 5891 015e 80BD     		pop	{r7, pc}
 5892              	.L421:
 5893              		.align	2
 5894              	.L420:
 5895 0160 00000000 		.word	uxSchedulerSuspended
 5896 0164 00000000 		.word	uxTopReadyPriority
 5897 0168 00000000 		.word	pxReadyTasksLists
 5898 016c 00000000 		.word	xPendingReadyList
 5899 0170 00000000 		.word	pxCurrentTCB
 5900              		.cfi_endproc
 5901              	.LFE52:
 5903              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 5904              		.align	2
 5905              		.global	vTaskNotifyGiveFromISR
 5906              		.thumb
 5907              		.thumb_func
 5909              	vTaskNotifyGiveFromISR:
 5910              	.LFB53:
4345:../FreeRTOS/tasks.c **** 
4346:../FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4347:../FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4348:../FreeRTOS/tasks.c **** 
4349:../FreeRTOS/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4350:../FreeRTOS/tasks.c **** 
4351:../FreeRTOS/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4352:../FreeRTOS/tasks.c **** 	{
 5911              		.loc 1 4352 0
 5912              		.cfi_startproc
 5913              		@ args = 0, pretend = 0, frame = 40
 5914              		@ frame_needed = 1, uses_anonymous_args = 0
 5915 0000 80B5     		push	{r7, lr}
 5916              		.cfi_def_cfa_offset 8
 5917              		.cfi_offset 7, -8
 5918              		.cfi_offset 14, -4
 5919 0002 8AB0     		sub	sp, sp, #40
 5920              		.cfi_def_cfa_offset 48
 5921 0004 00AF     		add	r7, sp, #0
 5922              		.cfi_def_cfa_register 7
 5923 0006 7860     		str	r0, [r7, #4]
 5924 0008 3960     		str	r1, [r7]
4353:../FreeRTOS/tasks.c **** 	TCB_t * pxTCB;
4354:../FreeRTOS/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4355:../FreeRTOS/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4356:../FreeRTOS/tasks.c **** 
4357:../FreeRTOS/tasks.c **** 		configASSERT( xTaskToNotify );
 5925              		.loc 1 4357 0
 5926 000a 7B68     		ldr	r3, [r7, #4]
 5927 000c 002B     		cmp	r3, #0
 5928 000e 09D1     		bne	.L423
 5929              	.LBB197:
 5930              	.LBB198:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5931              		.loc 2 215 0 discriminator 1
 5932              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5933 0010 4FF00703 			mov r3, #7												
 5934 0014 83F31188 		msr basepri, r3											
 5935 0018 BFF36F8F 		isb														
 5936 001c BFF34F8F 		dsb														
 5937              	
 5938              	@ 0 "" 2
 5939              		.thumb
 5940 0020 BB61     		str	r3, [r7, #24]
 5941              	.L424:
 5942              	.LBE198:
 5943              	.LBE197:
 5944              		.loc 1 4357 0 discriminator 1
 5945 0022 FEE7     		b	.L424
 5946              	.L423:
4358:../FreeRTOS/tasks.c **** 
4359:../FreeRTOS/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4360:../FreeRTOS/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4361:../FreeRTOS/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4362:../FreeRTOS/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4363:../FreeRTOS/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4364:../FreeRTOS/tasks.c **** 		is defined in FreeRTOSConfig.h then
4365:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4366:../FreeRTOS/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4367:../FreeRTOS/tasks.c **** 		been assigned a priority above the configured maximum system call
4368:../FreeRTOS/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4369:../FreeRTOS/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4370:../FreeRTOS/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4371:../FreeRTOS/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4372:../FreeRTOS/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4373:../FreeRTOS/tasks.c **** 		provided on the following link:
4374:../FreeRTOS/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4375:../FreeRTOS/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 5947              		.loc 1 4375 0
 5948 0024 FFF7FEFF 		bl	vPortValidateInterruptPriority
4376:../FreeRTOS/tasks.c **** 
4377:../FreeRTOS/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 5949              		.loc 1 4377 0
 5950 0028 7B68     		ldr	r3, [r7, #4]
 5951 002a 7B62     		str	r3, [r7, #36]
 5952              	.LBB199:
 5953              	.LBB200:
 231:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5954              		.loc 2 231 0
 5955              	@ 231 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5956 002c EFF31182 			mrs r2, basepri											
 5957 0030 4FF00703 		mov r3, #7												
 5958 0034 83F31188 		msr basepri, r3											
 5959 0038 BFF36F8F 		isb														
 5960 003c BFF34F8F 		dsb														
 5961              	
 5962              	@ 0 "" 2
 5963              		.thumb
 5964 0040 7A61     		str	r2, [r7, #20]
 5965 0042 3B61     		str	r3, [r7, #16]
 243:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** }
 5966              		.loc 2 243 0
 5967 0044 7B69     		ldr	r3, [r7, #20]
 5968              	.LBE200:
 5969              	.LBE199:
4378:../FreeRTOS/tasks.c **** 
4379:../FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5970              		.loc 1 4379 0
 5971 0046 3B62     		str	r3, [r7, #32]
4380:../FreeRTOS/tasks.c **** 		{
4381:../FreeRTOS/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 5972              		.loc 1 4381 0
 5973 0048 7B6A     		ldr	r3, [r7, #36]
 5974 004a 93F86430 		ldrb	r3, [r3, #100]
 5975 004e FB77     		strb	r3, [r7, #31]
4382:../FreeRTOS/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 5976              		.loc 1 4382 0
 5977 0050 7B6A     		ldr	r3, [r7, #36]
 5978 0052 0222     		movs	r2, #2
 5979 0054 83F86420 		strb	r2, [r3, #100]
4383:../FreeRTOS/tasks.c **** 
4384:../FreeRTOS/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4385:../FreeRTOS/tasks.c **** 			semaphore. */
4386:../FreeRTOS/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 5980              		.loc 1 4386 0
 5981 0058 7B6A     		ldr	r3, [r7, #36]
 5982 005a 1B6E     		ldr	r3, [r3, #96]
 5983 005c 5A1C     		adds	r2, r3, #1
 5984 005e 7B6A     		ldr	r3, [r7, #36]
 5985 0060 1A66     		str	r2, [r3, #96]
4387:../FreeRTOS/tasks.c **** 
4388:../FreeRTOS/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4389:../FreeRTOS/tasks.c **** 			notification then unblock it now. */
4390:../FreeRTOS/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 5986              		.loc 1 4390 0
 5987 0062 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 5988 0064 012B     		cmp	r3, #1
 5989 0066 43D1     		bne	.L426
4391:../FreeRTOS/tasks.c **** 			{
4392:../FreeRTOS/tasks.c **** 				/* The task should not have been on an event list. */
4393:../FreeRTOS/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5990              		.loc 1 4393 0
 5991 0068 7B6A     		ldr	r3, [r7, #36]
 5992 006a 9B6A     		ldr	r3, [r3, #40]
 5993 006c 002B     		cmp	r3, #0
 5994 006e 09D0     		beq	.L427
 5995              	.LBB201:
 5996              	.LBB202:
 215:/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h **** 	(
 5997              		.loc 2 215 0 discriminator 1
 5998              	@ 215 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 5999 0070 4FF00703 			mov r3, #7												
 6000 0074 83F31188 		msr basepri, r3											
 6001 0078 BFF36F8F 		isb														
 6002 007c BFF34F8F 		dsb														
 6003              	
 6004              	@ 0 "" 2
 6005              		.thumb
 6006 0080 FB60     		str	r3, [r7, #12]
 6007              	.L428:
 6008              	.LBE202:
 6009              	.LBE201:
 6010              		.loc 1 4393 0 discriminator 2
 6011 0082 FEE7     		b	.L428
 6012              	.L427:
4394:../FreeRTOS/tasks.c **** 
4395:../FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 6013              		.loc 1 4395 0
 6014 0084 1E4B     		ldr	r3, .L432
 6015 0086 1B68     		ldr	r3, [r3]
 6016 0088 002B     		cmp	r3, #0
 6017 008a 1ED1     		bne	.L429
4396:../FreeRTOS/tasks.c **** 				{
4397:../FreeRTOS/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 6018              		.loc 1 4397 0
 6019 008c 7B6A     		ldr	r3, [r7, #36]
 6020 008e 0433     		adds	r3, r3, #4
 6021 0090 1846     		mov	r0, r3
 6022 0092 FFF7FEFF 		bl	uxListRemove
4398:../FreeRTOS/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 6023              		.loc 1 4398 0
 6024 0096 7B6A     		ldr	r3, [r7, #36]
 6025 0098 DB6A     		ldr	r3, [r3, #44]
 6026 009a 1A46     		mov	r2, r3
 6027 009c 0123     		movs	r3, #1
 6028 009e 03FA02F2 		lsl	r2, r3, r2
 6029 00a2 184B     		ldr	r3, .L432+4
 6030 00a4 1B68     		ldr	r3, [r3]
 6031 00a6 1343     		orrs	r3, r3, r2
 6032 00a8 164A     		ldr	r2, .L432+4
 6033 00aa 1360     		str	r3, [r2]
 6034 00ac 7B6A     		ldr	r3, [r7, #36]
 6035 00ae DA6A     		ldr	r2, [r3, #44]
 6036 00b0 1346     		mov	r3, r2
 6037 00b2 9B00     		lsls	r3, r3, #2
 6038 00b4 1344     		add	r3, r3, r2
 6039 00b6 9B00     		lsls	r3, r3, #2
 6040 00b8 134A     		ldr	r2, .L432+8
 6041 00ba 1A44     		add	r2, r2, r3
 6042 00bc 7B6A     		ldr	r3, [r7, #36]
 6043 00be 0433     		adds	r3, r3, #4
 6044 00c0 1046     		mov	r0, r2
 6045 00c2 1946     		mov	r1, r3
 6046 00c4 FFF7FEFF 		bl	vListInsertEnd
 6047 00c8 05E0     		b	.L430
 6048              	.L429:
4399:../FreeRTOS/tasks.c **** 				}
4400:../FreeRTOS/tasks.c **** 				else
4401:../FreeRTOS/tasks.c **** 				{
4402:../FreeRTOS/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4403:../FreeRTOS/tasks.c **** 					this task pending until the scheduler is resumed. */
4404:../FreeRTOS/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 6049              		.loc 1 4404 0
 6050 00ca 7B6A     		ldr	r3, [r7, #36]
 6051 00cc 1833     		adds	r3, r3, #24
 6052 00ce 0F48     		ldr	r0, .L432+12
 6053 00d0 1946     		mov	r1, r3
 6054 00d2 FFF7FEFF 		bl	vListInsertEnd
 6055              	.L430:
4405:../FreeRTOS/tasks.c **** 				}
4406:../FreeRTOS/tasks.c **** 
4407:../FreeRTOS/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 6056              		.loc 1 4407 0
 6057 00d6 7B6A     		ldr	r3, [r7, #36]
 6058 00d8 DA6A     		ldr	r2, [r3, #44]
 6059 00da 0D4B     		ldr	r3, .L432+16
 6060 00dc 1B68     		ldr	r3, [r3]
 6061 00de DB6A     		ldr	r3, [r3, #44]
 6062 00e0 9A42     		cmp	r2, r3
 6063 00e2 05D9     		bls	.L426
4408:../FreeRTOS/tasks.c **** 				{
4409:../FreeRTOS/tasks.c **** 					/* The notified task has a priority above the currently
4410:../FreeRTOS/tasks.c **** 					executing task so a yield is required. */
4411:../FreeRTOS/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 6064              		.loc 1 4411 0
 6065 00e4 3B68     		ldr	r3, [r7]
 6066 00e6 002B     		cmp	r3, #0
 6067 00e8 02D0     		beq	.L426
4412:../FreeRTOS/tasks.c **** 					{
4413:../FreeRTOS/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 6068              		.loc 1 4413 0
 6069 00ea 3B68     		ldr	r3, [r7]
 6070 00ec 0122     		movs	r2, #1
 6071 00ee 1A60     		str	r2, [r3]
 6072              	.L426:
 6073 00f0 3B6A     		ldr	r3, [r7, #32]
 6074 00f2 BB60     		str	r3, [r7, #8]
 6075              	.LBB203:
 6076              	.LBB204:
 6077              		.loc 2 249 0
 6078 00f4 BB68     		ldr	r3, [r7, #8]
 6079              	@ 249 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/../../Free
 6080 00f6 83F31188 			msr basepri, r3	
 6081              	@ 0 "" 2
 6082              		.thumb
 6083              	.LBE204:
 6084              	.LBE203:
4414:../FreeRTOS/tasks.c **** 					}
4415:../FreeRTOS/tasks.c **** 				}
4416:../FreeRTOS/tasks.c **** 				else
4417:../FreeRTOS/tasks.c **** 				{
4418:../FreeRTOS/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4419:../FreeRTOS/tasks.c **** 				}
4420:../FreeRTOS/tasks.c **** 			}
4421:../FreeRTOS/tasks.c **** 		}
4422:../FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4423:../FreeRTOS/tasks.c **** 	}
 6085              		.loc 1 4423 0
 6086 00fa 2837     		adds	r7, r7, #40
 6087              		.cfi_def_cfa_offset 8
 6088 00fc BD46     		mov	sp, r7
 6089              		.cfi_def_cfa_register 13
 6090              		@ sp needed
 6091 00fe 80BD     		pop	{r7, pc}
 6092              	.L433:
 6093              		.align	2
 6094              	.L432:
 6095 0100 00000000 		.word	uxSchedulerSuspended
 6096 0104 00000000 		.word	uxTopReadyPriority
 6097 0108 00000000 		.word	pxReadyTasksLists
 6098 010c 00000000 		.word	xPendingReadyList
 6099 0110 00000000 		.word	pxCurrentTCB
 6100              		.cfi_endproc
 6101              	.LFE53:
 6103              		.text
 6104              	.Letext0:
 6105              		.file 3 "/home/houxd/prog/NXP/S32DS_ARM_v2.0/S32DS/arm_ewl2/EWL_C/include/size_t.h"
 6106              		.file 4 "/home/houxd/prog/NXP/S32DS_ARM_v2.0/S32DS/arm_ewl2/EWL_C/include/cstdint"
 6107              		.file 5 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/projdef
 6108              		.file 6 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/../../FreeRTOS/include/list.h"
 6109              		.file 7 "/home/houxd/workspaceS32DS.ARM.V20/dp1000/FreeRTOS/include/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccy1HA7z.s:25     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccy1HA7z.s:22     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccy1HA7z.s:28     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccy1HA7z.s:31     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccy1HA7z.s:34     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccy1HA7z.s:37     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccy1HA7z.s:40     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccy1HA7z.s:43     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccy1HA7z.s:46     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccy1HA7z.s:49     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccy1HA7z.s:52     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccy1HA7z.s:55     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccy1HA7z.s:58     .bss.xPendingReadyList:00000000 $d
     /tmp/ccy1HA7z.s:61     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccy1HA7z.s:64     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccy1HA7z.s:67     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccy1HA7z.s:70     .bss.uxTasksDeleted:00000000 $d
     /tmp/ccy1HA7z.s:73     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccy1HA7z.s:76     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccy1HA7z.s:79     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccy1HA7z.s:82     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccy1HA7z.s:85     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccy1HA7z.s:88     .bss.xTickCount:00000000 $d
     /tmp/ccy1HA7z.s:91     .bss.xTickCount:00000000 xTickCount
     /tmp/ccy1HA7z.s:94     .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccy1HA7z.s:97     .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccy1HA7z.s:100    .bss.xSchedulerRunning:00000000 $d
     /tmp/ccy1HA7z.s:103    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccy1HA7z.s:106    .bss.uxPendedTicks:00000000 $d
     /tmp/ccy1HA7z.s:109    .bss.uxPendedTicks:00000000 uxPendedTicks
     /tmp/ccy1HA7z.s:112    .bss.xYieldPending:00000000 $d
     /tmp/ccy1HA7z.s:115    .bss.xYieldPending:00000000 xYieldPending
     /tmp/ccy1HA7z.s:118    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccy1HA7z.s:121    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccy1HA7z.s:124    .bss.uxTaskNumber:00000000 $d
     /tmp/ccy1HA7z.s:127    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccy1HA7z.s:130    .bss.xNextTaskUnblockTime:00000000 $d
     /tmp/ccy1HA7z.s:133    .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccy1HA7z.s:136    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccy1HA7z.s:139    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccy1HA7z.s:142    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccy1HA7z.s:147    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccy1HA7z.s:4218   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/ccy1HA7z.s:3833   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/ccy1HA7z.s:3957   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccy1HA7z.s:393    .text.xTaskGenericCreate:00000168 $d
     /tmp/ccy1HA7z.s:403    .text.vTaskDelete:00000000 $t
     /tmp/ccy1HA7z.s:408    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccy1HA7z.s:4473   .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
     /tmp/ccy1HA7z.s:567    .text.vTaskDelete:000000e0 $d
     /tmp/ccy1HA7z.s:580    .text.vTaskDelayUntil:00000000 $t
     /tmp/ccy1HA7z.s:585    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccy1HA7z.s:2054   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccy1HA7z.s:4138   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccy1HA7z.s:2093   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccy1HA7z.s:787    .text.vTaskDelayUntil:00000108 $d
     /tmp/ccy1HA7z.s:796    .text.vTaskDelay:00000000 $t
     /tmp/ccy1HA7z.s:801    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccy1HA7z.s:910    .text.vTaskDelay:00000090 $d
     /tmp/ccy1HA7z.s:919    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccy1HA7z.s:924    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccy1HA7z.s:974    .text.uxTaskPriorityGet:00000030 $d
     /tmp/ccy1HA7z.s:979    .text.uxTaskPriorityGetFromISR:00000000 $t
     /tmp/ccy1HA7z.s:984    .text.uxTaskPriorityGetFromISR:00000000 uxTaskPriorityGetFromISR
     /tmp/ccy1HA7z.s:1064   .text.uxTaskPriorityGetFromISR:00000054 $d
     /tmp/ccy1HA7z.s:1069   .text.vTaskPrioritySet:00000000 $t
     /tmp/ccy1HA7z.s:1074   .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccy1HA7z.s:1290   .text.vTaskPrioritySet:00000138 $d
     /tmp/ccy1HA7z.s:1297   .text.vTaskSuspend:00000000 $t
     /tmp/ccy1HA7z.s:1302   .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccy1HA7z.s:2709   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccy1HA7z.s:1471   .text.vTaskSuspend:000000f0 $d
     /tmp/ccy1HA7z.s:1483   .text.prvTaskIsTaskSuspended:00000000 $t
     /tmp/ccy1HA7z.s:1487   .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
     /tmp/ccy1HA7z.s:1587   .text.prvTaskIsTaskSuspended:0000006c $d
     /tmp/ccy1HA7z.s:1593   .text.vTaskResume:00000000 $t
     /tmp/ccy1HA7z.s:1598   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccy1HA7z.s:1702   .text.vTaskResume:00000090 $d
     /tmp/ccy1HA7z.s:1709   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccy1HA7z.s:1714   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccy1HA7z.s:1865   .text.xTaskResumeFromISR:000000d0 $d
     /tmp/ccy1HA7z.s:1874   .rodata:00000000 $d
     /tmp/ccy1HA7z.s:1878   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccy1HA7z.s:1883   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccy1HA7z.s:1986   .text.vTaskStartScheduler:00000084 $d
     /tmp/ccy1HA7z.s:3790   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccy1HA7z.s:1995   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccy1HA7z.s:2000   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccy1HA7z.s:2044   .text.vTaskEndScheduler:00000028 $d
     /tmp/ccy1HA7z.s:2049   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccy1HA7z.s:2083   .text.vTaskSuspendAll:00000018 $d
     /tmp/ccy1HA7z.s:2088   .text.xTaskResumeAll:00000000 $t
     /tmp/ccy1HA7z.s:2483   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
     /tmp/ccy1HA7z.s:2261   .text.xTaskResumeAll:000000f0 $d
     /tmp/ccy1HA7z.s:2273   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccy1HA7z.s:2278   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccy1HA7z.s:2312   .text.xTaskGetTickCount:0000001c $d
     /tmp/ccy1HA7z.s:2317   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccy1HA7z.s:2322   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccy1HA7z.s:2358   .text.xTaskGetTickCountFromISR:00000020 $d
     /tmp/ccy1HA7z.s:2363   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccy1HA7z.s:2368   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccy1HA7z.s:2395   .text.uxTaskGetNumberOfTasks:00000014 $d
     /tmp/ccy1HA7z.s:2400   .text.pcTaskGetTaskName:00000000 $t
     /tmp/ccy1HA7z.s:2405   .text.pcTaskGetTaskName:00000000 pcTaskGetTaskName
     /tmp/ccy1HA7z.s:2473   .text.pcTaskGetTaskName:00000044 $d
     /tmp/ccy1HA7z.s:2478   .text.xTaskIncrementTick:00000000 $t
     /tmp/ccy1HA7z.s:2691   .text.xTaskIncrementTick:00000128 $d
     /tmp/ccy1HA7z.s:2704   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccy1HA7z.s:2853   .text.vTaskSwitchContext:000000bc $d
     /tmp/ccy1HA7z.s:2862   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccy1HA7z.s:2867   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccy1HA7z.s:2968   .text.vTaskPlaceOnEventList:0000008c $d
     /tmp/ccy1HA7z.s:2976   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
     /tmp/ccy1HA7z.s:2981   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
     /tmp/ccy1HA7z.s:3112   .text.vTaskPlaceOnUnorderedEventList:000000b4 $d
     /tmp/ccy1HA7z.s:3121   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/ccy1HA7z.s:3126   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
     /tmp/ccy1HA7z.s:3228   .text.vTaskPlaceOnEventListRestricted:0000008c $d
     /tmp/ccy1HA7z.s:3236   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccy1HA7z.s:3241   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccy1HA7z.s:3365   .text.xTaskRemoveFromEventList:000000b0 $d
     /tmp/ccy1HA7z.s:3375   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
     /tmp/ccy1HA7z.s:3380   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
     /tmp/ccy1HA7z.s:3516   .text.xTaskRemoveFromUnorderedEventList:000000bc $d
     /tmp/ccy1HA7z.s:3525   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccy1HA7z.s:3530   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccy1HA7z.s:3590   .text.vTaskSetTimeOutState:0000003c $d
     /tmp/ccy1HA7z.s:3596   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccy1HA7z.s:3601   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccy1HA7z.s:3743   .text.xTaskCheckForTimeOut:000000b4 $d
     /tmp/ccy1HA7z.s:3749   .text.vTaskMissedYield:00000000 $t
     /tmp/ccy1HA7z.s:3754   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccy1HA7z.s:3781   .text.vTaskMissedYield:00000014 $d
     /tmp/ccy1HA7z.s:3786   .text.prvIdleTask:00000000 $t
     /tmp/ccy1HA7z.s:4044   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccy1HA7z.s:3824   .text.prvIdleTask:00000020 $d
     /tmp/ccy1HA7z.s:3829   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/ccy1HA7z.s:3953   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccy1HA7z.s:4028   .text.prvInitialiseTaskLists:0000005c $d
     /tmp/ccy1HA7z.s:4040   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccy1HA7z.s:4435   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccy1HA7z.s:4127   .text.prvCheckTasksWaitingTermination:00000068 $d
     /tmp/ccy1HA7z.s:4134   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/ccy1HA7z.s:4205   .text.prvAddCurrentTaskToDelayedList:00000058 $d
     /tmp/ccy1HA7z.s:4214   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/ccy1HA7z.s:4309   .text.prvTaskCheckFreeStackSpace:00000000 $t
     /tmp/ccy1HA7z.s:4313   .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
     /tmp/ccy1HA7z.s:4370   .text.uxTaskGetStackHighWaterMark:00000000 $t
     /tmp/ccy1HA7z.s:4375   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
     /tmp/ccy1HA7z.s:4426   .text.uxTaskGetStackHighWaterMark:00000034 $d
     /tmp/ccy1HA7z.s:4431   .text.prvDeleteTCB:00000000 $t
     /tmp/ccy1HA7z.s:4469   .text.prvResetNextTaskUnblockTime:00000000 $t
     /tmp/ccy1HA7z.s:4534   .text.prvResetNextTaskUnblockTime:00000040 $d
     /tmp/ccy1HA7z.s:4540   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccy1HA7z.s:4545   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccy1HA7z.s:4579   .text.xTaskGetCurrentTaskHandle:0000001c $d
     /tmp/ccy1HA7z.s:4584   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/ccy1HA7z.s:4589   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/ccy1HA7z.s:4643   .text.xTaskGetSchedulerState:00000034 $d
     /tmp/ccy1HA7z.s:4649   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccy1HA7z.s:4654   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccy1HA7z.s:4802   .text.vTaskPriorityInherit:000000e4 $d
     /tmp/ccy1HA7z.s:4809   .text.xTaskPriorityDisinherit:00000000 $t
     /tmp/ccy1HA7z.s:4814   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
     /tmp/ccy1HA7z.s:4989   .text.xTaskPriorityDisinherit:00000100 $d
     /tmp/ccy1HA7z.s:4996   .text.uxTaskResetEventItemValue:00000000 $t
     /tmp/ccy1HA7z.s:5001   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
     /tmp/ccy1HA7z.s:5044   .text.uxTaskResetEventItemValue:0000002c $d
     /tmp/ccy1HA7z.s:5049   .text.pvTaskIncrementMutexHeldCount:00000000 $t
     /tmp/ccy1HA7z.s:5054   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
     /tmp/ccy1HA7z.s:5093   .text.pvTaskIncrementMutexHeldCount:00000024 $d
     /tmp/ccy1HA7z.s:5098   .text.ulTaskNotifyTake:00000000 $t
     /tmp/ccy1HA7z.s:5103   .text.ulTaskNotifyTake:00000000 ulTaskNotifyTake
     /tmp/ccy1HA7z.s:5245   .text.ulTaskNotifyTake:000000d4 $d
     /tmp/ccy1HA7z.s:5254   .text.xTaskNotifyWait:00000000 $t
     /tmp/ccy1HA7z.s:5259   .text.xTaskNotifyWait:00000000 xTaskNotifyWait
     /tmp/ccy1HA7z.s:5420   .text.xTaskNotifyWait:000000f8 $d
     /tmp/ccy1HA7z.s:5429   .text.xTaskGenericNotify:00000000 $t
     /tmp/ccy1HA7z.s:5434   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
     /tmp/ccy1HA7z.s:5509   .text.xTaskGenericNotify:00000060 $d
     /tmp/ccy1HA7z.s:5514   .text.xTaskGenericNotify:00000074 $t
     /tmp/ccy1HA7z.s:5635   .text.xTaskGenericNotify:0000011c $d
     /tmp/ccy1HA7z.s:5642   .text.xTaskNotifyFromISR:00000000 $t
     /tmp/ccy1HA7z.s:5647   .text.xTaskNotifyFromISR:00000000 xTaskNotifyFromISR
     /tmp/ccy1HA7z.s:5732   .text.xTaskNotifyFromISR:00000070 $d
     /tmp/ccy1HA7z.s:5737   .text.xTaskNotifyFromISR:00000084 $t
     /tmp/ccy1HA7z.s:5895   .text.xTaskNotifyFromISR:00000160 $d
     /tmp/ccy1HA7z.s:5904   .text.vTaskNotifyGiveFromISR:00000000 $t
     /tmp/ccy1HA7z.s:5909   .text.vTaskNotifyGiveFromISR:00000000 vTaskNotifyGiveFromISR
     /tmp/ccy1HA7z.s:6095   .text.vTaskNotifyGiveFromISR:00000100 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.728a2e6911dc01ff85c2d70c52e8fae1
                           .group:00000000 wm4.lib_c99.prefix.8.3580c292f50811c682d980dc4180498e
                           .group:00000000 wm4.common.prefix.16.d7bf937cdf46fd76dde96b376e3b328a
                           .group:00000000 wm4.ewl_c_version.h.9.0bcb57d6a3f89baae1f9b121de2772f5
                           .group:00000000 wm4.os_enum.h.9.f9446d6af68b3fa72a37d4d924d3b347
                           .group:00000000 wm4.ansi_prefix.ARM.h.13.4b23f4c654df3c3277534542f67d200c
                           .group:00000000 wm4.ansi_parms.h.64.90aed58330fdde08746db908036e1f37
                           .group:00000000 wm4.size_t.h.9.f983491a73b5c81f421ee8223b1ac5c0
                           .group:00000000 wm4.ewl_lib_ext1.h.14.f9b057cc049671136093886db2a3473f
                           .group:00000000 wm4.ewl_rsize_t.h.11.b283831bb803e76ceb1756da2df9a1b5
                           .group:00000000 wm4.wchar_t.h.9.94198016f5b5f455e54ea1f3f054b416
                           .group:00000000 wm4.limits_api.h.9.bc6daa20b3abae2bba6c512044e73b43
                           .group:00000000 wm4.cstdint.134.883feaa2838fb8c945f155045ce06256
                           .group:00000000 wm4.cstdlib.44.e27e649b4051799f046eccdb898dfe03
                           .group:00000000 wm4.string_api.h.9.a9265430fd330d238bc93998aef29e99
                           .group:00000000 wm4.cstddef.32.067e2ea187472b6198f9ace951e27a51
                           .group:00000000 wm4.FreeRTOSConfig.h.72.75cb346dabad37f1d1a80e0a337065ed
                           .group:00000000 wm4.projdefs.h.71.b3c50e668908413922aad758934ec914
                           .group:00000000 wm4.portmacro.h.72.f619b572c99e5bd3ac77abd33efb542d
                           .group:00000000 wm4.portable.h.106.61ffdda1afafb5a5e1f7197ade95b43a
                           .group:00000000 wm4.mpu_wrappers.h.71.dd245fe44d82bd40288b5a47f895c82c
                           .group:00000000 wm4.FreeRTOS.h.179.860507a4e765cb3b74f37181fc3c9df6
                           .group:00000000 wm4.list.h.103.6a12b7b9a7a136c3cca0ee53675c5498
                           .group:00000000 wm4.task.h.88.249f28f82749d6a86cb49478ec501d6f
                           .group:00000000 wm4.timers.h.96.6d8400d69a49ecea6915b6a9d26422a9
                           .group:00000000 wm4.StackMacros.h.71.fde88348a4450a040c0db0a023c7fb31

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
uxListRemove
vPortValidateInterruptPriority
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vApplicationStackOverflowHook
vListInsert
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
